---
title: "C谩lculo del 铆ndice"
subtitle: 'ndice de pobreza 2022 / Python'
author: "Diana Villasana Ocampo"
output:
   html_document:
      highlight: tango
      theme: flatly
      toc: yes
      toc_depth: 2
      toc_float:
        collapsed: yes
---

\usepackage{color}

```{=html}
<style>
code.r{
  font-size: 10px;
}
pre {
  font-size: 12px
}
</style>

<style>
body {
text-align: justify;
font-style: normal;
font-family: "Montserrat";
font-size: 12px
}
h1.title {
  font-size: 40px;
  color: #000D3B;
}
h1 {
  font-size: 30px;
  color: #B6854D;
}
h2 {
 font-size: 27px;
  color: #172984;
}
h3 {
  font-size: 20px;
  color: #172984;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 16px;
}
h7 {
  font-size: 16px;
}
</style>
```

```{=html}
<style>
.nav>li>a {
    position: relative;
    display: block;
    padding: 10px 15px;
    color: #0A2687;
}
.nav-pills>li.active>a, .nav-pills > li.active > a:hover, .nav-pills > li.active > a:focus {
    color: #ffffff;
    background-color: #09C2BC;
}
.top1-tiles a:nth-of-type(1):hover, .top-tiles1 a:nth-of-type(1):focus{
    color: #ffffff;
    background: #0A6A87
}
.top2-tiles a:nth-of-type(1):hover, .top2-tiles a:nth-of-type(1):focus{
    color: #ffffff;
    background: #0A6CC8
}
.top3-tiles a:nth-of-type(1):hover, .top2-tiles a:nth-of-type(1):focus{
    color: #ffffff;
    background: #596AB7
}
.top4-tiles a:nth-of-type(1):hover, .top2-tiles a:nth-of-type(1):focus{
    color: #ffffff;
    background: #A92AA4
}
</style>
```

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = FALSE, cache.lazy = FALSE, 
                         eval = FALSE, class.source = "fold-show")
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
options(digits = 2, encoding = "UTF8")
options(reticulate.repl.quiet = TRUE) #Python REPL in the R session, which can be used to interactively run Python code. All code executed within the REPL is run within the Python main module, and any generated Python objects will persist in the Python session
modo_notdebug = TRUE #es para separar las configuraciones de lo que ser铆a un despliegue a producci贸n y un ambiente local, el ALLOWED_HOST es un settings para definir los dominios permitidos cuando estar谩 en modo producci贸n,
```   
 

```{r, echo=FALSE}
rm(list = ls())
```

```{r, echo=FALSE}
setwd(here::here())
```

 Se define un `conda environment` a utilizar:

```{r,eval=FALSE}
#Se utiliza {reticulate} para instalar miniconda con:
require(reticulate)
#reticulate::install_miniconda()
##Se visualiza la configuraci贸n de python: que tengo actualemente.  
#reticulate::py_config()
reticulate::repl_python() #can be used to interactively run Python code
# Se define un `conda environment` a utilizar:
#reticulate::conda_create(envname='Pobreza-2022', 
  #                        python_version="3.11.5")
```

```{python, eval = FALSE}
# Eliminar todas las variables en el entorno de trabajo actual
for name in dir():
    if not name.startswith('_'):
        del globals()[name]
```


**Ubicaci贸n del proyecto** 
```{r}
root_dir = rprojroot::find_rstudio_root_file()
```

```{python}
import os
# Cambia el directorio de trabajo al directorio actual del script
os.path.dirname(os.getcwd())
current_directory = r.root_dir
os.chdir(current_directory)
os.getcwd()
```

**Se intalan la paqueter铆as de pyton** 
```{python}
# Se instalan los paquetes y librer铆as a utilizar en el programa
#pip install pandas
#pip install numpy
#pip install tabulate
import pandas as pd 
import numpy as np
from tabulate import tabulate
```


## Medici贸n multidimensional del 铆ndice de pobreza 2022 {.tabset .tabset-pills .top1-tiles}       

Se sigue la estructura del 铆ndice de pobreza, presentado en la p谩gina oficial del CONEVAL.   

De acuerdo con los Lineamientos y criterios generales para la definici贸n, identificaci贸n y medici贸n de la pobreza (2018) que se pueden consultar en el [Diario Oficial de la Federaci贸n](https://www.dof.gob.mx/nota_detalle.php?codigo=5542421&fecha=30/10/2018) y la Metodolog铆a para la medici贸n multidimensional de la pobreza en M茅xico, tercera edici贸n (https://www.coneval.org.mx/InformesPublicaciones/InformesPublicaciones/Documents/Metodologia-medicion-multidimensional-3er-edicion.pdf).   

Siguiendo la estructura del c谩lculo del 铆ndice multidimensional de la pobreza, se simplifican los c贸digos para entender el orden del c谩lculo de los indicadores sociodemogr谩ficos.      


### Indicadores de carencias sociales  {.tabset .tabset-pills .top2-tiles}    

#### I. Indicador de rezago educativo  {.tabset .tabset-pills .top3-tiles}     

```{python}
poblacion = pd.read_csv(current_directory + "/Bases de datos/poblacion.csv", low_memory = False)
```

**Indicador de carencia por rezago educativo `ic_rezedu`**

Se considera en situaci贸n de carencia por rezago educativo a la poblaci贸n que cumpla con alguno de los siguientes criterios:

1. Tiene de tres a 21 a帽os, no cuenta con la educaci贸n obligatoria y no asiste a un centro de educaci贸n formal. 
2. Tiene 22 a帽os o m谩s, naci贸 a partir del a帽o 1998 y no ha terminado la educaci贸n obligatoria (media superior).   
3. Tiene 16 a帽os o m谩s, naci贸 entre 1982 y 1997 y no cuenta con el nivel de educaci贸n obligatorio vigente en el momento en que deb铆a haberlo cursado (secundaria completa).   
4. Tiene 16 a帽os o m谩s, naci贸 antes de 1982 y no cuenta con el nivel de educaci贸n obligatorio vigente en el momento en que deb铆a haberlo cursado (primaria completa).	  

##### Opci贸n 1     

```{python}
import pandas as pd
import numpy as np

rezago_educativo = poblacion.copy()

# Convirtiendo variables string a numericas
rezago_educativo[['parentesco','edad','asis_esc','nivelaprob','gradoaprob','antec_esc','hablaind'
                ]] = rezago_educativo[['parentesco','edad','asis_esc','nivelaprob','gradoaprob','antec_esc','hablaind']].apply(pd.to_numeric, errors = 'coerce')
       
# Poblaci贸n objetivo: no se incluye a hu茅spedes ni trabajadores dom茅sticos
rezago_educativo = rezago_educativo[~((rezago_educativo['parentesco'] >= 400) & (rezago_educativo['parentesco'] < 500) |
                                      (rezago_educativo['parentesco'] >= 700) & (rezago_educativo['parentesco'] < 800))
                                      ]

# A帽o de nacimiento
rezago_educativo['anac_e'] = 2022 - rezago_educativo['edad'].fillna(0)

# Inasistencia escolar (se reporta para personas de 3 a帽os o m谩s)
rezago_educativo['inas_esc'] = np.NaN
rezago_educativo.loc[(rezago_educativo['asis_esc'] == 1), 'inas_esc'] = 0 # S铆 asiste
rezago_educativo.loc[(rezago_educativo['asis_esc'] == 2), 'inas_esc'] = 1 # No asiste

# Nivel educativo
rezago_educativo['niv_ed'] = np.NaN
# Con primaria incompleta o menos
rezago_educativo.loc[(rezago_educativo['nivelaprob'] < 2) | ((rezago_educativo['nivelaprob'] == 2) & (rezago_educativo['gradoaprob'] < 6)), 'niv_ed'] = 0
# Primaria completa o secundaria incompleta
rezago_educativo.loc[((rezago_educativo['nivelaprob'] == 2) & (rezago_educativo['gradoaprob'] == 6)) |
                      ((rezago_educativo['nivelaprob'] == 3) & (rezago_educativo['gradoaprob'] < 3)) |
                       (((rezago_educativo['nivelaprob'] == 5) | (rezago_educativo['nivelaprob'] == 6)) & 
                        (rezago_educativo['gradoaprob'] < 3) &                   
                         (rezago_educativo['antec_esc'] == 1)), 'niv_ed'] = 1
# Secundaria completa o media superior incompleta
rezago_educativo.loc[((rezago_educativo['nivelaprob'] == 3) & (rezago_educativo['gradoaprob'] == 3)) |
                      ((rezago_educativo['nivelaprob'] == 4) & (rezago_educativo['gradoaprob'] < 3)) |
                       ((rezago_educativo['nivelaprob'] == 5) & (rezago_educativo['antec_esc'] == 1) & (rezago_educativo['gradoaprob'] >= 3)) |
                        ((rezago_educativo['nivelaprob'] == 6) & (rezago_educativo['antec_esc'] == 1) & (rezago_educativo['gradoaprob'] >= 3)) |
                         ((rezago_educativo['nivelaprob'] == 5) & (rezago_educativo['antec_esc'] == 2) & (rezago_educativo['gradoaprob'] < 3)) |
                          ((rezago_educativo['nivelaprob'] == 6) & (rezago_educativo['antec_esc'] == 2) & (rezago_educativo['gradoaprob'] < 3)), 'niv_ed'] = 2
# Media superior completa o mayor nivel educativo
rezago_educativo.loc[((rezago_educativo['nivelaprob'] == 4) & (rezago_educativo['gradoaprob'] == 3)) |
                      ((rezago_educativo['nivelaprob'] == 5) & (rezago_educativo['antec_esc'] == 2) & (rezago_educativo['gradoaprob'] >= 3)) |
                       ((rezago_educativo['nivelaprob'] == 6) & (rezago_educativo['antec_esc'] == 2) & (rezago_educativo['gradoaprob'] >= 3)) |
                        ((rezago_educativo['nivelaprob'] == 5) & (rezago_educativo['antec_esc'] > 2)) |
                         ((rezago_educativo['nivelaprob'] == 6) & (rezago_educativo['antec_esc'] > 2)) |
                          ((rezago_educativo['nivelaprob'] >= 7) & (~rezago_educativo['nivelaprob'].isna())), 'niv_ed'] = 3

# Indicador de carencia por rezago educativo
rezago_educativo['ic_rezedu'] = np.NaN
# Presenta carencia
rezago_educativo.loc[(rezago_educativo['anac_e'] >= 1998) & (rezago_educativo['edad'].between(3, 21)) &
                      (rezago_educativo['inas_esc'] == 1) & (rezago_educativo['niv_ed'] < 3), 'ic_rezedu'] = 1 # Presenta carencia
rezago_educativo.loc[((rezago_educativo['anac_e'] >= 1982) & (rezago_educativo['anac_e'] <= 1997)) &
                      (rezago_educativo['edad'] >= 16) & (rezago_educativo['niv_ed'] < 2), 'ic_rezedu'] = 1 # Presenta carencia
rezago_educativo.loc[(rezago_educativo['anac_e'] <= 1981) & (rezago_educativo['edad'] >= 16) &  
                      (rezago_educativo['niv_ed'] == 0), 'ic_rezedu'] = 1 # Presenta carencia
rezago_educativo.loc[(rezago_educativo['anac_e'] >= 1998) & (rezago_educativo['edad'] >= 22) & 
                      (rezago_educativo['niv_ed'] < 3), 'ic_rezedu'] = 1 # Presenta carencia
                      
# No presenta carencia
rezago_educativo.loc[(rezago_educativo['edad'].between(0, 2)), 'ic_rezedu'] = 0 # No presenta carencia
rezago_educativo.loc[(rezago_educativo['anac_e'] >= 1998) & (rezago_educativo['edad'].between(3, 21)) &
                      (rezago_educativo['inas_esc'] == 0), 'ic_rezedu'] = 0 # No presenta carencia
rezago_educativo.loc[(rezago_educativo['niv_ed'] == 3), 'ic_rezedu'] = 0 # No presenta carencia
rezago_educativo.loc[((rezago_educativo['anac_e'] >= 1982) & (rezago_educativo['anac_e'] <= 1997)) &
                       (rezago_educativo['edad'] >= 16) & ((rezago_educativo['niv_ed'] >= 2) &
                        (~rezago_educativo['niv_ed'].isna())), 'ic_rezedu'] = 0 # No presenta carencia
rezago_educativo.loc[(rezago_educativo['anac_e'] <= 1981) &
                      (rezago_educativo['edad'] >= 16) &
                       ((rezago_educativo['niv_ed'] >= 1) & (~rezago_educativo['niv_ed'].isna())), 'ic_rezedu'] = 0 # No presenta carencia
                      
# Hablante de lengua ind铆gena
rezago_educativo['hli'] = np.NaN
rezago_educativo.loc[(rezago_educativo['hablaind'] == 1) & (rezago_educativo['edad'] >= 3), 'hli'] = 1 # Habla lengua ind铆gena
rezago_educativo.loc[(rezago_educativo['hablaind'] == 2) & (rezago_educativo['edad'] >= 3), 'hli'] = 0 # No habla lengua ind铆gena

rezago_educativo = rezago_educativo[['folioviv', 'foliohog', 'numren', 'edad', 'anac_e', 'inas_esc', 'niv_ed',
                                     'ic_rezedu', 'parentesco', 'hli'
                                     ]]
```

**Se guarda la base de datos** 
```{python}
#del [[rezedu]] # Eliminamos el data.frame "rezedu"  
rezago_educativo.to_csv(current_directory + '/Output/Data/' + 'ic_rezedu22.csv', index = False)
```

##### Opci贸n 2  

```{python}
def indicador_rezago_educativo(poblacion):
    def convert_to_numeric(df):
        cols_to_convert = ['parentesco','edad','asis_esc','nivelaprob','gradoaprob','antec_esc','hablaind']
        df[cols_to_convert] = df[cols_to_convert].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    def filter_population(df):
        return df[~((df['parentesco'] >= 400) & (df['parentesco'] < 500) | (df['parentesco'] >= 700) & (df['parentesco'] < 800))]
    
    def add_birth_year(df):
        df['anac_e'] = 2022 - df['edad'].fillna(0)
        return df
    
    def add_inas_esc(df):
        df['inas_esc'] = np.NaN
        df.loc[(df['asis_esc'] == 1), 'inas_esc'] = 0
        df.loc[(df['asis_esc'] == 2), 'inas_esc'] = 1
        return df
    
    def add_niv_ed(df):
        df['niv_ed'] = np.NaN
        df.loc[(df['nivelaprob'] < 2) | ((df['nivelaprob'] == 2) & (df['gradoaprob'] < 6)), 'niv_ed'] = 0
        df.loc[((df['nivelaprob'] == 2) & (df['gradoaprob'] == 6)) |
               ((df['nivelaprob'] == 3) & (df['gradoaprob'] < 3)) |
               (((df['nivelaprob'] == 5) | (df['nivelaprob'] == 6)) & (df['gradoaprob'] < 3) & (df['antec_esc'] == 1)), 'niv_ed'] = 1
        df.loc[((df['nivelaprob'] == 3) & (df['gradoaprob'] == 3)) |
               ((df['nivelaprob'] == 4) & (df['gradoaprob'] < 3)) |
               ((df['nivelaprob'] == 5) & (df['antec_esc'] == 1) & (df['gradoaprob'] >= 3)) |
               ((df['nivelaprob'] == 6) & (df['antec_esc'] == 1) & (df['gradoaprob'] >= 3)) |
               ((df['nivelaprob'] == 5) & (df['antec_esc'] == 2) & (df['gradoaprob'] < 3)) |
               ((df['nivelaprob'] == 6) & (df['antec_esc'] == 2) & (df['gradoaprob'] < 3)), 'niv_ed'] = 2
        df.loc[((df['nivelaprob'] == 4) & (df['gradoaprob'] == 3)) |
               ((df['nivelaprob'] == 5) & (df['antec_esc'] == 2) & (df['gradoaprob'] >= 3)) |
               ((df['nivelaprob'] == 6) & (df['antec_esc'] == 2) & (df['gradoaprob'] >= 3)) |
               ((df['nivelaprob'] == 5) & (df['antec_esc'] > 2)) |
               ((df['nivelaprob'] == 6) & (df['antec_esc'] > 2)) |
               ((df['nivelaprob'] >= 7) & (~df['nivelaprob'].isna())), 'niv_ed'] = 3
        return df
    
    def add_ic_rezedu(df):
        df['ic_rezedu'] = np.NaN
        df.loc[(df['anac_e'] >= 1998) & (df['edad'].between(3, 21)) &
               (df['inas_esc'] == 1) & (df['niv_ed'] < 3), 'ic_rezedu'] = 1
        df.loc[((df['anac_e'] >= 1982) & (df['anac_e'] <= 1997)) &
               (df['edad'] >= 16) & (df['niv_ed'] < 2), 'ic_rezedu'] = 1
        df.loc[(df['anac_e'] <= 1981) & (df['edad'] >= 16) & (df['niv_ed'] == 0), 'ic_rezedu'] = 1
        df.loc[(df['anac_e'] >= 1998) & (df['edad'] >= 22) & (df['niv_ed'] < 3), 'ic_rezedu'] = 1
        df.loc[(df['edad'].between(0, 2)), 'ic_rezedu'] = 0
        df.loc[(df['anac_e'] >= 1998) & (df['edad'].between(3, 21)) & (df['inas_esc'] == 0), 'ic_rezedu'] = 0
        df.loc[(df['niv_ed'] == 3), 'ic_rezedu'] = 0
        df.loc[((df['anac_e'] >= 1982) & (df['anac_e'] <= 1997)) & (df['edad'] >= 16) &
               ((df['niv_ed'] >= 2) & (~df['niv_ed'].isna())), 'ic_rezedu'] = 0
        df.loc[(df['anac_e'] <= 1981) & (df['edad'] >= 16) &
               ((df['niv_ed'] >= 1) & (~df['niv_ed'].isna())), 'ic_rezedu'] = 0
        return df
    
    def add_hli(df):
        df['hli'] = np.NaN
        df.loc[(df['hablaind'] == 1) & (df['edad'] >= 3), 'hli'] = 1
        df.loc[(df['hablaind'] == 2) & (df['edad'] >= 3), 'hli'] = 0
        return df
      
    def seleccionar_columnas(df):
        columnas = ['folioviv', 'foliohog', 'numren', 'edad', 'anac_e', 'inas_esc', 'niv_ed',
                    'ic_rezedu', 'parentesco', 'hli']
        return df[columnas]
      
    return (poblacion.copy()
                     .pipe(convert_to_numeric)
                     .pipe(filter_population)
                     .pipe(add_birth_year)
                     .pipe(add_inas_esc)
                     .pipe(add_niv_ed)
                     .pipe(add_ic_rezedu)
                     .pipe(add_hli)
                     .pipe(seleccionar_columnas)
           )

## Indicador de rezago educativo 
rezago_educativo = indicador_rezago_educativo(poblacion)
```

**Se guarda la base de datos** 
```{python}
#del [[rezedu]] # Eliminamos el data.frame "rezedu"  
rezago_educativo.to_csv(current_directory + '/Output/Data/' + 'ic_rezedu22_2.csv', index = False)
```

#### II. Indicador de carencia por acceso a los servicios de salud  {.tabset .tabset-pills .top3-tiles}       

```{python}
#del [[trabajos]] # Eliminamos el data.frame "trabajos" 
ocupados = pd.read_csv(current_directory + "/Bases de datos/trabajos.csv", low_memory = False)
```

**Indicador de carencia por servicios de salud `ic_asalud`**  

Se considera en situaci贸n de carencia por acceso a servicios de salud a la poblaci贸n que:    
 
 1. No se encuentra inscrita al Seguro Popular* o afiliada a alguna instituci贸n  por prestaci贸n laboral, contrataci贸n voluntaria o afiliaci贸n de un familiar por parentesco directo a recibir servicios m茅dicos por alguna instituci贸n que los preste como: las instituciones de seguridad social (`IMSS`, `ISSSTE federal o estatal`, `Pemex`, `Ej茅rcito` o `Marina`), los servicios m茅dicos privados, u otra instituci贸n m茅dica.      
 
 - Se reporta la poblaci贸n que respondi贸 estar afiliado o inscrito al Seguro Popular, o que tiene derecho a los servicios del
 Instituto de Salud para el Bienestar (`INSABI`), lo anterior de acuerdo con el cuestionario de la ENIGH 2022.     
 

##### Opci贸n 1     
 
```{python}
#Convirtiendo variables string a numericas
ocupados[['subor', 'indep', 'tiene_suel','pago','id_trabajo']
         ] = ocupados[['subor', 'indep', 'tiene_suel','pago','id_trabajo']
                      ].apply(pd.to_numeric, errors = 'coerce')

# Tipo de trabajador: identifica la poblaci贸n subordinada e independiente
ocupados['tipo_trab'] = np.NaN
# Subordinados
ocupados.loc[(ocupados['subor'] == 1), 'tipo_trab'] = 1
# Independientes que reciben un pago
ocupados.loc[(ocupados['subor'] == 2) & (ocupados['indep'] == 1) & (ocupados['tiene_suel'] == 1), 'tipo_trab'] = 2
ocupados.loc[(ocupados['subor'] == 2) & (ocupados['indep'] == 2) & (ocupados['pago'] == 1), 'tipo_trab'] = 2
#Independientes que no reciben un pago
ocupados.loc[(ocupados['subor'] == 2) & (ocupados['indep'] == 1) & (ocupados['tiene_suel'] == 2), 'tipo_trab'] = 3
ocupados.loc[(ocupados['subor'] == 2) & (ocupados['indep'] == 2) & ((ocupados['pago'] == 2) | (ocupados['pago'] == 3)), 'tipo_trab'] = 3

# Ocupaci贸n principal o secundaria
ocupados['ocupa'] = np.NaN
ocupados.loc[(ocupados['id_trabajo'] == 1), 'ocupa'] = 1
ocupados.loc[(ocupados['id_trabajo'] == 2), 'ocupa'] = 1

ocupados = ocupados[['folioviv', 'foliohog', 'numren', 'id_trabajo', 'tipo_trab', 'ocupa']]

# Distinci贸n de prestaciones en trabajo principal y secundario
ocupados = pd.pivot_table(ocupados, 
                          index = ['folioviv', 'foliohog', 'numren'], 
                          columns = 'id_trabajo', 
                          values = ['tipo_trab', 'ocupa'], 
                          aggfunc = np.sum, 
                          fill_value = 0)
                          
ocupados.columns = [f'{i}{j}' for i, j in ocupados.columns]
ocupados = ocupados.reset_index()

# Identificaci贸n de la poblaci贸n trabajadora (toda la que reporta al menos un empleo en la base de trabajos.csv)
ocupados['trab'] = 1
ocupados = ocupados[['folioviv', 'foliohog', 'numren', 'trab'] + [col for col in ocupados.columns if col.startswith('tipo_trab') or col.startswith('ocupa')]]
```

**Se guarda la base de datos** 
```{python}
ocupados.to_csv(current_directory + '/Output/Data/' + 'ocupados22.csv', index = False)
```

**Indicador de carencia por acceso a los servicios de salud** 

```{python}
#Indicador de carencia por acceso a los servicios de salud
salud = poblacion.copy()
# Poblaci贸n objetivo: no se incluye a hu茅spedes ni trabajadores dom茅sticos
salud = salud.loc[~((salud['parentesco'] >= 400) & (salud['parentesco'] < 500) |
                    (salud['parentesco'] >= 700) & (salud['parentesco'] < 800))]

salud = pd.merge(salud, 
                  ocupados, 
                   on = ['folioviv', 'foliohog', 'numren'], 
                    how = 'left')

#Convirtiendo variables string a numericas
salud[['parentesco', 'trab', 'edad', 'act_pnea1', 'act_pnea2','ocupa1', 'atemed', 'inst_1', 'inst_2', 'inst_3', 'inst_4', 'inst_5', 'inst_6', 
       'inscr_1', 'inscr_2', 'inscr_3', 'inscr_4', 'inscr_5', 'inscr_6', 'inscr_7', 'asis_esc', 'pop_insabi', 'segvol_2']
      ] = salud[['parentesco', 'trab', 'edad', 'act_pnea1', 'act_pnea2','ocupa1', 'atemed', 'inst_1', 'inst_2', 'inst_3', 'inst_4', 'inst_5', 
                 'inst_6', 'inscr_1', 'inscr_2', 'inscr_3', 'inscr_4', 'inscr_5', 'inscr_6', 'inscr_7', 'asis_esc', 'pop_insabi', 'segvol_2']
                 ].apply(pd.to_numeric, errors = 'coerce')

# PEA (personas de 16 a帽os o m谩s)
salud['pea'] = np.NaN
salud.loc[(salud['trab'] == 1) & (salud['edad'] >= 16) & 
           (~salud['edad'].isna()), 'pea'] = 1 # PEA: ocupada
salud.loc[((salud['act_pnea1'] == 1) | (salud['act_pnea2'] == 1)) & 
           (salud['edad'] >= 16) & (~salud['edad'].isna()),'pea'] = 2 # PEA: desocupada
salud.loc[((salud['edad'] >= 16) & (~salud['edad'].isna()) &
           (((salud['act_pnea1'] != 1) | (salud['act_pnea1'].isna())) &
            ((salud['act_pnea2'] != 1) | (salud['act_pnea2'].isna()))) &
             (((salud['act_pnea1'] >= 2) & (salud['act_pnea1'] <= 6)) |
              ((salud['act_pnea2'] >= 2) & (salud['act_pnea2'] <= 6)))),'pea'] = 0 # PNEA
   
# Tipo de trabajo
## Ocupaci贸n principal
salud['tipo_trab1'] = np.where(salud['pea'] == 1, 
                                salud['tipo_trab1'], 
                                 salud['tipo_trab1']) # Depende de un patr贸n, jefe o superior 
salud['tipo_trab1'] = np.where((salud['pea'] == 0) | (salud['pea'] == 2), 
                                 np.NaN, 
                                  salud['tipo_trab1']) # No depende de un jefe y recibe o tiene asignado un sueldo
salud['tipo_trab1'] = np.where(salud['pea'].isna(), 
                                np.NaN, 
                                 salud['tipo_trab1']) # No depende de un jefe y no recibe o no tiene asignado un sueldo
## Ocupaci贸n secundaria
salud['tipo_trab2'] = np.where(salud['pea'] == 1, 
                                salud['tipo_trab2'], 
                                 salud['tipo_trab2']) # Depende de un patr贸n, jefe o superior
salud['tipo_trab2'] = np.where((salud['pea'] == 0) | (salud['pea'] == 2), 
                                 np.NaN, 
                                  salud['tipo_trab2']) # No depende de un jefe y recibe o tiene asignado un sueldo
salud['tipo_trab2'] = np.where(salud['pea'].isna(), 
                                np.NaN, 
                                 salud['tipo_trab2']) # No depende de un jefe y no recibe o no tiene asignado un sueldo

# Servicios m茅dicos prestaciones laborales
salud['smlab1'] = np.NaN
## Ocupaci贸n principal
salud.loc[(salud['ocupa1'] == 1), 'smlab1'] = 0 # Sin servicios m茅dicos
salud.loc[((salud['ocupa1'] == 1) & (salud['atemed'] == 1) &
           ((salud['inst_1'] == 1) | (salud['inst_2'] == 2) | (salud['inst_3'] == 3) | (salud['inst_4'] == 4)) & 
            (salud['inscr_1'] == 1), 'smlab1')] = 1 # Con servicios m茅dicos

## Ocupaci贸n secundaria
salud['smlab2'] = np.NaN
salud.loc[(salud['ocupa2'] == 1), 'smlab2'] = 0 # Sin servicios m茅dicos
salud.loc[((salud['ocupa2'] == 1) & (salud['atemed'] == 1) &
           ((salud['inst_1'] == 1) | (salud['inst_2'] == 2) | (salud['inst_3'] == 3) | (salud['inst_4'] == 4)) & 
            (salud['inscr_1'] == 1), 'smlab2')] = 1 # Con servicios m茅dicos

# Contrataci贸n voluntaria de servicios m茅dicos
salud['smcv'] = np.NaN
salud.loc[((salud['edad'] >= 12) & (~salud['edad'].isna())), 'smcv'] = 0 # No cuenta
salud.loc[((salud['atemed'] == 1) & ((salud['inst_1'] == 1) | 
           (salud['inst_2'] == 2) | (salud['inst_3'] == 3) | 
            (salud['inst_4'] == 4)) & (salud['inscr_6'] == 6) & 
             (salud['edad'] >= 12) & (~salud['edad'].isna())), 'smcv'] = 1 # S铆 cuenta

# Acceso directo a servicios de salud
salud['sa_dir'] = np.NaN
## Ocupaci贸n principal
salud.loc[((salud['tipo_trab1'] == 1) & (salud['smlab1'] == 1)), 'sa_dir'] = 1 # Con acceso
salud.loc[((salud['tipo_trab1'] == 2) & ((salud['smlab1'] == 1) | (salud['smcv'] == 1))), 'sa_dir'] = 1 # Con acceso
salud.loc[((salud['tipo_trab1'] == 3) & ((salud['smlab1'] == 1) | (salud['smcv'] == 1))), 'sa_dir'] = 1 # Con acceso

## Ocupaci贸n secundaria
salud.loc[((salud['tipo_trab2'] == 1) & (salud['smlab2'] == 1)), 'sa_dir'] = 1 # Con acceso
salud.loc[((salud['tipo_trab2'] == 2) & ((salud['smlab2'] == 1) | (salud['smcv'] == 1))), 'sa_dir'] = 1 # Con acceso
salud.loc[((salud['tipo_trab2'] == 3) & ((salud['smlab2'] == 1) | (salud['smcv'] == 1))), 'sa_dir'] = 1 # Con acceso
salud.loc[(salud['sa_dir'].isna()), 'sa_dir'] = 0 # Sin acceso

# N煤cleos familiares
salud['par'] = np.NaN
salud.loc[((salud['parentesco'] >= 100) & (salud['parentesco'] < 200)), 'par'] = 1 # Jefe o jefa del hogar
salud.loc[((salud['parentesco'] >= 200) & (salud['parentesco'] < 300)), 'par'] = 2 # C贸nyuge del  jefe/a
salud.loc[((salud['parentesco'] >= 300) & (salud['parentesco'] < 400)), 'par'] = 3 # Hijo del jefe/a
salud.loc[((salud['parentesco'] == 601)), 'par'] = 4 # Padre o Madre del jefe/a
salud.loc[((salud['parentesco'] == 615)), 'par'] = 5 # Suegro del jefe/a
salud.loc[(salud['par'].isna()), 'par'] = 6 # Sin acceso

# Asimismo, se utilizar谩 la informaci贸n relativa a la asistencia a la escuela
salud['inas_esc'] = np.NaN
salud.loc[((salud['asis_esc'] == 1)), 'inas_esc'] = 0 # S铆 asiste
salud.loc[((salud['asis_esc'] == 2)), 'inas_esc'] = 1 # No asiste

# En primer lugar se identifican los principales parentescos respecto a la jefatura del hogar y si ese miembro cuenta con acceso directo
salud['jef'] = np.NaN
salud.loc[((salud['par'] == 1) & (salud['sa_dir'] == 1)), 'jef'] = 1
salud.loc[((((salud['inst_2'] == 2) | (salud['inst_3'] == 3)) & (salud['inscr_6'] == 6)) &
           ((salud['inst_1'].isna()) & (salud['inst_4'].isna()) & (salud['inst_6'].isna())) &
            ((salud['inscr_1'].isna()) & (salud['inscr_2'].isna()) & (salud['inscr_3'].isna()) &
             (salud['inscr_4'].isna()) & (salud['inscr_5'].isna()) & (salud['inscr_7'].isna()))), 'jef'] = np.NaN

salud['cony'] = np.NaN
salud.loc[((salud['par'] == 2) & (salud['sa_dir'] == 1)), 'cony'] = 1
salud.loc[((((salud['inst_2'] == 2) | (salud['inst_3'] == 3)) & (salud['inscr_6'] == 6)) &
           ((salud['inst_1'].isna()) & (salud['inst_4'].isna()) & (salud['inst_6'].isna())) &
            ((salud['inscr_1'].isna()) & (salud['inscr_2'].isna()) & (salud['inscr_3'].isna()) &
             (salud['inscr_4'].isna()) & (salud['inscr_5'].isna()) & (salud['inscr_7'].isna()))), 'cony'] = np.NaN

salud['hijo'] = np.NaN
salud.loc[((salud['par'] == 3) & (salud['sa_dir'] == 1)), 'hijo'] = 1
salud.loc[((((salud['inst_2'] == 2) | (salud['inst_3'] == 3)) & (salud['inscr_6'] == 6)) &
           ((salud['inst_1'].isna()) & (salud['inst_4'].isna()) & (salud['inst_6'].isna())) &
            ((salud['inscr_1'].isna()) & (salud['inscr_2'].isna()) & (salud['inscr_3'].isna()) &
             (salud['inscr_4'].isna()) & (salud['inscr_5'].isna()) & (salud['inscr_7'].isna()))), 'hijo'] = np.NaN

salud = salud.groupby(['folioviv', 'foliohog']).apply(lambda x: pd.Series({'jef_sa': x['jef'].sum(skipna = True),
                                                                           'cony_sa': x['cony'].sum(skipna = True),
                                                                           'hijo_sa': x['hijo'].sum(skipna = True)})).reset_index().merge(salud, on = ['folioviv', 'foliohog'])

salud.loc[(salud['jef_sa'] > 0), 'jef_sa'] = 1 # Acceso directo a servicios de salud de la jefatura del hogar
salud.loc[(salud['cony_sa'] > 0), 'cony_sa'] = 1 # Acceso directo a servicios de salud del c贸nyuge de la jefatura del hogar
salud.loc[(salud['hijo_sa'] > 0), 'hijo_sa'] = 1 # Acceso directo a servicios de salud de hijos(as) de la jefatura del hogar

# Otros n煤cleos familiares: se identifica a la poblaci贸n con acceso a servicios de salud mediante otros n煤cleos familiares a trav茅s de la 
# afiliaci贸n o inscripci贸n a servicios de salud por alg煤n familiar dentro o fuera del hogar, muerte del asegurado o por contrataci贸n propia; 

salud['s_salud'] = np.NaN
salud.loc[((~salud['pop_insabi'].isna()) & (~salud['atemed'].isna())), 's_salud'] = 0 # No cuenta
salud.loc[((salud['atemed'] == 1) & ((salud['inst_1'] == 1) | (salud['inst_2'] == 2) | (salud['inst_3'] == 3) | (salud['inst_4'] == 4)) &
           ((salud['inscr_3'] == 3) | (salud['inscr_4'] == 4) | (salud['inscr_6'] == 6) | (salud['inscr_7'] == 7))), 's_salud'] = 1 # S铆 cuenta

# Indicador de carencia por servicios de salud
# Indicador de carencia por acceso a los servicios de salud
salud['ic_asalud'] = np.NaN

## Acceso directo
salud.loc[((salud['sa_dir'] == 1)), 'ic_asalud'] = 0 

## Parentesco directo: jefatura
salud.loc[((salud['par'] == 1) & (salud['cony_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia
salud.loc[((salud['par'] == 1) & (salud['pea'] == 0) & (salud['hijo_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia

## Parentesco directo: c贸nyuge
salud.loc[((salud['par'] == 2) & (salud['jef_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia
salud.loc[((salud['par'] == 2) & (salud['pea'] == 0) & (salud['hijo_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia

## Parentesco directo: descendientes
salud.loc[((salud['par'] == 3) & (salud['edad'] < 16) & (salud['jef_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia
salud.loc[((salud['par'] == 3) & (salud['edad'] < 16) & (salud['cony_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia
salud.loc[((salud['par'] == 3) & (salud['edad'].between(16, 25)) & (salud['inas_esc'] == 0) & (salud['jef_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia
salud.loc[((salud['par'] == 3) & (salud['edad'].between(16, 25)) & (salud['inas_esc'] == 0) & (salud['cony_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia

## Parentesco directo: ascendientes
salud.loc[((salud['par'] == 4) & (salud['pea'] == 0) & (salud['jef_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia
salud.loc[((salud['par'] == 5) & (salud['pea'] == 0) & (salud['cony_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia

## Otros n煤cleos familiares
salud.loc[((salud['s_salud'] == 1)), 'ic_asalud'] = 0 # No presenta carencia

## Acceso reportado
salud.loc[((salud['pop_insabi'] == 1) | 
           ((salud['pop_insabi'] == 2) & (salud['atemed'] == 1) & ((salud['inst_1'] == 1) | 
            (salud['inst_2'] == 2) | 
             (salud['inst_3'] == 3) | 
              (salud['inst_4'] == 4) | 
               (salud['inst_5'] == 5) | 
                (salud['inst_6'] == 6))) | 
                 (salud['segvol_2'] == 2)), 'ic_asalud'] = 0 # No presenta carencia
salud.loc[(salud['ic_asalud'].isna()), 'ic_asalud'] = 1 # Presenta carencia

# Poblaci贸n con presencia de discapacidad, sea f铆sica o mental
salud['discap'] = np.NaN
salud.loc[((salud['disc_camin'] == '3') | (salud['disc_camin'] == '4')), 'discap'] = 0 # Sin presencia de discapacidad
salud.loc[((salud['disc_ver'] == '3') | (salud['disc_ver'] == '4')), 'discap'] = 0 # Sin presencia de discapacidad
salud.loc[((salud['disc_brazo'] == '3') | (salud['disc_brazo'] == '4')), 'discap'] = 0 # Sin presencia de discapacidad
salud.loc[((salud['disc_apren'] == '3') | (salud['disc_apren'] == '4')), 'discap'] = 0 # Sin presencia de discapacidad
salud.loc[((salud['disc_oir'] == '3') | (salud['disc_oir'] == '4')), 'discap'] = 0 # Sin presencia de discapacidad
salud.loc[((salud['disc_vest'] == '3') | (salud['disc_vest'] == '4')), 'discap'] = 0 # Sin presencia de discapacidad
salud.loc[((salud['disc_habla'] == '3') | (salud['disc_habla'] == '4')), 'discap'] = 0 # Sin presencia de discapacidad
salud.loc[((salud['disc_acti'] == '3') | (salud['disc_acti'] == '4')), 'discap'] = 0 # Sin presencia de discapacidad
salud.loc[((salud['disc_camin'] == '&') | (salud['disc_ver'] == '&') |
          (salud['disc_brazo'] == '&') | (salud['disc_apren'] == '&') |
          (salud['disc_oir'] == '&') | (salud['disc_vest'] == '&') &
          (salud['disc_habla'] == '&') | (salud['disc_acti'] == '&')), 'discap'] = np.NaN # Sin presencia de discapacidad
salud.loc[((salud['disc_camin'] == '1') | (salud['disc_camin'] == '2')), 'discap'] = 1 # Con presencia de discapacidad
salud.loc[((salud['disc_ver'] == '1') | (salud['disc_ver'] == '2')), 'discap'] = 1 # Con presencia de discapacidad
salud.loc[((salud['disc_brazo'] == '1') | (salud['disc_brazo'] == '2')), 'discap'] = 1 # Con presencia de discapacidad
salud.loc[((salud['disc_apren'] == '1') | (salud['disc_apren'] == '2')), 'discap'] = 1 # Con presencia de discapacidad
salud.loc[((salud['disc_oir'] == '1') | (salud['disc_oir'] == '2')), 'discap'] = 1 # Con presencia de discapacidad
salud.loc[((salud['disc_vest'] == '1') | (salud['disc_vest'] == '2')), 'discap'] = 1 # Con presencia de discapacidad
salud.loc[((salud['disc_habla'] == '1') | (salud['disc_habla'] == '2')), 'discap'] = 1 # Con presencia de discapacidad
salud.loc[((salud['disc_acti'] == '1') | (salud['disc_acti'] == '2')), 'discap'] = 1 # Con presencia de discapacidad

salud = salud[['folioviv', 'foliohog', 'numren', 'sexo', 'pop_insabi', 'atemed', 'inst_1', 'inst_2', 'inst_3', 'inst_4', 'inst_5', 'inst_6', 
               'inscr_1', 'inscr_2', 'inscr_3', 'inscr_4', 'inscr_5', 'inscr_6', 'inscr_7', 'inscr_8', 'segvol_1', 'segvol_2', 'segvol_3', 
               'segvol_4', 'segvol_5', 'segvol_6', 'segvol_7', 'sa_dir', 'jef_sa', 'cony_sa', 'hijo_sa', 'ic_asalud', 'discap']]
```


```{python}
salud.to_csv(current_directory + '/Output/Data/' + '/ic_asalud22.csv', index = False)
```

##### Opci贸n 2  

```{python}
#del [[trabajos]] # Eliminamos el data.frame "trabajos" 
ocupados = pd.read_csv(current_directory + "/Bases de datos/trabajos.csv", low_memory = False)
```

```{python}
def indicador_ocupados(poblacion):
    def convert_to_numeric(df):
        cols_to_convert = ['subor', 'indep', 'tiene_suel', 'pago', 'id_trabajo']
        df[cols_to_convert] = df[cols_to_convert].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    def add_tipo_trab(df):
        df['tipo_trab'] = np.NaN
        df.loc[(df['subor'] == 1), 'tipo_trab'] = 1
        df.loc[(df['subor'] == 2) & (df['indep'] == 1) & (df['tiene_suel'] == 1), 'tipo_trab'] = 2
        df.loc[(df['subor'] == 2) & (df['indep'] == 2) & (df['pago'] == 1), 'tipo_trab'] = 2
        df.loc[(df['subor'] == 2) & (df['indep'] == 1) & (df['tiene_suel'] == 2), 'tipo_trab'] = 3
        df.loc[(df['subor'] == 2) & (df['indep'] == 2) & ((df['pago'] == 2) | (df['pago'] == 3)), 'tipo_trab'] = 3
        return df
    
    def add_ocupa(df):
        df['ocupa'] = np.NaN
        df.loc[df['id_trabajo'].isin([1, 2]), 'ocupa'] = 1
        return df
    
    def pivot_and_finalize(df):
        df = df[['folioviv', 'foliohog', 'numren', 'id_trabajo', 'tipo_trab', 'ocupa']]
        df = pd.pivot_table(df, index=['folioviv', 'foliohog', 'numren'], columns='id_trabajo', 
                            values=['tipo_trab', 'ocupa'], aggfunc = np.sum, fill_value=0)
        df.columns = [f'{i}{j}' for i, j in df.columns]
        df = df.reset_index()
        df['trab'] = 1
        df = df[['folioviv', 'foliohog', 'numren', 'trab'] + 
                [col for col in df.columns if col.startswith('tipo_trab') or col.startswith('ocupa')]]
        return df
    
    return (ocupados.copy()
                    .pipe(convert_to_numeric)
                    .pipe(add_tipo_trab)
                    .pipe(add_ocupa)
                    .pipe(pivot_and_finalize))

ocupados = indicador_ocupados(ocupados)
```

**Se guarda la base de datos** 
```{python}
ocupados.to_csv(current_directory + '/Output/Data/' + 'ocupados22_2.csv', index = False)
```

**Indicador de carencia por acceso a los servicios de salud** 

```{python}
def indicador_salud(poblacion):
  
    def filter_poblacion(df):
        return df.loc[~((df['parentesco'] >= 400) & (df['parentesco'] < 500) |
                         (df['parentesco'] >= 700) & (df['parentesco'] < 800))]
    
    def merge_ocupados(df, ocupados):
        return pd.merge(df, ocupados, 
                         on = ['folioviv', 'foliohog', 'numren'], 
                          how = 'left')
    def convert_to_numeric(df):
        columnas = ['parentesco', 'trab', 'edad', 'act_pnea1', 'act_pnea2', 'ocupa1', 'ocupa2', 'atemed', 
                    'inst_1', 'inst_2', 'inst_3', 'inst_4', 'inst_5', 'inst_6', 
                    'inscr_1', 'inscr_2', 'inscr_3', 'inscr_4', 'inscr_5', 'inscr_6', 
                    'inscr_7', 'asis_esc', 'pop_insabi', 'segvol_2']
        df[columnas] = df[columnas].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    def define_pea(df):
        df['pea'] = np.NaN
        df.loc[(df['trab'] == 1) & (df['edad'] >= 16) & (~df['edad'].isna()), 'pea'] = 1
        df.loc[((df['act_pnea1'] == 1) | (df['act_pnea2'] == 1)) & (df['edad'] >= 16) & (~df['edad'].isna()), 'pea'] = 2
        df.loc[((df['edad'] >= 16) & (~df['edad'].isna()) &
                   (((df['act_pnea1'] != 1) | (df['act_pnea1'].isna())) &
                    ((df['act_pnea2'] != 1) | (df['act_pnea2'].isna()))) &
                   (((df['act_pnea1'] >= 2) & (df['act_pnea1'] <= 6)) |
                    ((df['act_pnea2'] >= 2) & (df['act_pnea2'] <= 6)))), 'pea'] = 0
        return df
    
    def define_tipo_trab(df):
        df['tipo_trab1'] = np.where(df['pea'] == 1, df['tipo_trab1'], df['tipo_trab1'])
        df['tipo_trab1'] = np.where((df['pea'] == 0) | (df['pea'] == 2), np.NaN, df['tipo_trab1'])
        df['tipo_trab1'] = np.where(df['pea'].isna(), np.NaN, df['tipo_trab1'])
        df['tipo_trab2'] = np.where(df['pea'] == 1, df['tipo_trab2'], df['tipo_trab2'])
        df['tipo_trab2'] = np.where((df['pea'] == 0) | (df['pea'] == 2), np.NaN, df['tipo_trab2'])
        df['tipo_trab2'] = np.where(df['pea'].isna(), np.NaN, df['tipo_trab2'])
        return df
      
    def servicios_medicos_ocupacion_principal(df):
        df['smlab1'] = np.NaN
        df.loc[(df['ocupa1'] == 1), 'smlab1'] = 0
        df.loc[((df['ocupa1'] == 1) & (df['atemed'] == 1) &
                ((df['inst_1'] == 1) | (df['inst_2'] == 2) | 
                 (df['inst_3'] == 3) | (df['inst_4'] == 4)) & 
                  (df['inscr_1'] == 1)), 'smlab1'] = 1
        return df
    
    def servicios_medicos_ocupacion_secundaria(df):
        df['smlab2'] = np.NaN
        df.loc[(df['ocupa2'] == 1), 'smlab2'] = 0
        df.loc[(df['ocupa2'] == 1) & (df['atemed'] == 1) &
                ((df['inst_1'] == 1) | (df['inst_2'] == 2) | 
                  (df['inst_3'] == 3) | (df['inst_4'] == 4)) & 
                   (df['inscr_1'] == 1), 'smlab2'] = 1
        return df
    
    def contratacion_voluntaria_servicios_medicos(df):
        df['smcv'] = np.NaN
        df.loc[((df['edad'] >= 12) & (~df['edad'].isna())), 'smcv'] = 0
        df.loc[((df['atemed'] == 1) &
                ((df['inst_1'] == 1) | (df['inst_2'] == 2) | 
                  (df['inst_3'] == 3) | (df['inst_4'] == 4)) & 
                   (df['inscr_6'] == 6) & (df['edad'] >= 12) & 
                    (~df['edad'].isna())), 'smcv'] = 1
        return df
    
    def acceso_directo_servicios_salud(df):
        df['sa_dir'] = np.NaN
        # Ocupaci贸n principal 
        df.loc[((df['tipo_trab1'] == 1) & (df['smlab1'] == 1)), 'sa_dir'] = 1
        df.loc[((df['tipo_trab1'] == 2) & ((df['smlab1'] == 1) | (df['smcv'] == 1))), 'sa_dir'] = 1
        df.loc[((df['tipo_trab1'] == 3) & ((df['smlab1'] == 1) | (df['smcv'] == 1))), 'sa_dir'] = 1
        # Ocupaci贸n secundaria
        df.loc[((df['tipo_trab2'] == 1) & (df['smlab2'] == 1)), 'sa_dir'] = 1
        df.loc[((df['tipo_trab2'] == 2) & ((df['smlab2'] == 1) | (df['smcv'] == 1))), 'sa_dir'] = 1
        df.loc[((df['tipo_trab2'] == 3) & ((df['smlab2'] == 1) | (df['smcv'] == 1))), 'sa_dir'] = 1
        df.loc[(df['sa_dir'].isna()), 'sa_dir'] = 0
        return df
    
    def definir_nucleos_familiares(df):
        df['par'] = np.NaN
        df.loc[((df['parentesco'] >= 100) & (df['parentesco'] < 200)), 'par'] = 1
        df.loc[((df['parentesco'] >= 200) & (df['parentesco'] < 300)), 'par'] = 2
        df.loc[((df['parentesco'] >= 300) & (df['parentesco'] < 400)), 'par'] = 3
        df.loc[(df['parentesco'] == 601), 'par'] = 4
        df.loc[(df['parentesco'] == 615), 'par'] = 5
        df.loc[(df['par'].isna()), 'par'] = 6
        return df
      
    def asistencia_escuela(df):
        df['inas_esc'] = np.NaN
        df.loc[(df['asis_esc'] == 1), 'inas_esc'] = 0
        df.loc[(df['asis_esc'] == 2), 'inas_esc'] = 1
        return df
    
    def identificar_jefes_conyuges_hijos(df):
        df['jef'] = np.NaN
        df.loc[(df['par'] == 1) & (df['sa_dir'] == 1), 'jef'] = 1
        df.loc[((((df['inst_2'] == 2) | (df['inst_3'] == 3)) & (df['inscr_6'] == 6)) &
                ((df['inst_1'].isna()) & (df['inst_4'].isna()) & (df['inst_6'].isna())) &
                 ((df['inscr_1'].isna()) & (df['inscr_2'].isna()) & (df['inscr_3'].isna()) &
                  (df['inscr_4'].isna()) & (df['inscr_5'].isna()) & (df['inscr_7'].isna()))), 'jef'] = np.NaN
    
        df['cony'] = np.NaN
        df.loc[(df['par'] == 2) & (df['sa_dir'] == 1), 'cony'] = 1
        df.loc[((((df['inst_2'] == 2) | (df['inst_3'] == 3)) & (df['inscr_6'] == 6)) &
                ((df['inst_1'].isna()) & (df['inst_4'].isna()) & (df['inst_6'].isna())) &
                 ((df['inscr_1'].isna()) & (df['inscr_2'].isna()) & (df['inscr_3'].isna()) &
                  (df['inscr_4'].isna()) & (df['inscr_5'].isna()) & (df['inscr_7'].isna()))), 'cony'] = np.NaN
    
        df['hijo'] = np.NaN
        df.loc[(df['par'] == 3) & (df['sa_dir'] == 1), 'hijo'] = 1
        df.loc[((((df['inst_2'] == 2) | (df['inst_3'] == 3)) & (df['inscr_6'] == 6)) &
                ((df['inst_1'].isna()) & (df['inst_4'].isna()) & (df['inst_6'].isna())) &
                 ((df['inscr_1'].isna()) & (df['inscr_2'].isna()) & (df['inscr_3'].isna()) &
                  (df['inscr_4'].isna()) & (df['inscr_5'].isna()) & (df['inscr_7'].isna()))), 'hijo'] = np.NaN
        return df
    
    def calcular_acceso_servicios(df):
        df_agg = (df.groupby(['folioviv', 'foliohog']).apply(lambda x: pd.Series({'jef_sa': x['jef'].sum(skipna = True),
                                                                                  'cony_sa': x['cony'].sum(skipna = True),
                                                                                  'hijo_sa': x['hijo'].sum(skipna = True)})
                                                                                  ).reset_index())
        df = df_agg.merge(df, on=['folioviv', 'foliohog'])
        df.loc[df['jef_sa'] > 0, 'jef_sa'] = 1
        df.loc[df['cony_sa'] > 0, 'cony_sa'] = 1
        df.loc[df['hijo_sa'] > 0, 'hijo_sa'] = 1
        return df
    
    def acceso_servicios_salud(df):
        df['s_salud'] = np.NaN
        df.loc[(~df['pop_insabi'].isna()) & 
                (~df['atemed'].isna()), 's_salud'] = 0
        df.loc[(df['atemed'] == 1) & ((df['inst_1'] == 1) |
                (df['inst_2'] == 2) | 
                 (df['inst_3'] == 3) | (df['inst_4'] == 4)) & 
                  ((df['inscr_3'] == 3) | (df['inscr_4'] == 4) | 
                   (df['inscr_6'] == 6) | (df['inscr_7'] == 7)), 's_salud'] = 1
        return df
    
    def indicador_carencia_acceso_salud(df):
        df['ic_asalud'] = np.NaN
    
        # Acceso directo
        df.loc[(df['sa_dir'] == 1), 'ic_asalud'] = 0 
    
        # Parentesco directo: jefatura
        df.loc[(df['par'] == 1) & (df['cony_sa'] == 1), 'ic_asalud'] = 0
        df.loc[(df['par'] == 1) & (df['pea'] == 0) & (df['hijo_sa'] == 1), 'ic_asalud'] = 0
    
        # Parentesco directo: c贸nyuge
        df.loc[(df['par'] == 2) & (df['jef_sa'] == 1), 'ic_asalud'] = 0
        df.loc[(df['par'] == 2) & (df['pea'] == 0) & (df['hijo_sa'] == 1), 'ic_asalud'] = 0
    
        # Parentesco directo: descendientes
        df.loc[(df['par'] == 3) & (df['edad'] < 16) & (df['jef_sa'] == 1), 'ic_asalud'] = 0
        df.loc[(df['par'] == 3) & (df['edad'] < 16) & (df['cony_sa'] == 1), 'ic_asalud'] = 0
        df.loc[(df['par'] == 3) & (df['edad'].between(16, 25)) & (df['inas_esc'] == 0) & (df['jef_sa'] == 1), 'ic_asalud'] = 0
        df.loc[(df['par'] == 3) & (df['edad'].between(16, 25)) & (df['inas_esc'] == 0) & (df['cony_sa'] == 1), 'ic_asalud'] = 0
    
        # Parentesco directo: ascendientes
        df.loc[(df['par'] == 4) & (df['pea'] == 0) & (df['jef_sa'] == 1), 'ic_asalud'] = 0
        df.loc[(df['par'] == 5) & (df['pea'] == 0) & (df['cony_sa'] == 1), 'ic_asalud'] = 0
    
        # Otros n煤cleos familiares
        df.loc[(df['s_salud'] == 1), 'ic_asalud'] = 0
    
        # Acceso reportado
        df.loc[(df['pop_insabi'] == 1) | ((df['pop_insabi'] == 2) & (df['atemed'] == 1) & 
                                          ((df['inst_1'] == 1) | (df['inst_2'] == 2) | (df['inst_3'] == 3) | 
                                           (df['inst_4'] == 4) | (df['inst_5'] == 5) | (df['inst_6'] == 6))) | 
                                            (df['segvol_2'] == 2), 'ic_asalud'] = 0
        df.loc[df['ic_asalud'].isna(), 'ic_asalud'] = 1
        return df
    
    def presencia_discapacidad(df):
        df['discap'] = np.NaN
        df.loc[(df['disc_camin'] == '3') | (df['disc_camin'] == '4'), 'discap'] = 0
        df.loc[(df['disc_ver'] == '3') | (df['disc_ver'] == '4'), 'discap'] = 0
        df.loc[(df['disc_brazo'] == '3') | (df['disc_brazo'] == '4'), 'discap'] = 0
        df.loc[(df['disc_apren'] == '3') | (df['disc_apren'] == '4'), 'discap'] = 0
        df.loc[(df['disc_oir'] == '3') | (df['disc_oir'] == '4'), 'discap'] = 0
        df.loc[(df['disc_vest'] == '3') | (df['disc_vest'] == '4'), 'discap'] = 0
        df.loc[(df['disc_habla'] == '3') | (df['disc_habla'] == '4'), 'discap'] = 0
        df.loc[(df['disc_acti'] == '3') | (df['disc_acti'] == '4'), 'discap'] = 0
        df.loc[(df['disc_camin'] == '&') | (df['disc_ver'] == '&') |
                (df['disc_brazo'] == '&') | (df['disc_apren'] == '&') |
                 (df['disc_oir'] == '&') | (df['disc_vest'] == '&') &
                  (df['disc_habla'] == '&') | (df['disc_acti'] == '&'), 'discap'] = np.NaN
        df.loc[(df['disc_camin'] == '1') | (df['disc_camin'] == '2'), 'discap'] = 1
        df.loc[(df['disc_ver'] == '1') | (df['disc_ver'] == '2'), 'discap'] = 1
        df.loc[(df['disc_brazo'] == '1') | (df['disc_brazo'] == '2'), 'discap'] = 1
        df.loc[(df['disc_apren'] == '1') | (df['disc_apren'] == '2'), 'discap'] = 1
        df.loc[(df['disc_oir'] == '1') | (df['disc_oir'] == '2'), 'discap'] = 1
        df.loc[(df['disc_vest'] == '1') | (df['disc_vest'] == '2'), 'discap'] = 1
        df.loc[(df['disc_habla'] == '1') | (df['disc_habla'] == '2'), 'discap'] = 1
        df.loc[(df['disc_acti'] == '1') | (df['disc_acti'] == '2'), 'discap'] = 1
        return df
    
    def seleccionar_columnas(df):
        columnas = ['folioviv', 'foliohog', 'numren', 'sexo', 'pop_insabi', 'atemed', 'inst_1', 'inst_2', 'inst_3', 'inst_4', 
                    'inst_5', 'inst_6', 'inscr_1', 'inscr_2', 'inscr_3', 'inscr_4', 'inscr_5', 'inscr_6', 'inscr_7', 'inscr_8', 
                    'segvol_1', 'segvol_2', 'segvol_3', 'segvol_4', 'segvol_5', 'segvol_6', 'segvol_7', 'sa_dir', 'jef_sa', 
                    'cony_sa', 'hijo_sa', 'ic_asalud', 'discap']
        return df[columnas]
      
    return (poblacion.copy()
                     .pipe(filter_poblacion)
                     .pipe(merge_ocupados, ocupados)
                     .pipe(convert_to_numeric)
                     .pipe(define_pea)
                     .pipe(define_tipo_trab)
                     .pipe(servicios_medicos_ocupacion_principal)
                     .pipe(servicios_medicos_ocupacion_secundaria)
                     .pipe(contratacion_voluntaria_servicios_medicos)
                     .pipe(acceso_directo_servicios_salud)
                     .pipe(definir_nucleos_familiares)
                     .pipe(asistencia_escuela)
                     .pipe(identificar_jefes_conyuges_hijos)
                     .pipe(calcular_acceso_servicios)
                     .pipe(acceso_servicios_salud)
                     .pipe(indicador_carencia_acceso_salud)
                     .pipe(presencia_discapacidad)
                     .pipe(seleccionar_columnas))

# Indiccador de salud
salud = indicador_salud(poblacion)
```

**Se guarda la base de datos** 
```{python}
salud.to_csv(current_directory + '/Output/Data/' + 'ic_asalud22_2.csv', index = False)
```

#### III. Indicador de carencia por acceso a la seguridad social {.tabset .tabset-pills .top3-tiles}  

```{python}
# Prestaciones laborales
trabajos = pd.read_csv(current_directory + "/Bases de datos/trabajos.csv", low_memory = False) 
```

##### Opci贸n 1 {.tabset .tabset-pills .top4-tiles} 

###### Prestaciones laborales

```{python}
prestaciones = trabajos.copy()

#Convirtiendo variables string a numericas
prestaciones[['subor', 'indep', 'tiene_suel', 'pago', 'pres_8', 'id_trabajo']] = prestaciones[['subor', 'indep', 'tiene_suel', 'pago', 'pres_8', 'id_trabajo']
                                                                                             ].apply(pd.to_numeric, errors = 'coerce')

# Tipo de trabajador: identifica la poblaci贸n subordinada e independiente
prestaciones['tipo_trab'] = np.NaN
## Subordinados
prestaciones.loc[(prestaciones['subor'] == 1), 'tipo_trab'] = 1

## Independientes que reciben un pago
prestaciones.loc[((prestaciones['subor'] == 2) & (prestaciones['indep'] == 1) & (prestaciones['tiene_suel'] == 1)), 'tipo_trab'] = 2
prestaciones.loc[((prestaciones['subor'] == 2) & (prestaciones['indep'] == 2) & (prestaciones['pago'] == 1)), 'tipo_trab'] = 2

## Independientes que no reciben un pago
prestaciones.loc[((prestaciones['subor'] == 2) & (prestaciones['indep'] == 1) & (prestaciones['tiene_suel'] == 2)), 'tipo_trab'] = 3
prestaciones.loc[((prestaciones['subor'] == 2) & (prestaciones['indep'] == 2) & ((prestaciones['pago'] == 2) | (prestaciones['pago'] == 3))), 'tipo_trab'] = 3
 

# Ahorro para el retiro o pensi贸n para la vejez (SAR, Afore)
prestaciones['aforlab'] = np.NaN
prestaciones.loc[(prestaciones['pres_8'].isna()), 'aforlab'] = 0 
prestaciones.loc[(prestaciones['pres_8'] == 8), 'aforlab'] = 1 

# Ocupaci贸n principal o secundaria
prestaciones['ocupa'] = np.NaN
prestaciones.loc[(prestaciones['id_trabajo'] == 1), 'ocupa'] = 1 
prestaciones.loc[(prestaciones['id_trabajo'] == 2), 'ocupa'] = 1 

# Distinci贸n de prestaciones en trabajo principal y secundario
prestaciones = prestaciones[['folioviv', 'foliohog', 'numren', 'id_trabajo', 'tipo_trab', 'aforlab', 'ocupa']]

prestaciones = pd.pivot_table(prestaciones, 
                               index = ['folioviv', 'foliohog', 'numren'], 
                                columns = 'id_trabajo', 
                                 values = ['tipo_trab', 'aforlab', 'ocupa'], 
                                  aggfunc = np.sum, 
                                   fill_value = 0)
prestaciones.columns = [f'{i}{j}' for i, j in prestaciones.columns]
prestaciones = prestaciones.reset_index()

#Identificaci贸n de la poblaci贸n trabajadora (toda la que reporta al menos un empleo en la base de trabajos.csv)
prestaciones['trab'] = 1
prestaciones = prestaciones[['folioviv', 'foliohog', 'numren', 'trab', 'tipo_trab1', 'tipo_trab2', 'aforlab1', 'aforlab2', 'ocupa1', 'ocupa2']]
```

**Se guarda la base de datos** 
```{python}
prestaciones.to_csv(current_directory + '/Output/Data/' + '/prestaciones22.csv', index = False)
```

###### Ingresos por jubilaciones o pensiones

```{python}
# Ingresos por jubilaciones o pensiones
pensiones = pd.read_csv(current_directory + "/Bases de datos/ingresos.csv", low_memory = False)

pensiones = pensiones[((pensiones['clave'] == 'P032') | (pensiones['clave'] == 'P033') | 
                       (pensiones['clave'] == 'P104') | (pensiones['clave'] == 'P045'))]
```


```{python}
# Definici贸n de los deflactores 2022 
dic21 =	0.9475376203	
ene22 =	0.9531433002
feb22 =	0.9610510246	
mar22 =	0.9705661414	
abr22 =	0.9758164180	
may22 =	0.9775368933
jun22 =	0.9857919437	
jul22 =	0.9930938669
ago22 =	1.0000000000
sep22 =	1.0062034038
oct22 =	1.0118979346
nov22 =	1.0177217030
dic22 =	1.0216069077
```

```{python}
#Convirtiendo variables string a numericas
pensiones[['mes_1', 'mes_2', 'mes_3', 'mes_4', 'mes_5', 'mes_6', 'ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']
          ] = pensiones[['mes_1', 'mes_2', 'mes_3', 'mes_4', 'mes_5', 'mes_6', 'ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']].apply(pd.to_numeric, errors = 'coerce')
          
# Se deflactan los ingresos por jubilaciones, pensionesiones y programas de adultos mayores de acuerdo con el mes de levantamiento
pensiones['ing_6'] = np.where(pensiones['mes_6'].isna(), pensiones['ing_6'] ,
                      np.where(pensiones['mes_6'] == 2, pensiones['ing_6'] / feb22,
                       np.where(pensiones['mes_6'] == 3, pensiones['ing_6'] / mar22,
                        np.where(pensiones['mes_6'] == 4, pensiones['ing_6'] / abr22,
                         pensiones['ing_6'] / may22))))
pensiones['ing_5'] = np.where(pensiones['mes_5'].isna(), pensiones['ing_5'] ,
                      np.where(pensiones['mes_5'] == 3, pensiones['ing_5'] / mar22,
                       np.where(pensiones['mes_5'] == 4, pensiones['ing_5'] / abr22,
                        np.where(pensiones['mes_5'] == 5, pensiones['ing_5'] / may22,
                         pensiones['ing_5'] / jun22))))
pensiones['ing_4'] = np.where(pensiones['mes_4'].isna(), pensiones['ing_4'] ,
                      np.where(pensiones['mes_4'] == 4, pensiones['ing_4'] / abr22,
                       np.where(pensiones['mes_4'] == 5, pensiones['ing_4'] / may22,
                        np.where(pensiones['mes_4'] == 6, pensiones['ing_4'] / jun22,
                         pensiones['ing_4'] / jul22 ))))
pensiones['ing_3'] = np.where(pensiones['mes_3'].isna(), pensiones['ing_3'] ,
                      np.where(pensiones['mes_3'] == 5, pensiones['ing_3'] / may22,
                       np.where(pensiones['mes_3'] == 6, pensiones['ing_3'] / jun22,
                        np.where(pensiones['mes_3'] == 7, pensiones['ing_3'] / jul22,
                         pensiones['ing_3'] / ago22))))
pensiones['ing_2'] = np.where(pensiones['mes_2'].isna(), pensiones['ing_2'] ,
                      np.where(pensiones['mes_2'] == 6, pensiones['ing_2'] / jun22,
                       np.where(pensiones['mes_2'] == 7, pensiones['ing_2'] / jul22,
                        np.where(pensiones['mes_2'] == 8, pensiones['ing_2'] / ago22,
                         pensiones['ing_2'] / sep22))))
pensiones['ing_1'] = np.where(pensiones['mes_1'].isna(), pensiones['ing_1'] ,
                      np.where(pensiones['mes_1'] == 7, pensiones['ing_1'] / jul22,
                       np.where(pensiones['mes_1'] == 8, pensiones['ing_1'] / ago22,
                        np.where(pensiones['mes_1'] == 9, pensiones['ing_1'] / sep22,
                         pensiones['ing_1'] / oct22 ))))

# Ingreso promedio mensual por programas de adultos mayores
pensiones['ing_pam'] = np.where((pensiones['clave'] == 'P104') | (pensiones['clave'] == 'P045'),
                                  np.apply_along_axis(np.mean, 1, pensiones[['ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']]), 0)
# Ingreso promedio mensual por jubilaciones y pensiones
pensiones['ing_pens'] = np.where((pensiones['clave'] == 'P032') | (pensiones['clave'] == 'P033'),
                                   np.apply_along_axis(np.mean, 1, pensiones[['ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']]), 0)

pensiones = pensiones.groupby(['folioviv', 'foliohog', 'numren'])[['ing_pens', 'ing_pam']].sum(numeric_only = True)
pensiones = pensiones.reset_index()
```


**Se guarda la base de datos** 
```{python}
pensiones.to_csv(current_directory + '/Output/Data/' + '/pensiones22.csv', index = False)
```


###### Construcci贸n del indicador

**Indicador de carencia por acceso a la seguridad social** 

Se encuentra en situaci贸n de carencia por acceso a la seguridad social a la poblaci贸n que:    
1. No disponga de acceso directo a la seguridad social.   
2. No cuente con parentesco directo con alguna persona dentro del hogar que tenga acceso directo.    
3. No recibe servicios m茅dicos por parte de alg煤n familiar dentro o fuera del hogar, por muerte del asegurado o por contrataci贸n propia.  
4. No recibe ingreso por parte de un programa de adultos mayores donde el monto sea mayor o igual al valor promedio de la canasta alimentaria rural y urbana.    

```{python}
# Valor monetario de las l铆neas de pobreza extrema por ingresos rural y urbana
lp1_urb = 2086.21
lp1_rur = 1600.18
lp_pam = (lp1_urb + lp1_rur)/2
```

 
 
```{python}
# Construcci贸n del indicador
seguridad_social = poblacion.copy()

# Poblaci贸n objetivo: no se incluye a hu茅spedes ni trabajadores dom茅sticos
seguridad_social = seguridad_social[~((seguridad_social['parentesco'] >= 400) & (seguridad_social['parentesco'] < 500) |
                   (seguridad_social['parentesco'] >= 700) & (seguridad_social['parentesco'] < 800))]

# Integraci贸n de bases
seguridad_social = pd.merge(seguridad_social, prestaciones, 
                             on = ['folioviv', 'foliohog', 'numren'], 
                              how = 'left')
seguridad_social = pd.merge(seguridad_social, pensiones, 
                    on = ['folioviv', 'foliohog', 'numren'], 
                     how = 'left')

#Convirtiendo variables string a numericas
seguridad_social[['parentesco', 'trab', 'edad', 'act_pnea1', 'act_pnea2','ocupa1', 'atemed', 'trabajo_mp',
                  'inst_1', 'inst_2', 'inst_3', 'inst_4', 'inst_5', 'inst_6', 'inscr_1', 'inscr_2', 'inscr_3', 
                  'inscr_4', 'inscr_5', 'inscr_6', 'inscr_7', 'asis_esc', 'pop_insabi', 'segvol_1']
                 ] = seguridad_social[['parentesco', 'trab', 'edad', 'act_pnea1', 'act_pnea2','ocupa1', 'atemed', 'trabajo_mp',
                                       'inst_1', 'inst_2', 'inst_3', 'inst_4', 'inst_5', 'inst_6', 'inscr_1', 'inscr_2', 'inscr_3', 
                                       'inscr_4', 'inscr_5', 'inscr_6', 'inscr_7', 'asis_esc', 'pop_insabi', 'segvol_1']].apply(pd.to_numeric, errors = 'coerce')

# PEA (personas de 16 a帽os o m谩s)
seguridad_social['pea'] = np.NaN
seguridad_social.loc[(seguridad_social['trab'] == 1) & (seguridad_social['edad'] >= 16) & 
                      (~seguridad_social['edad'].isna()), 'pea'] = 1 # PEA: ocupada
seguridad_social.loc[((seguridad_social['act_pnea1'] == 1) | (seguridad_social['act_pnea2'] == 1)) & 
                      (seguridad_social['edad'] >= 16) & (~seguridad_social['edad'].isna()), 'pea'] = 2 # PEA: desocupada
seguridad_social.loc[((seguridad_social['edad'] >= 16) & (~seguridad_social['edad'].isna()) &
                      (((seguridad_social['act_pnea1'] != 1) | (seguridad_social['act_pnea1'].isna())) &
                       ((seguridad_social['act_pnea2'] != 1) | (seguridad_social['act_pnea2'].isna()))) &
                        (((seguridad_social['act_pnea1'] >= 2) & (seguridad_social['act_pnea1'] <= 6)) |
                         ((seguridad_social['act_pnea2'] >= 2) & (seguridad_social['act_pnea2'] <= 6)))), 'pea'] = 0 # PNEA

# Acceso directo a la seguridad social
## Ocupaci贸n principal
seguridad_social['tipo_trab1'] = np.where(seguridad_social['pea'] == 1, 
                                           seguridad_social['tipo_trab1'], 
                                            seguridad_social['tipo_trab1']) # Depende de un patr贸n, jefe o superior 
seguridad_social['tipo_trab1'] = np.where((seguridad_social['pea'] == 0) | (seguridad_social['pea'] == 2), 
                                            np.NaN, 
                                             seguridad_social['tipo_trab1']) # No depende de un jefe y recibe o tiene asignado un sueldo
seguridad_social['tipo_trab1'] = np.where(seguridad_social['pea'].isna(), 
                                           np.NaN, 
                                            seguridad_social['tipo_trab1']) # No depende de un jefe y no recibe o no tiene asignado un sueldo
## Ocupaci贸n secundaria
seguridad_social['tipo_trab2'] = np.where(seguridad_social['pea'] == 1, 
                                           seguridad_social['tipo_trab2'], 
                                            seguridad_social['tipo_trab2']) # Depende de un patr贸n, jefe o superior
seguridad_social['tipo_trab2'] = np.where((seguridad_social['pea'] == 0) | (seguridad_social['pea'] == 2), 
                                            np.NaN, 
                                             seguridad_social['tipo_trab2']) # No depende de un jefe y recibe o tiene asignado un sueldo
seguridad_social['tipo_trab2'] = np.where(seguridad_social['pea'].isna(), 
                                           np.NaN, 
                                            seguridad_social['tipo_trab2']) # No depende de un jefe y no recibe o no tiene asignado un sueldo
## Jubilados y pensionados
seguridad_social['jub'] = np.NaN
seguridad_social.loc[((seguridad_social['trabajo_mp'] == 2) & ((seguridad_social['act_pnea1'] == 2) | 
                      (seguridad_social['act_pnea2'] == 2))), 'jub'] = 1 # Poblaci贸n pensionada o jubilada
seguridad_social.loc[((seguridad_social['ing_pens'] > 0) & (~seguridad_social['ing_pens'].isna())), 'jub'] = 1 # Poblaci贸n pensionada o jubilada
seguridad_social.loc[(seguridad_social['inscr_2'] == 2), 'jub'] = 1 # Poblaci贸n pensionada o jubilada
seguridad_social.loc[(seguridad_social['jub'].isna()), 'jub'] = 0 # Poblaci贸n no pensionada o jubilada

# Prestaciones b谩sicas

# Prestaciones laborales (Servicios m茅dicos)
## Ocupaci贸n principal
seguridad_social['smlab1'] = np.NaN
seguridad_social.loc[(seguridad_social['ocupa1'] == 1), 'smlab1'] = 0 # Con servicios m茅dicos
seguridad_social.loc[((seguridad_social['ocupa1'] == 1) & (seguridad_social['atemed'] == 1) & 
                      ((seguridad_social['inst_1'] == 1) | (seguridad_social['inst_2'] == 2) | 
                       (seguridad_social['inst_3'] == 3) | (seguridad_social['inst_4'] == 4)) & 
                        (seguridad_social['inscr_1'] == 1)), 'smlab1'] = 1 # Sin servicios m茅dicos
## Ocupaci贸n secundaria
seguridad_social['smlab2'] = np.NaN
seguridad_social.loc[(seguridad_social['ocupa2'] == 1), 'smlab2'] = 0 # Con servicios m茅dicos
seguridad_social.loc[((seguridad_social['ocupa2'] == 1) & (seguridad_social['atemed'] == 1) & 
                      ((seguridad_social['inst_1'] == 1) | (seguridad_social['inst_2'] == 2) | 
                       (seguridad_social['inst_3'] == 3) | (seguridad_social['inst_4'] == 4)) & 
                        (seguridad_social['inscr_1'] == 1)), 'smlab2'] = 1 # Sin servicios m茅dicos

# Contrataci贸n voluntaria: servicios m茅dicos y ahorro para el retiro o pensi贸n para la vejez (SAR, Afore, Haber de retiro)
## Servicios m茅dicos
seguridad_social['smcv'] = np.NaN
seguridad_social.loc[((seguridad_social['edad'] >= 12) & (~seguridad_social['edad'].isna())), 'smcv'] = 0 # No cuenta
seguridad_social.loc[((seguridad_social['atemed'] == 1) & ((seguridad_social['inst_1'] == 1) |
                      (seguridad_social['inst_2'] == 2) | (seguridad_social['inst_3'] == 3) |
                       (seguridad_social['inst_4'] == 4)) & (seguridad_social['inscr_6'] == 6) & 
                        ((seguridad_social['edad'] >= 12) & (~seguridad_social['edad'].isna()))), 'smcv'] = 1 # S铆 cuenta
                        
## SAR o Afore
seguridad_social['aforecv'] = np.NaN              
seguridad_social.loc[((seguridad_social['segvol_1'].isna()) & ((seguridad_social['edad'] >= 12) & 
                      (~seguridad_social['edad'].isna()))), 'aforecv'] = 0 # No cuenta    
seguridad_social.loc[((seguridad_social['segvol_1'] == 1) & ((seguridad_social['edad'] >= 12) & 
                      (~seguridad_social['edad'].isna()))), 'aforecv'] = 1 # S铆 cuenta 
                      
## Acceso directo a la seguridad social
seguridad_social['ss_dir'] = np.NaN
seguridad_social.loc[(seguridad_social['ss_dir'].isna()), 'ss_dir'] = 0 # Sin acceso

## Ocupaci贸n principal
seguridad_social.loc[((seguridad_social['tipo_trab1'] == 1) & (seguridad_social['smlab1'] == 1)), 'ss_dir'] = 1 # Con acceso
seguridad_social.loc[((seguridad_social['tipo_trab1'] == 2) & ((seguridad_social['smlab1'] == 1) |
                      (seguridad_social['smcv'] == 1)) & ((seguridad_social['aforlab1'] == 1) | 
                       (seguridad_social['aforecv'] == 1))), 'ss_dir'] = 1 # Con acceso
seguridad_social.loc[((seguridad_social['tipo_trab1'] == 3) & ((seguridad_social['smlab1'] == 1) | 
                       (seguridad_social['smcv'] == 1)) & (seguridad_social['aforecv'] == 1)), 'ss_dir'] = 1 # Con acceso

## Ocupaci贸n secundaria
seguridad_social.loc[((seguridad_social['tipo_trab2'] == 1) & (seguridad_social['smlab2'] == 1)), 'ss_dir'] = 1 # Con acceso
seguridad_social.loc[((seguridad_social['tipo_trab2'] == 2) & ((seguridad_social['smlab2'] == 1) | 
                      (seguridad_social['smcv'] == 1)) & ((seguridad_social['aforlab2'] == 1) | 
                       (seguridad_social['aforecv'] == 1))), 'ss_dir'] = 1 # Con acceso
seguridad_social.loc[((seguridad_social['tipo_trab2'] == 3) & ((seguridad_social['smlab2'] == 1) | 
                       (seguridad_social['smcv'] == 1)) & (seguridad_social['aforecv'] == 1)), 'ss_dir'] = 1 # Con acceso   

## Jubilados y pensionados
seguridad_social.loc[(seguridad_social['jub'] == 1), 'ss_dir'] = 1 # Con acceso 

## N煤cleos familiares   
seguridad_social['par'] = np.NaN
seguridad_social.loc[((seguridad_social['parentesco'] >= 100) & (seguridad_social['parentesco'] < 200)), 'par'] = 1 # Jefe o jefa del hogar
seguridad_social.loc[((seguridad_social['parentesco'] >= 200) & (seguridad_social['parentesco'] < 300)), 'par'] = 2 # C贸nyuge del  jefe/a
seguridad_social.loc[((seguridad_social['parentesco'] >= 300) & (seguridad_social['parentesco'] < 400)), 'par'] = 3 # Hijo del jefe/a
seguridad_social.loc[((seguridad_social['parentesco'] == 601)), 'par'] = 4 # Padre o Madre del jefe/a
seguridad_social.loc[((seguridad_social['parentesco'] == 615)), 'par'] = 5 # Suegro del jefe/a
seguridad_social.loc[(seguridad_social['par'].isna()), 'par'] = 6 # Sin acceso

# Asimismo, se utilizar谩 la informaci贸n relativa a la asistencia a la escuela
seguridad_social['inas_esc'] = np.NaN
seguridad_social.loc[((seguridad_social['asis_esc'] == 1)), 'inas_esc'] = 0 # S铆 asiste
seguridad_social.loc[((seguridad_social['asis_esc'] == 2)), 'inas_esc'] = 1 # No asiste

# En primer lugar se identifican los principales parentescos respecto a la jefatura del hogar y si ese miembro cuenta con acceso directo
seguridad_social['jef'] = np.NaN
seguridad_social.loc[((seguridad_social['par'] == 1) & (seguridad_social['ss_dir'] == 1)), 'jef'] = 1
seguridad_social.loc[((((seguridad_social['inst_2'] == 2) | (seguridad_social['inst_3'] == 3)) & (seguridad_social['inscr_6'] == 6)) & 
                      ((seguridad_social['inst_1'].isna()) & (seguridad_social['inst_4'].isna()) & (seguridad_social['inst_6'].isna())) &
                       ((seguridad_social['inscr_1'].isna()) & (seguridad_social['inscr_2'].isna()) & (seguridad_social['inscr_3'].isna()) &
                        (seguridad_social['inscr_4'].isna()) & (seguridad_social['inscr_5'].isna()) & (seguridad_social['inscr_7'].isna()))), 'jef'] = np.NaN

seguridad_social['cony'] = np.NaN
seguridad_social.loc[((seguridad_social['par'] == 2) & (seguridad_social['ss_dir'] == 1)), 'cony'] = 1
seguridad_social.loc[((((seguridad_social['inst_2'] == 2) | (seguridad_social['inst_3'] == 3)) & (seguridad_social['inscr_6'] == 6)) &
                      ((seguridad_social['inst_1'].isna()) & (seguridad_social['inst_4'].isna()) & (seguridad_social['inst_6'].isna())) &
                       ((seguridad_social['inscr_1'].isna()) & (seguridad_social['inscr_2'].isna()) & (seguridad_social['inscr_3'].isna()) &
                        (seguridad_social['inscr_4'].isna()) & (seguridad_social['inscr_5'].isna()) & (seguridad_social['inscr_7'].isna()))), 'cony'] = np.NaN

seguridad_social['hijo'] = np.NaN
seguridad_social.loc[((seguridad_social['par'] == 3) & (seguridad_social['ss_dir'] == 1) & (seguridad_social['jub'] == 1) & 
                      ((seguridad_social['edad'] > 25) & (~seguridad_social['edad'].isna()))), 'hijo'] = 1
seguridad_social.loc[((seguridad_social['par'] == 3) & (seguridad_social['ss_dir'] == 1) & (seguridad_social['jub'] == 0)), 'hijo'] = 1
seguridad_social.loc[((((seguridad_social['inst_2'] == 2) | (seguridad_social['inst_3'] == 3)) & (seguridad_social['inscr_6'] == 6)) &
                      ((seguridad_social['inst_1'].isna()) & (seguridad_social['inst_4'].isna()) & (seguridad_social['inst_6'].isna())) &
                       ((seguridad_social['inscr_1'].isna()) & (seguridad_social['inscr_2'].isna()) & (seguridad_social['inscr_3'].isna()) &
                        (seguridad_social['inscr_4'].isna()) & (seguridad_social['inscr_5'].isna()) & (seguridad_social['inscr_7'].isna()))), 'hijo'] = np.NaN

seguridad_social = seguridad_social.groupby(['folioviv', 'foliohog']
                                           ).apply(lambda x: pd.Series({'jef_ss': x['jef'].sum(skipna=True),
                                                                        'cony_ss': x['cony'].sum(skipna=True),
                                                                        'hijo_ss': x['hijo'].sum(skipna=True)})
                                                                      ).reset_index().merge(seguridad_social, 
                                                                                             on = ['folioviv', 'foliohog'])

seguridad_social.loc[(seguridad_social['jef_ss'] > 0), 'jef_ss'] = 1 # Acceso directo a servicios de salud de la jefatura del hogar
seguridad_social.loc[(seguridad_social['cony_ss'] > 0), 'cony_ss'] = 1 # Acceso directo a servicios de salud del c贸nyuge de la jefatura del hogar
seguridad_social.loc[(seguridad_social['hijo_ss'] > 0), 'hijo_ss'] = 1 # Acceso directo a servicios de salud de hijos(as) de la jefatura del hogar

# Otros n煤cleos familiares: se identifica a la poblaci贸n con acceso a la seguridad social mediante otros n煤cleos familiares a trav茅s de la afiliaci贸n o inscripci贸n 
#a servicios de salud por alg煤n familiar dentro o fuera del hogar, muerte del asegurado o por contrataci贸n propia.

seguridad_social['s_salud'] = np.NaN
seguridad_social.loc[((~seguridad_social['pop_insabi'].isna()) & (~seguridad_social['atemed'].isna())), 's_salud'] = 0 # Sin acceso
seguridad_social.loc[((seguridad_social['atemed'] == 1) & ((seguridad_social['inst_1'] == 1) |
                      (seguridad_social['inst_2'] == 2) | (seguridad_social['inst_3'] == 3) | 
                       (seguridad_social['inst_4'] == 4)) & ((seguridad_social['inscr_3'] == 3) | 
                        (seguridad_social['inscr_4'] == 4) | (seguridad_social['inscr_6'] == 6) | 
                         (seguridad_social['inscr_7'] == 7))), 's_salud'] = 1 # Con acceso

# Programas sociales de pensiones para adultos mayores
seguridad_social['pam'] = np.NaN
seguridad_social.loc[((seguridad_social['edad'] >= 65) & (~seguridad_social['edad'].isna())), 'pam'] = 0 # No recibe
seguridad_social.loc[((seguridad_social['edad'] >= 65) & (~seguridad_social['edad'].isna()) & 
                      (seguridad_social['ing_pam'] >= lp_pam) & (~seguridad_social['ing_pam'].isna())), 'pam'] = 1 # Recibe

#Indicador de carencia por acceso a la seguridad social
seguridad_social['ic_segsoc'] = np.NaN
## Acceso directo
seguridad_social.loc[(seguridad_social['ss_dir'] == 1), 'ic_segsoc'] = 0 # No presenta carencia

## Parentesco directo: jefatura
seguridad_social.loc[((seguridad_social['par'] == 1) & (seguridad_social['cony_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia
seguridad_social.loc[((seguridad_social['par'] == 1) & (seguridad_social['pea'] == 0) & 
                      (seguridad_social['hijo_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia

## Parentesco directo: c贸nyuge
seguridad_social.loc[((seguridad_social['par'] == 2) & (seguridad_social['jef_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia
seguridad_social.loc[((seguridad_social['par'] == 2) & (seguridad_social['pea'] == 0) & 
                      (seguridad_social['hijo_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia

## Parentesco directo: descendientes
seguridad_social.loc[((seguridad_social['par'] == 3) & (seguridad_social['edad'] < 16) & 
                      (seguridad_social['jef_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia
seguridad_social.loc[((seguridad_social['par'] == 3) & (seguridad_social['edad'] < 16) & 
                      (seguridad_social['cony_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia
seguridad_social.loc[((seguridad_social['par'] == 3) & (seguridad_social['edad'].between(16, 25)) & 
                      (seguridad_social['inas_esc'] == 0) & (seguridad_social['jef_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia
seguridad_social.loc[((seguridad_social['par'] == 3) & (seguridad_social['edad'].between(16, 25)) & 
                      (seguridad_social['inas_esc'] == 0) & (seguridad_social['cony_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia

## Parentesco directo: ascendientes
seguridad_social.loc[((seguridad_social['par'] == 4) & (seguridad_social['pea'] == 0) &
                      (seguridad_social['jef_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia
seguridad_social.loc[((seguridad_social['par'] == 5) & (seguridad_social['pea'] == 0) & 
                      (seguridad_social['cony_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia

## Otros n煤cleos familiares
seguridad_social.loc[(seguridad_social['s_salud'] == 1), 'ic_segsoc'] = 0 # No presenta carencia

## Programa de adultos mayores
seguridad_social.loc[(seguridad_social['pam'] == 1), 'ic_segsoc'] = 0 # No presenta carencia
seguridad_social.loc[(seguridad_social['ic_segsoc'].isna()), 'ic_segsoc'] = 1 # Presenta carencia

seguridad_social = seguridad_social[['folioviv', 'foliohog', 'numren', 'tipo_trab1', 'tipo_trab2', 'aforlab1', 'aforlab2', 'pea', 'jub', 
'smlab1', 'smlab2', 'smcv', 'aforecv', 'ss_dir', 'par', 'jef_ss', 'cony_ss', 'hijo_ss', 's_salud', 'pam', 'ing_pam', 'ic_segsoc']]
```

**Se guarda la base de datos** 
```{python}
seguridad_social.to_csv(current_directory + '/Output/Data/' + '/ic_segsoc22.csv', index = False)
```

##### Opci贸n 2 {.tabset .tabset-pills .top4-tiles} 

###### Prestaciones laborales

```{python}
trabajos = pd.read_csv(current_directory + "/Bases de datos/trabajos.csv", low_memory = False)
```

```{python}
def indicador_prestaciones(trabajos):
    def convertir_a_numerico(df):
        columnas = ['subor', 'indep', 'tiene_suel', 'pago', 'pres_8', 'id_trabajo']
        df[columnas] = df[columnas].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    def tipo_de_trabajador(df):
        df['tipo_trab'] = np.NaN
    
        # Subordinados
        df.loc[df['subor'] == 1, 'tipo_trab'] = 1
    
        # Independientes que reciben un pago
        df.loc[(df['subor'] == 2) & (df['indep'] == 1) & (df['tiene_suel'] == 1), 'tipo_trab'] = 2
        df.loc[(df['subor'] == 2) & (df['indep'] == 2) & (df['pago'] == 1), 'tipo_trab'] = 2
    
        # Independientes que no reciben un pago
        df.loc[(df['subor'] == 2) & (df['indep'] == 1) & (df['tiene_suel'] == 2), 'tipo_trab'] = 3
        df.loc[(df['subor'] == 2) & (df['indep'] == 2) & ((df['pago'] == 2) | (df['pago'] == 3)), 'tipo_trab'] = 3
    
        return df
    
    def ahorro_para_el_retiro(df):
        df['aforlab'] = np.NaN
        df.loc[df['pres_8'].isna(), 'aforlab'] = 0
        df.loc[df['pres_8'] == 8, 'aforlab'] = 1
        return df
    
    def ocupacion_principal_secundaria(df):
        df['ocupa'] = np.NaN
        df.loc[df['id_trabajo'] == 1, 'ocupa'] = 1
        df.loc[df['id_trabajo'] == 2, 'ocupa'] = 1
        return df
    
    def pivot_prestaciones(df):
        df = pd.pivot_table(df,
                            index = ['folioviv', 'foliohog', 'numren'],
                            columns = 'id_trabajo',
                            values = ['tipo_trab', 'aforlab', 'ocupa'],
                            aggfunc = np.sum,
                            fill_value = 0
                            )
        df.columns = [f'{i}{j}' for i, j in df.columns]
        df = df.reset_index()
        return df
    
    def identificar_poblacion_trabajadora(df):
        df['trab'] = 1
        columnas = ['folioviv', 'foliohog', 'numren', 'trab', 'tipo_trab1', 'tipo_trab2', 'aforlab1', 'aforlab2', 'ocupa1', 'ocupa2']
        return df[columnas]
    
            # Aplicando el pipeline
    return (trabajos.copy()
                    .pipe(convertir_a_numerico)
                    .pipe(tipo_de_trabajador)
                    .pipe(ahorro_para_el_retiro)
                    .pipe(ocupacion_principal_secundaria)
                    .pipe(pivot_prestaciones)
                    .pipe(identificar_poblacion_trabajadora))

# Indicador de prestaciones 
prestaciones = indicador_prestaciones(trabajos)
```


**Se guarda la base de datos** 
```{python}
prestaciones.to_csv(current_directory + '/Output/Data/' + '/prestaciones22_2.csv', index = False)
```

###### Ingresos por jubilaciones o pensiones

```{python}
# Ingresos por jubilaciones o pensiones
pensiones = pd.read_csv(current_directory + "/Bases de datos/ingresos.csv", low_memory = False)
```


```{python}
# Definiendo las constantes de deflaci贸n
deflactores = {
    1: 1.0118979346,  # oct22
    2: 0.9610510246,  # feb22
    3: 0.9705661414,  # mar22
    4: 0.9758164180,  # abr22
    5: 0.9775368933,  # may22
    6: 0.9857919437,  # jun22
    7: 0.9930938669,  # jul22
    8: 1.0000000000,  # ago22
    9: 1.0062034038,  # sep22
    10: 1.0118979346,  # oct22
    11: 1.0177217030,  # nov22
    12: 1.0216069077   # dic22
}
```

```{python}
def indicador_pensiones(pensiones):
    # Funci贸n para filtrar las pensiones relevantes
    def filtrar_pensiones(df):
        claves_relevantes = ['P032', 'P033', 'P104', 'P045']
        return df[df['clave'].isin(claves_relevantes)]
    
    # Funci贸n para convertir variables string a num茅ricas
    def convertir_a_numerico(df):
        columnas = ['mes_1', 'mes_2', 'mes_3', 'mes_4', 'mes_5', 'mes_6', 
                    'ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']
        df[columnas] = df[columnas].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    # Funci贸n para deflactar los ingresos
    def deflactar(ingreso, mes):
        if pd.isna(mes):
            return ingreso
        return ingreso / deflactores.get(mes, 1)
    
    def deflactar_ingresos(df):
        for i in range(1, 7):
            mes_col = f'mes_{i}'
            ing_col = f'ing_{i}'
            df[ing_col] = df.apply(lambda row: deflactar(row[ing_col], row[mes_col]), axis = 1)
        return df
    
    # Funci贸n para calcular los ingresos promedios
    def calcular_ingresos_promedios(df):
        # Ingreso promedio mensual por programas de adultos mayores
        df['ing_pam'] = np.where(df['clave'].isin(['P104', 'P045']),
                                  np.apply_along_axis(np.mean, 1, df[['ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']]),
                                   0
                                 )
        # Ingreso promedio mensual por jubilaciones y pensiones
        df['ing_pens'] = np.where(df['clave'].isin(['P032', 'P033']),
                                    np.apply_along_axis(np.mean, 1, df[['ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']]),
                                     0)
        return df
    
    # Funci贸n para agrupar los datos por hogar y sumar los ingresos
    def agrupar_y_sumar(df):
        df = df.groupby(['folioviv', 'foliohog', 'numren'])[['ing_pens', 'ing_pam']].sum(numeric_only = True)
        return df.reset_index()
    
    # Aplicando el pipeline
    return (pensiones.copy()
                     .pipe(filtrar_pensiones)
                     .pipe(convertir_a_numerico)
                     .pipe(deflactar_ingresos)
                     .pipe(calcular_ingresos_promedios)
                     .pipe(agrupar_y_sumar))
                     
# Indicador de pensiones 
pensiones = indicador_pensiones(pensiones)
```


**Se guarda la base de datos** 
```{python}
del deflactores
pensiones.to_csv(current_directory + '/Output/Data/' + '/pensiones22_2.csv', index = False)
```


###### Construcci贸n del indicador

**Indicador de carencia por acceso a la seguridad social** 

Se encuentra en situaci贸n de carencia por acceso a la seguridad social a la poblaci贸n que:    
1. No disponga de acceso directo a la seguridad social.   
2. No cuente con parentesco directo con alguna persona dentro del hogar que tenga acceso directo.    
3. No recibe servicios m茅dicos por parte de alg煤n familiar dentro o fuera del hogar, por muerte del asegurado o por contrataci贸n propia.  
4. No recibe ingreso por parte de un programa de adultos mayores donde el monto sea mayor o igual al valor promedio de la canasta alimentaria rural y urbana. 

```{python}
pensiones = pd.read_csv(current_directory + '/Output/Data/' + '/pensiones22.csv', low_memory = False)
prestaciones = pd.read_csv(current_directory + '/Output/Data/' + '/prestaciones22.csv', low_memory = False)
```

```{python}
# Valor monetario de las l铆neas de pobreza extrema por ingresos rural y urbana
lp1_urb = 2086.21
lp1_rur = 1600.18
lp_pam = (lp1_urb + lp1_rur)/2
```

 
```{python}
def indicador_seguridad_social(poblacion):
    def filtrar_poblacion_objetivo(df):
        return df[~((df['parentesco'] >= 400) & (df['parentesco'] < 500) |
                    (df['parentesco'] >= 700) & (df['parentesco'] < 800))]

    def integrar_bases(df):
        df = pd.merge(df, 
                       prestaciones, 
                        on = ['folioviv', 'foliohog', 'numren'], 
                         how = 'left')
        df = pd.merge(df, 
                       pensiones, 
                        on = ['folioviv', 'foliohog', 'numren'], 
                         how = 'left')
        return df
      
       # Convirtiendo variables string a num茅ricas
    def convertir_a_numerico(df):
        columnas_a_convertir = ['parentesco', 'trab', 'edad', 'act_pnea1', 'act_pnea2', 'ocupa1', 'atemed', 'trabajo_mp',
                                'inst_1', 'inst_2', 'inst_3', 'inst_4', 'inst_5', 'inst_6', 'inscr_1', 'inscr_2', 'inscr_3',
                                'inscr_4', 'inscr_5', 'inscr_6', 'inscr_7', 'asis_esc', 'pop_insabi', 'segvol_1']
        df[columnas_a_convertir] = df[columnas_a_convertir].apply(pd.to_numeric, errors = 'coerce')
        
        return df
      
    def calcular_pea(df):
        df['pea'] = np.NaN
        df.loc[(df['trab'] == 1) & (df['edad'] >= 16) & (~df['edad'].isna()), 'pea'] = 1  # PEA: ocupada
        df.loc[((df['act_pnea1'] == 1) | (df['act_pnea2'] == 1)) & (df['edad'] >= 16) & (~df['edad'].isna()), 'pea'] = 2  # PEA: desocupada
        df.loc[((df['edad'] >= 16) & (~df['edad'].isna()) &
                (((df['act_pnea1'] != 1) | (df['act_pnea1'].isna())) &
                 ((df['act_pnea2'] != 1) | (df['act_pnea2'].isna()))) &
                (((df['act_pnea1'] >= 2) & (df['act_pnea1'] <= 6)) |
                 ((df['act_pnea2'] >= 2) & (df['act_pnea2'] <= 6)))), 'pea'] = 0  # PNEA
        return df

    def tipo_trabajo(df):
        # Ocupaci贸n principal
        df['tipo_trab1'] = np.where(df['pea'] == 1, df['tipo_trab1'], df['tipo_trab1'])
        df['tipo_trab1'] = np.where((df['pea'] == 0) | (df['pea'] == 2), np.NaN, df['tipo_trab1'])
        df['tipo_trab1'] = np.where(df['pea'].isna(), np.NaN, df['tipo_trab1'])
        
        # Ocupaci贸n secundaria
        df['tipo_trab2'] = np.where(df['pea'] == 1, df['tipo_trab2'], df['tipo_trab2'])
        df['tipo_trab2'] = np.where((df['pea'] == 0) | (df['pea'] == 2), np.NaN, df['tipo_trab2'])
        df['tipo_trab2'] = np.where(df['pea'].isna(), np.NaN, df['tipo_trab2'])
        
        return df

    def calcular_jubilados(df):
        df['jub'] = np.NaN
        df.loc[((df['trabajo_mp'] == 2) & ((df['act_pnea1'] == 2) | (df['act_pnea2'] == 2))), 'jub'] = 1
        df.loc[((df['ing_pens'] > 0) & (~df['ing_pens'].isna())), 'jub'] = 1
        df.loc[(df['inscr_2'] == 2), 'jub'] = 1
        df.loc[(df['jub'].isna()), 'jub'] = 0
        
        return df

    def prestaciones_basicas(df):
        df['smlab1'] = np.NaN
        df.loc[(df['ocupa1'] == 1), 'smlab1'] = 0
        df.loc[((df['ocupa1'] == 1) & (df['atemed'] == 1) & 
                ((df['inst_1'] == 1) | (df['inst_2'] == 2) | (df['inst_3'] == 3) | (df['inst_4'] == 4)) &
                 (df['inscr_1'] == 1)), 'smlab1'] = 1
    
        df['smlab2'] = np.NaN
        df.loc[(df['ocupa2'] == 1), 'smlab2'] = 0
        df.loc[((df['ocupa2'] == 1) & (df['atemed'] == 1) &
                ((df['inst_1'] == 1) | (df['inst_2'] == 2) | (df['inst_3'] == 3) | (df['inst_4'] == 4)) &
                 (df['inscr_1'] == 1)), 'smlab2'] = 1
                 
        return df

    def contratacion_voluntaria(df):
        df['smcv'] = np.where((df['edad'] >= 12) & (~df['edad'].isna()), 0, np.NaN)
        df.loc[((df['atemed'] == 1) & ((df['inst_1'] == 1) |
                (df['inst_2'] == 2) | (df['inst_3'] == 3) |
                 (df['inst_4'] == 4)) & (df['inscr_6'] == 6) &
                  ((df['edad'] >= 12) & (~df['edad'].isna()))), 'smcv'] = 1
    
        df['aforecv'] = np.NaN
        df.loc[(df['segvol_1'].isna()) &
                ((df['edad'] >= 12) &
                 (~df['edad'].isna())), 'aforecv'] = 0
        df.loc[(df['segvol_1'] == 1) &
                ((df['edad'] >= 12) &
                 (~df['edad'].isna())), 'aforecv'] = 1
        
        return df

    def acceso_directo_seguridad_social(df):
        df['ss_dir'] = np.NaN
        df.loc[(df['ss_dir'].isna()), 'ss_dir'] = 0
    
        df.loc[((df['tipo_trab1'] == 1) & (df['smlab1'] == 1)), 'ss_dir'] = 1
        df.loc[((df['tipo_trab1'] == 2) & ((df['smlab1'] == 1) |
                (df['smcv'] == 1)) & ((df['aforlab1'] == 1) |
                 (df['aforecv'] == 1))), 'ss_dir'] = 1
        df.loc[((df['tipo_trab1'] == 3) & ((df['smlab1'] == 1) |
                (df['smcv'] == 1)) & (df['aforecv'] == 1)), 'ss_dir'] = 1
    
        df.loc[((df['tipo_trab2'] == 1) & (df['smlab2'] == 1)), 'ss_dir'] = 1
        df.loc[((df['tipo_trab2'] == 2) & ((df['smlab2'] == 1) |
                (df['smcv'] == 1)) & ((df['aforlab2'] == 1) |
                 (df['aforecv'] == 1))), 'ss_dir'] = 1
        df.loc[((df['tipo_trab2'] == 3) & ((df['smlab2'] == 1) |
                (df['smcv'] == 1)) & (df['aforecv'] == 1)), 'ss_dir'] = 1
    
        df.loc[(df['jub'] == 1), 'ss_dir'] = 1
        
        return df

    def identificar_nucleos_familiares(df):
        df['par'] = np.NaN
        df.loc[((df['parentesco'] >= 100) & (df['parentesco'] < 200)), 'par'] = 1
        df.loc[((df['parentesco'] >= 200) & (df['parentesco'] < 300)), 'par'] = 2
        df.loc[((df['parentesco'] >= 300) & (df['parentesco'] < 400)), 'par'] = 3
        df.loc[((df['parentesco'] == 601)), 'par'] = 4
        df.loc[((df['parentesco'] == 615)), 'par'] = 5
        df.loc[(df['par'].isna()), 'par'] = 6
        
        df['inas_esc'] = np.where((df['asis_esc'] == 1), 0, 1)
        
        return df

    def identificar_acceso_directo(df):
        df['jef'] = np.where(((df['par'] == 1) & (df['ss_dir'] == 1)), 1, np.NaN)
        df['cony'] = np.where(((df['par'] == 2) & (df['ss_dir'] == 1)), 1, np.NaN)
        df['hijo'] = np.where(((df['par'] == 3) & (df['ss_dir'] == 1) & (df['jub'] == 1) & 
                                (df['edad'] > 25) & (~df['edad'].isna())) | 
                               ((df['par'] == 3) & (df['ss_dir'] == 1) & (df['jub'] == 0)), 1, np.NaN)
        
        return df

    def agrupar_nucleos_familiares(df):
        grouped = df.groupby(['folioviv', 'foliohog']).agg({'jef': 'sum', 'cony': 'sum', 'hijo': 'sum'}).reset_index()
        grouped['jef'] = np.where((grouped['jef'] > 0), 1, 0)
        grouped['cony'] = np.where((grouped['cony'] > 0), 1, 0)
        grouped['hijo'] = np.where((grouped['hijo'] > 0), 1, 0)
        grouped.rename(columns={'jef': 'jef_ss', 'cony': 'cony_ss', 'hijo': 'hijo_ss'}, inplace=True)
        
        df = pd.merge(df, 
                       grouped, 
                        on = ['folioviv', 'foliohog'], 
                         how = 'left')
        df['jef_ss'] = np.where((df['jef_ss'] == 1), 1, np.NaN)
        df['cony_ss'] = np.where((df['cony_ss'] == 1), 1, np.NaN)
        df['hijo_ss'] = np.where((df['hijo_ss'] == 1), 1, np.NaN)
        
        return df

    # Funciones auxiliares
    def identificar_otro_nucleo_familiar(df):
        df['s_salud'] = np.NaN
        df.loc[((~df['pop_insabi'].isna()) & (~df['atemed'].isna())), 's_salud'] = 0
        df.loc[((df['atemed'] == 1) &
                ((df['inst_1'] == 1) | (df['inst_2'] == 2) | (df['inst_3'] == 3) | (df['inst_4'] == 4)) &
                 ((df['inscr_3'] == 3) | (df['inscr_4'] == 4) | (df['inscr_6'] == 6) | (df['inscr_7'] == 7))), 's_salud'] = 1
        return df

    def identificar_programa_pensiones(df):
        df['pam'] = np.NaN
        df.loc[((df['edad'] >= 65) & (~df['edad'].isna())), 'pam'] = 0
        df.loc[((df['edad'] >= 65) & (~df['edad'].isna()) & 
                (df['ing_pam'] >= lp_pam) & (~df['ing_pam'].isna())), 'pam'] = 1
        return df

    def calcular_indicador_carencia(df):
        df['ic_segsoc'] = np.NaN
        df.loc[(df['ss_dir'] == 1), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 1) & (df['cony_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 1) & (df['pea'] == 0) & (df['hijo_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 2) & (df['jef_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 2) & (df['pea'] == 0) & (df['hijo_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 3) & (df['edad'] < 16) & (df['jef_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 3) & (df['edad'] < 16) & (df['cony_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 3) & (df['edad'].between(16, 25)) & (df['inas_esc'] == 0) & (df['jef_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 3) & (df['edad'].between(16, 25)) & (df['inas_esc'] == 0) & (df['cony_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 4) & (df['pea'] == 0) & (df['jef_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 5) & (df['pea'] == 0) & (df['cony_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[(df['s_salud'] == 1), 'ic_segsoc'] = 0
        df.loc[(df['pam'] == 1), 'ic_segsoc'] = 0
        df.loc[df['ic_segsoc'].isna(), 'ic_segsoc'] = 1
        
        return df
      
        # Seleccionar columnas finales
    def seleccionar_columnas(df):
        columnas = ['folioviv', 'foliohog', 'numren', 'tipo_trab1', 'tipo_trab2', 'aforlab1', 'aforlab2', 'pea', 'jub',
                    'smlab1', 'smlab2', 'smcv', 'aforecv', 'ss_dir', 'par', 'jef_ss', 'cony_ss', 'hijo_ss', 's_salud',
                    'pam', 'ing_pam', 'ic_segsoc']
                    
        return df[columnas]    

    return (poblacion.copy()
                     .pipe(filtrar_poblacion_objetivo)
                     .pipe(integrar_bases)
                     .pipe(convertir_a_numerico)
                     .pipe(calcular_pea)
                     .pipe(tipo_trabajo)
                     .pipe(calcular_jubilados)
                     .pipe(prestaciones_basicas)
                     .pipe(contratacion_voluntaria)
                     .pipe(acceso_directo_seguridad_social)
                     .pipe(identificar_nucleos_familiares)
                     .pipe(identificar_acceso_directo)
                     .pipe(agrupar_nucleos_familiares)
                     .pipe(identificar_otro_nucleo_familiar)
                     .pipe(identificar_programa_pensiones)
                     .pipe(calcular_indicador_carencia)
                     .pipe(seleccionar_columnas)
                     )
                     
seguridad_social = indicador_seguridad_social(poblacion)
```


**Se guarda la base de datos** 
```{python}
seguridad_social.to_csv(current_directory + '/Output/Data/' + '/ic_segsoc22_2.csv', index = False)
```

#### IV. Indicador de carencia por calidad y espacios de la vivienda {.tabset .tabset-pills .top3-tiles}  

```{python}
viviendas = pd.read_csv(current_directory + "/Bases de datos/viviendas.csv", low_memory = False)
concentradohogar = pd.read_csv(current_directory + "/Bases de datos/concentradohogar.csv", low_memory = False)
```

##### Opci贸n 1 

###### Material de construcci贸n de la vivienda  

**Indicador de carencia por calidad y espacios de la vivienda**  

Se considera en situaci贸n de carencia por calidad y espacios de la vivienda a las personas que residan en viviendas que presenten, al menos, una de las siguientes caracter铆sticas:     
  
1. El material de los pisos de la vivienda es de tierra   
2. El material del techo de la vivienda es de l谩mina de cart贸n o desechos.   
3. El material de los muros de la vivienda es de embarro o bajareque, de carrizo, bamb煤 o palma, de l谩mina de cart贸n, met谩lica o asbesto, o material de desecho.    
4. La raz贸n de personas por cuarto (hacinamiento) es mayor que `2.5`.      

```{python}
calidad_viviendas = viviendas.copy()

calidad_viviendas = pd.merge(calidad_viviendas, concentradohogar, 
                              on = ['folioviv'], 
                               how = 'left')

#Convirtiendo variables string a numericas
calidad_viviendas[['mat_pisos', 'mat_techos', 'mat_pared', 'tot_resid', 'num_cuarto']
                  ] = calidad_viviendas[['mat_pisos', 'mat_techos', 'mat_pared', 'tot_resid', 'num_cuarto']
                                        ].apply(pd.to_numeric, errors = 'coerce')

# Indicador de carencia por material de piso de la vivienda
## Material de los pisos de la vivienda
calidad_viviendas['icv_pisos'] = np.NaN
calidad_viviendas.loc[(calidad_viviendas['mat_pisos'] >= 2), 'icv_pisos'] = 0
calidad_viviendas.loc[(calidad_viviendas['mat_pisos'] == 1), 'icv_pisos'] = 1

# Indicador de carencia por material de techos de la vivienda
## Material de los techos de la vivienda
calidad_viviendas['icv_techos'] = np.NaN
calidad_viviendas.loc[(calidad_viviendas['mat_techos'] >= 3), 'icv_techos'] = 0
calidad_viviendas.loc[(calidad_viviendas['mat_techos'] <= 2), 'icv_techos'] = 1

# Indicador de carencia por material de muros de la vivienda
## Material de muros en la vivienda
calidad_viviendas['icv_muros'] = np.NaN
calidad_viviendas.loc[(calidad_viviendas['mat_pared'] >= 6), 'icv_muros'] = 0
calidad_viviendas.loc[(calidad_viviendas['mat_pared'] <= 5), 'icv_muros'] = 1

# Espacios en la vivienda (Hacinamiento)
## N煤mero de residentes en la vivienda
calidad_viviendas['num_ind'] = calidad_viviendas['tot_resid']

## N煤mero de cuartos en la vivienda
calidad_viviendas['num_cua'] = calidad_viviendas['num_cuarto']

## ndice de hacinamiento
calidad_viviendas['cv_hac'] = calidad_viviendas['num_ind'] / calidad_viviendas['num_cua']

## Indicador de carencia por hacinamiento en la vivienda
calidad_viviendas['icv_hac'] = np.NaN
calidad_viviendas.loc[((calidad_viviendas['cv_hac'] > 2.5) & (~calidad_viviendas['cv_hac'].isna())), 'icv_hac'] = 1
calidad_viviendas.loc[(calidad_viviendas['cv_hac'] <= 2.5), 'icv_hac'] = 0
       
# Indicador de carencia por calidad y espacios de la vivienda
calidad_viviendas['ic_cv'] = np.NaN
calidad_viviendas.loc[((calidad_viviendas['icv_pisos'] == 1) | 
                       (calidad_viviendas['icv_techos'] == 1) | 
                        (calidad_viviendas['icv_muros'] == 1) | 
                         (calidad_viviendas['icv_hac'] == 1)), 'ic_cv'] = 1 # Con carencia
calidad_viviendas.loc[((calidad_viviendas['icv_pisos'] == 0) & 
                       (calidad_viviendas['icv_techos'] == 0) & 
                        (calidad_viviendas['icv_muros'] == 0) & 
                         (calidad_viviendas['icv_hac'] == 0)), 'ic_cv'] = 0 # Sin carencia  
calidad_viviendas.loc[((calidad_viviendas['icv_pisos'].isna()) | 
                       (calidad_viviendas['icv_techos'].isna()) |
                        (calidad_viviendas['icv_muros'].isna()) | 
                         (calidad_viviendas['icv_hac'].isna())), 'ic_cv'] = np.NaN
            
calidad_viviendas = calidad_viviendas[['folioviv', 'foliohog', 'icv_pisos', 'icv_techos', 'icv_muros', 'icv_hac', 'ic_cv']]    
```


**Se guarda la base de datos** 
```{python}
calidad_viviendas.to_csv(current_directory + '/Output/Data/' + '/ic_cev22.csv', index = False)
```

##### Opci贸n 2  

###### Material de construcci贸n de la vivienda  

**Indicador de carencia por calidad y espacios de la vivienda**  

Se considera en situaci贸n de carencia por calidad y espacios de la vivienda a las personas que residan en viviendas que presenten, al menos, una de las siguientes caracter铆sticas:     
  
1. El material de los pisos de la vivienda es de tierra   
2. El material del techo de la vivienda es de l谩mina de cart贸n o desechos.   
3. El material de los muros de la vivienda es de embarro o bajareque, de carrizo, bamb煤 o palma, de l谩mina de cart贸n, met谩lica o asbesto, o material de desecho.    
4. La raz贸n de personas por cuarto (hacinamiento) es mayor que `2.5`.      

```{python}
def indicador_calidad_viviendas(viviendas):
    # Funciones auxiliares
    def merge_concentradohogar(df):
        return pd.merge(df, 
                         concentradohogar, 
                          on = 'folioviv', 
                           how = 'left')
                           
    def convertir_variables_numericas(df):
        cols = ['mat_pisos', 'mat_techos', 'mat_pared', 'tot_resid', 'num_cuarto']
        df[cols] = df[cols].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    def calcular_icv_pisos(df):
        df['icv_pisos'] = np.NaN
        df.loc[df['mat_pisos'] >= 2, 'icv_pisos'] = 0
        df.loc[df['mat_pisos'] == 1, 'icv_pisos'] = 1
        return df
    
    def calcular_icv_techos(df):
        df['icv_techos'] = np.NaN
        df.loc[df['mat_techos'] >= 3, 'icv_techos'] = 0
        df.loc[df['mat_techos'] <= 2, 'icv_techos'] = 1
        return df
    
    def calcular_icv_muros(df):
        df['icv_muros'] = np.NaN
        df.loc[df['mat_pared'] >= 6, 'icv_muros'] = 0
        df.loc[df['mat_pared'] <= 5, 'icv_muros'] = 1
        return df
    
    def calcular_icv_hacinamiento(df):
        df['num_ind'] = df['tot_resid']
        df['num_cua'] = df['num_cuarto']
        df['cv_hac'] = df['num_ind'] / df['num_cua']
        
        df['icv_hac'] = np.NaN
        df.loc[(df['cv_hac'] > 2.5) & (~df['cv_hac'].isna()), 'icv_hac'] = 1
        df.loc[df['cv_hac'] <= 2.5, 'icv_hac'] = 0
        return df
    
    def calcular_ic_cv(df):
        df['ic_cv'] = np.NaN
        df.loc[((df['icv_pisos'] == 1) | 
                (df['icv_techos'] == 1) | 
                (df['icv_muros'] == 1) | 
                (df['icv_hac'] == 1)), 'ic_cv'] = 1
        
        df.loc[((df['icv_pisos'] == 0) & 
                (df['icv_techos'] == 0) & 
                (df['icv_muros'] == 0) & 
                (df['icv_hac'] == 0)), 'ic_cv'] = 0
        
        df.loc[((df['icv_pisos'].isna()) | 
                (df['icv_techos'].isna()) |
                (df['icv_muros'].isna()) | 
                (df['icv_hac'].isna())), 'ic_cv'] = np.NaN
        return df
      
          # Seleccionar columnas finales
    def seleccionar_columnas(df):
        columnas = ['folioviv', 'foliohog', 'icv_pisos', 'icv_techos', 'icv_muros', 'icv_hac', 'ic_cv']
                    
        return df[columnas]    

    return (viviendas.copy()
                     .pipe(merge_concentradohogar)
                     .pipe(convertir_variables_numericas)
                     .pipe(calcular_icv_pisos)
                     .pipe(calcular_icv_techos)
                     .pipe(calcular_icv_muros)
                     .pipe(calcular_icv_hacinamiento)
                     .pipe(calcular_ic_cv)
                     .pipe(seleccionar_columnas))

calidad_viviendas = indicador_calidad_viviendas(viviendas)         
```

```{python}
calidad_viviendas.to_csv(current_directory + '/Output/Data/' + '/ic_cev22_2.csv', index = False)
```


#### V. Indicador de carencia por acceso a los servicios b谩sicos de la vivienda {.tabset .tabset-pills .top3-tiles}    

**Indicador de carencia por acceso a los servicios b谩sicos en la vivienda**   

Se considera en situaci贸n de carencia por servicios b谩sicos en la vivienda a las personas que residan en viviendas que presenten, al menos, una de las siguientes caracter铆sticas:   
  
1. El agua se obtiene de un pozo, r铆o, lago, arroyo, pipa, o bien, el agua entubada la adquieren por acarreo de otra vivienda, o de la llave p煤blica o hidrante.  
2. No cuentan con servicio de drenaje o el desag眉e tiene conexi贸n a una tuber铆a que va a dar a un r铆o, lago, mar, barranca o grieta.   
3. No disponen de energ铆a el茅ctrica.   
4. El combustible que se usa para cocinar o calentar los alimentos es le帽a o carb贸n sin chimenea.   

```{python}
viviendas = pd.read_csv(current_directory + "/Bases de datos/viviendas.csv", low_memory = False)
concentradohogar = pd.read_csv(current_directory + "/Bases de datos/concentradohogar.csv", low_memory = False)
```

##### Opci贸n 1  

```{python}
servicios_basicos = pd.merge(concentradohogar, 
                              viviendas, 
                               on = ['folioviv'], 
                                how = 'left')                  

#Convirtiendo variables string a numericas
servicios_basicos[['procaptar', 'disp_agua', 'drenaje', 'disp_elect', 'combustible', 'estufa_chi']
                  ] = servicios_basicos[['procaptar', 'disp_agua', 'drenaje', 'disp_elect', 'combustible', 'estufa_chi']
                                        ].apply(pd.to_numeric, errors = 'coerce')

# Indicador de carencia por acceso al agua
servicios_basicos['isb_agua'] = np.NaN
servicios_basicos.loc[((servicios_basicos['disp_agua'] >= 3) & 
                       (~servicios_basicos['disp_agua'].isna())), 'isb_agua'] = 1
servicios_basicos.loc[((servicios_basicos['procaptar'] == 1) & 
                       (servicios_basicos['disp_agua'] == 4)), 'isb_agua'] = 0
servicios_basicos.loc[((servicios_basicos['disp_agua'] <= 2) & 
                       (~servicios_basicos['disp_agua'].isna())), 'isb_agua'] = 0

# Indicador de carencia por servicio de drenaje
servicios_basicos['isb_dren'] = np.NaN
servicios_basicos.loc[(servicios_basicos['drenaje'] >= 3), 'isb_dren'] = 1
servicios_basicos.loc[(servicios_basicos['drenaje'] <= 2), 'isb_dren'] = 0

# Indicador de carencia por servicios de electricidad
servicios_basicos['isb_luz'] = np.NaN
servicios_basicos.loc[(servicios_basicos['disp_elect'] >= 5), 'isb_luz'] = 1
servicios_basicos.loc[(servicios_basicos['disp_elect'] <= 4), 'isb_luz'] = 0

# Indicador de carencia por combustible para cocinar
servicios_basicos['combus'] = servicios_basicos['combustible']
servicios_basicos['estufa'] = servicios_basicos['estufa_chi']
servicios_basicos['isb_combus'] = np.NaN
servicios_basicos.loc[(((servicios_basicos['combus'] == 1) | 
                       (servicios_basicos['combus'] == 2)) & 
                        (servicios_basicos['estufa'] == 2)), 'isb_combus'] = 1
servicios_basicos.loc[(((servicios_basicos['combus'] == 1) | 
                       (servicios_basicos['combus'] == 2)) & 
                        (servicios_basicos['estufa'] == 1)), 'isb_combus'] = 0
servicios_basicos.loc[(servicios_basicos['combus'].between(3, 6)), 'isb_combus'] = 0

# Indicador de carencia por acceso a los servicios b谩sicos en la vivienda
servicios_basicos['ic_sbv'] = np.NaN
servicios_basicos.loc[((servicios_basicos['isb_agua'] == 1) | 
                       (servicios_basicos['isb_dren'] == 1) | 
                        (servicios_basicos['isb_luz'] == 1) | 
                         (servicios_basicos['isb_combus'] == 1)), 'ic_sbv'] = 1 # Con carencia
servicios_basicos.loc[((servicios_basicos['isb_agua'] == 0) & 
                       (servicios_basicos['isb_dren'] == 0) & 
                        (servicios_basicos['isb_luz'] == 0) & 
                         (servicios_basicos['isb_combus'] == 0)), 'ic_sbv'] = 0 # Sin carencia 
servicios_basicos.loc[((servicios_basicos['isb_agua'].isna()) | 
                       (servicios_basicos['isb_dren'].isna()) | 
                        (servicios_basicos['isb_luz'].isna()) | 
                         (servicios_basicos['isb_combus'].isna())), 'ic_sbv'] = np.NaN

servicios_basicos = servicios_basicos[['folioviv', 'foliohog', 'isb_agua', 'isb_dren', 'isb_luz', 'isb_combus', 'ic_sbv']]
```

**Se guarda la base de datos** 
```{python}
servicios_basicos.to_csv(current_directory + '/Output/Data/' + '/ic_sbv22.csv', index = False)
```

##### Opci贸n 2  

```{python}
def indicador_servicios_basicos(viviendas):
    # Funciones auxiliares
    def merge_concentradohogar(df):
        return pd.merge(df, 
                         concentradohogar, 
                          on = 'folioviv', 
                           how = 'left')

    def convertir_variables_numericas(df):
        cols = ['procaptar', 'disp_agua', 'drenaje', 'disp_elect', 'combustible', 'estufa_chi']
        df[cols] = df[cols].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    def calcular_isb_agua(df):
        df['isb_agua'] = np.nan
        df.loc[(df['disp_agua'] >= 3) & (~df['disp_agua'].isna()), 'isb_agua'] = 1
        df.loc[(df['procaptar'] == 1) & (df['disp_agua'] == 4), 'isb_agua'] = 0
        df.loc[(df['disp_agua'] <= 2) & (~df['disp_agua'].isna()), 'isb_agua'] = 0
        return df
    
    def calcular_isb_dren(df):
        df['isb_dren'] = np.nan
        df.loc[df['drenaje'] >= 3, 'isb_dren'] = 1
        df.loc[df['drenaje'] <= 2, 'isb_dren'] = 0
        return df
    
    def calcular_isb_luz(df):
        df['isb_luz'] = np.nan
        df.loc[df['disp_elect'] >= 5, 'isb_luz'] = 1
        df.loc[df['disp_elect'] <= 4, 'isb_luz'] = 0
        return df
    
    def calcular_isb_combus(df):
        df['combus'] = df['combustible']
        df['estufa'] = df['estufa_chi']
        df['isb_combus'] = np.nan
        df.loc[((df['combus'].isin([1, 2])) & (df['estufa'] == 2)), 'isb_combus'] = 1
        df.loc[((df['combus'].isin([1, 2])) & (df['estufa'] == 1)), 'isb_combus'] = 0
        df.loc[df['combus'].between(3, 6), 'isb_combus'] = 0
        return df
    
    def calcular_ic_sbv(df):
        df['ic_sbv'] = np.nan
        df.loc[((df['isb_agua'] == 1) | 
                (df['isb_dren'] == 1) | 
                (df['isb_luz'] == 1) | 
                (df['isb_combus'] == 1)), 'ic_sbv'] = 1  # Con carencia
        
        df.loc[((df['isb_agua'] == 0) & 
                (df['isb_dren'] == 0) & 
                (df['isb_luz'] == 0) & 
                (df['isb_combus'] == 0)), 'ic_sbv'] = 0  # Sin carencia
        
        df.loc[((df['isb_agua'].isna()) | 
                (df['isb_dren'].isna()) | 
                (df['isb_luz'].isna()) | 
                (df['isb_combus'].isna())), 'ic_sbv'] = np.nan
        return df
      
          # Seleccionar columnas finales
    def seleccionar_columnas(df):
        columnas = ['folioviv', 'foliohog', 'isb_agua', 'isb_dren', 'isb_luz', 'isb_combus', 'ic_sbv']
                    
        return df[columnas]  
    
    return (viviendas.copy()
                     .pipe(merge_concentradohogar)
                     .pipe(convertir_variables_numericas)
                     .pipe(calcular_isb_agua)
                     .pipe(calcular_isb_dren)
                     .pipe(calcular_isb_luz)
                     .pipe(calcular_isb_combus)
                     .pipe(calcular_ic_sbv)
                     .pipe(seleccionar_columnas)
                     )

servicios_basicos = indicador_servicios_basicos(viviendas)
```


```{python}
servicios_basicos.to_csv(current_directory + '/Output/Data/' + '/ic_sbv22_2.csv', index = False)
```


#### VI. Indicador de carencia por acceso a la alimentaci贸n nutritiva y de calidad {.tabset .tabset-pills .top3-tiles}  

##### Opci贸n 1 {.tabset .tabset-pills .top4-tiles} 
 
###### Grado de inseguridad alimentaria

```{python}
menores_alimentacion = poblacion.copy()

# Poblaci贸n objetivo: no se incluye a hu茅spedes ni trabajadores dom茅sticos
menores_alimentacion = menores_alimentacion[~((menores_alimentacion['parentesco'] >= 400) & 
                                              (menores_alimentacion['parentesco'] < 500) |
                                               (menores_alimentacion['parentesco'] >= 700) & 
                                                (menores_alimentacion['parentesco'] < 800))]

# Indicador de hogares con menores_alimentacion de 18 a帽os
menores_alimentacion['men'] = np.NaN
menores_alimentacion.loc[(menores_alimentacion['edad'].between(0, 17)), 'men'] = 1

menores_alimentacion = menores_alimentacion.groupby(['folioviv', 'foliohog'])['men'].sum().dropna().reset_index()

menores_alimentacion['id_men'] = np.NaN
menores_alimentacion.loc[((menores_alimentacion['men'] >= 1) & 
                          (~menores_alimentacion['men'].isna())), 'id_men'] = 1
menores_alimentacion.loc[(menores_alimentacion['men'] == 0), 'id_men'] = 0

menores_alimentacion = menores_alimentacion[['folioviv', 'foliohog', 'id_men']]
```

**Se guarda la base de datos** 
```{python}
menores_alimentacion.to_csv(current_directory + '/Output/Data/' + '/menores22.csv', index = False)
```

####### Grado de inseguridad alimentaria 

```{python}
hogares = pd.read_csv(current_directory + "/Bases de datos/hogares.csv", low_memory = False)
```

```{python}
alimentacion = hogares.copy()

#Convirtiendo variables string a numericas
alimentacion[['acc_alim2', 'acc_alim4', 'acc_alim5', 'acc_alim6', 'acc_alim7', 'acc_alim8', 'acc_alim11', 'acc_alim12', 
              'acc_alim13', 'acc_alim14', 'acc_alim15', 'acc_alim16']
             ] = alimentacion[['acc_alim2', 'acc_alim4', 'acc_alim5', 'acc_alim6', 'acc_alim7', 'acc_alim8',
                               'acc_alim11', 'acc_alim12', 'acc_alim13', 'acc_alim14', 'acc_alim15', 'acc_alim16']
                               ].apply(pd.to_numeric, errors = 'coerce')
                  
                  
# Parte 1. Grado de inseguridad alimentaria 
# Seis preguntas para hogares sin poblaci贸n menor a 18 a帽os

## Alg煤n adulto tuvo una alimentaci贸n basada en muy poca variedad de alimentos
alimentacion['ia_1ad'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim4'] == 2), 'ia_1ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim4'].isna()), 'ia_1ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim4'] == 1), 'ia_1ad'] = 1 # S铆

## Alg煤n adulto dej贸 de desayunar, comer o cenar
alimentacion['ia_2ad'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim5'] == 2), 'ia_2ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim5'].isna()), 'ia_2ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim5'] == 1), 'ia_2ad'] = 1 # S铆

## Alg煤n adulto comi贸 menos de lo que deb铆a comer
alimentacion['ia_3ad'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim6'] == 2), 'ia_3ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim6'].isna()), 'ia_3ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim6'] == 1), 'ia_3ad'] = 1 # S铆

## El hogar se qued贸 sin comida
alimentacion['ia_4ad'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim2'] == 2), 'ia_4ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim2'].isna()), 'ia_4ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim2'] == 1), 'ia_4ad'] = 1 # S铆

## Alg煤n adulto sinti贸 hambre pero no comi贸
alimentacion['ia_5ad'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim7'] == 2), 'ia_5ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim7'].isna()), 'ia_5ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim7'] == 1), 'ia_5ad'] = 1 # S铆

## Alg煤n adulto solo comi贸 una vez al d铆a o dej贸 de comer todo un d铆a
alimentacion['ia_6ad'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim8'] == 2), 'ia_6ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim8'].isna()), 'ia_6ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim8'] == 1), 'ia_6ad'] = 1 # S铆    

# Seis preguntas para hogares sin poblaci贸n menor a 18 a帽os
            
## Alguien de 0 a 17 a帽os tuvo una alimentaci贸n basada en muy poca variedad de alimentos
alimentacion['ia_7men'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim11'] == 2), 'ia_7men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim11'].isna()), 'ia_7men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim11'] == 1), 'ia_7men'] = 1 # S铆 

## Alguien de 0 a 17 a帽os comi贸 menos de lo que deb铆a
alimentacion['ia_8men'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim12'] == 2), 'ia_8men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim12'].isna()), 'ia_8men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim12'] == 1), 'ia_8men'] = 1 # S铆 

## Se tuvo que disminuir la cantidad servida en las comidas a alguien de 0 a 17 a帽os
alimentacion['ia_9men'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim13'] == 2), 'ia_9men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim13'].isna()), 'ia_9men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim13'] == 1), 'ia_9men'] = 1 # S铆 

## Alguien de 0 a 17 a帽os sinti贸 hambre pero no comi贸
alimentacion['ia_10men'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim14'] == 2), 'ia_10men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim14'].isna()), 'ia_10men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim14'] == 1), 'ia_10men'] = 1 # S铆 

## Alguien de 0 a 17 a帽os se acost贸 con hambre
alimentacion['ia_11men'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim15'] == 2), 'ia_11men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim15'].isna()), 'ia_11men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim15'] == 1), 'ia_11men'] = 1 # S铆 

## Alguien de 0 a 17 a帽os comi贸 una vez al d铆a o dej贸 de comer todo un d铆a
alimentacion['ia_12men'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim16'] == 2), 'ia_12men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim16'].isna()), 'ia_12men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim16'] == 1), 'ia_12men'] = 1 # S铆 

alimentacion = pd.merge(alimentacion, menores_alimentacion, 
                         on = ['folioviv', 'foliohog'], 
                          how = 'left')

#Convirtiendo variables string a numericas
alimentacion[['id_men', 'ia_1ad', 'ia_2ad', 'ia_3ad', 'ia_4ad', 'ia_5ad', 'ia_6ad', 'ia_7men', 'ia_8men',
              'ia_9men', 'ia_10men', 'ia_11men', 'ia_12men', 'alim17_1', 'alim17_2', 'alim17_3', 'alim17_4',
              'alim17_5', 'alim17_6', 'alim17_7', 'alim17_8', 'alim17_9','alim17_10', 'alim17_11', 'alim17_12']
             ] = alimentacion[['id_men', 'ia_1ad', 'ia_2ad', 'ia_3ad', 'ia_4ad', 'ia_5ad', 'ia_6ad', 'ia_7men',
                               'ia_8men', 'ia_9men', 'ia_10men', 'ia_11men', 'ia_12men', 'alim17_1', 'alim17_2',
                               'alim17_3', 'alim17_4', 'alim17_5', 'alim17_6', 'alim17_7', 'alim17_8', 'alim17_9',
                               'alim17_10', 'alim17_11', 'alim17_12']
                               ].apply(pd.to_numeric, errors = 'coerce')

# Construcci贸n de la escala de inseguridad alimentaria

# Escala para hogares sin menores de 18 a帽os
alimentacion['tot_iaad'] = np.NaN 
alimentacion.loc[(alimentacion['id_men'] == 0), 'tot_iaad'] = (alimentacion['ia_1ad']
                                                               ) + (alimentacion['ia_2ad']
                                                               ) + (alimentacion['ia_3ad']
                                                               ) + (alimentacion['ia_4ad']
                                                               ) + (alimentacion['ia_5ad']
                                                               ) + (alimentacion['ia_6ad'])
# Escala para hogares con menores de 18 a帽os
alimentacion['tot_iamen'] = np.NaN 
alimentacion.loc[(alimentacion['id_men'] == 1), 'tot_iamen'] = (alimentacion['ia_1ad']
                                                                ) + (alimentacion['ia_2ad']
                                                                ) + (alimentacion['ia_3ad']
                                                                ) + (alimentacion['ia_4ad']
                                                                ) +  (alimentacion['ia_5ad']
                                                                ) + (alimentacion['ia_6ad']
                                                                ) + (alimentacion['ia_7men']
                                                                ) +  (alimentacion['ia_8men']
                                                                ) + (alimentacion['ia_9men']
                                                                ) + (alimentacion['ia_10men']
                                                                ) + (alimentacion['ia_11men']
                                                                ) + (alimentacion['ia_12men'])

## Grado de inseguridad alimentaria
alimentacion['ins_ali'] = np.NaN

## Seguridad alimentaria 
alimentacion.loc[((alimentacion['tot_iaad'] == 0) | 
                  (alimentacion['tot_iamen'] == 0)), 'ins_ali'] = 0

## Inseguridad alimentaria leve
alimentacion.loc[((alimentacion['tot_iaad'] == 1) | (alimentacion['tot_iaad'] == 2) | 
                  (alimentacion['tot_iamen'] == 1) | (alimentacion['tot_iamen'] == 2) | 
                   (alimentacion['tot_iamen'] == 3)), 'ins_ali'] = 1

## Inseguridad alimentaria moderada
alimentacion.loc[((alimentacion['tot_iaad'] == 3) | (alimentacion['tot_iaad'] == 4) | 
                  (alimentacion['tot_iamen'] == 4) | (alimentacion['tot_iamen'] == 5) | 
                   (alimentacion['tot_iamen'] == 6) | (alimentacion['tot_iamen'] == 7)), 'ins_ali'] = 2

## Inseguridad alimentaria severa
alimentacion.loc[((alimentacion['tot_iaad'] == 5) | (alimentacion['tot_iaad'] == 6) | 
                  (alimentacion['tot_iamen'] >= 8) & (~alimentacion['tot_iamen'].isna())), 'ins_ali'] = 3   

# Se genera el indicador de carencia por acceso a la alimentaci贸n que considera en situaci贸n de carencia a la poblaci贸n en hogares que presenten inseguridad alimentaria moderada o severa

#Indicador de carencia por acceso a la alimentaci贸n
alimentacion['ic_ali'] = np.NaN
alimentacion.loc[((alimentacion['ins_ali'] == 2) | 
                  (alimentacion['ins_ali'] == 3)), 'ic_ali'] = 1 # Con carencia
alimentacion.loc[((alimentacion['ins_ali'] == 0) | 
                  (alimentacion['ins_ali'] == 1)), 'ic_ali'] = 0 # Sin carencia
```

###### Limitaci贸n en el consumo de alimentos  

Se considera el n煤mero de d铆as que se consumieron cada uno de los 12 grupos  de alimentos por el ponderador utilizado por el Programa Mundial de Alimentos (`PMA`) de las Naciones Unidas:   

`Grupo 1`: (ma铆z, avena, arroz, sorgo, mijo, pan y otros cereales) y (yuca, papas, camotes y otros tub茅rculos)  
`Grupo 2`: frijoles, ch铆charos, cacahuates, nueces  
`Grupo 3`: vegetales y hojas  
`Grupo 4`: frutas  
`Grupo 5`: carne de res, cabra, aves, cerdo, huevos y pescado  
`Grupo 6`: leche, yogur y otros l谩cteos  
`Grupo 7`: az煤cares y productos azucarados  
`Grupo 8`: aceites, grasas y mantequilla  
`Grupo 9`: especias, t茅, caf茅, sal, polvo de pescado, peque帽as cantidades de leche para el t茅  

El ponderador para el `Grupo 1` es 2, para el `Grupo 2` es 3, para el `Grupo 3` y `Grupo 4` es 1, para el `Grupo 5` y `Grupo 6` es 4, para el `Grupo 7` y `Grupo 8` es 0.5, y para el `Grupo 9` es 0.    


```{python}
alimentacion['cpond1'] = np.where(alimentacion['alim17_1'] > alimentacion['alim17_2'],
                                   alimentacion['alim17_1'],
                                    alimentacion['alim17_2']) * 2
alimentacion['cpond3'] = alimentacion['alim17_3'] * 1
alimentacion['cpond4'] = alimentacion['alim17_4'] * 1
alimentacion['cpond5'] = alimentacion[['alim17_5', 'alim17_6', 'alim17_7']].apply(lambda row: max(row), axis = 1) * 4
alimentacion['cpond8'] = alimentacion['alim17_8'] * 3
alimentacion['cpond9'] = alimentacion['alim17_9'] * 4
alimentacion['cpond10'] = alimentacion['alim17_10'] * 0.5
alimentacion['cpond11'] = alimentacion['alim17_11'] * 0.5
alimentacion['cpond12'] = alimentacion['alim17_12'] * 0

# Puntaje total de consumo ponderado de alimentos, indica el n煤mero ponderado de grupos de alimentos que se consumieron en los 煤ltimos siete d铆as.   
alimentacion['tot_cpond'] = alimentacion['cpond1' 
                             ] + alimentacion['cpond3'
                             ] + alimentacion['cpond4'
                             ] + alimentacion['cpond5'
                             ] + alimentacion['cpond8'
                             ] + alimentacion['cpond9'
                             ] + alimentacion['cpond10'
                             ] + alimentacion['cpond11'
                             ] + alimentacion['cpond12']

# Se categoriza la dieta consumida en los hogares
## Dieta consumida en los hogares
alimentacion['dch'] = np.NaN
alimentacion.loc[(alimentacion['tot_cpond'].between(0, 28)), 'dch'] = 1 # Pobre
alimentacion.loc[((alimentacion['tot_cpond'] > 28) &
                  (alimentacion['tot_cpond'] <= 42)), 'dch'] = 2 # Lim铆trofe
alimentacion.loc[((alimentacion['tot_cpond'] > 42) &
                  (~alimentacion['tot_cpond'].isna())), 'dch'] = 3 # Aceptable

## Limitaci贸n en el consumo de Alimentos
alimentacion['lca'] = np.NaN
alimentacion.loc[((alimentacion['dch'] == 1) |
                  (alimentacion['dch'] == 2)), 'lca'] = 1 # Limitado
alimentacion.loc[(alimentacion['dch'] == 3), 'lca'] = 0 # No limitado
```


###### Indicador de carencia por acceso a la alimentaci贸n nutritiva y de calidad   

Se considera en situaci贸n de carencia por acceso a la alimentaci贸n nutritiva y de calidad a la poblaci贸n en hogares que presenten, al menos, una de las siguientes caracter铆sticas:
  
1. Grado inseguridad alimentaria moderada o severa.   
2. Limitaci贸n en el consumo de alimentos.  


```{python}
alimentacion['ic_ali_nc'] = np.NaN
alimentacion.loc[((alimentacion['ic_ali'] == 0) &
                    (alimentacion['lca'] == 0)), 'ic_ali_nc'] = 0 # Sin carencia
alimentacion.loc[((alimentacion['ic_ali'] == 1) |
                  (alimentacion['lca'] == 1) &
                   ((~alimentacion['ic_ali'].isna()) &
                    (~alimentacion['lca'].isna()))), 'ic_ali_nc'] = 1 # Con carencia

alimentacion = alimentacion[['folioviv', 'foliohog', 'ia_1ad', 'ia_2ad', 'ia_3ad', 'ia_4ad', 'ia_5ad', 'ia_6ad',
                             'ia_7men', 'ia_8men', 'ia_9men', 'ia_10men', 'ia_11men', 'ia_12men', 'id_men',
                             'tot_iaad', 'tot_iamen', 'ins_ali', 'dch', 'lca', 'ic_ali', 'ic_ali_nc']]
```


**Se guarda la base de datos** 
```{python}
alimentacion.to_csv(current_directory + '/Output/Data/' + '/ic_ali22.csv', index = False)
```

##### Opci贸n 2 {.tabset .tabset-pills .top4-tiles} 
 
###### Grado de inseguridad alimentaria

```{python}
def indicador_menores_alimentacion (poblacion):
    # Funciones auxiliares
    def filtrar_poblacion_objetivo(df):
        return df[~((df['parentesco'] >= 400) & (df['parentesco'] < 500) | 
                    (df['parentesco'] >= 700) & (df['parentesco'] < 800))]
    
    def crear_indicador_menores(df):
        df['men'] = np.NaN
        df.loc[df['edad'].between(0, 17), 'men'] = 1
        return df
    
    def agrupar_y_contar_menores(df):
        return df.groupby(['folioviv', 'foliohog'])['men'].sum().dropna().reset_index()
    
    def calcular_id_men(df):
        df['id_men'] = np.NaN
        df.loc[(df['men'] >= 1) & (~df['men'].isna()), 'id_men'] = 1
        df.loc[df['men'] == 0, 'id_men'] = 0
        return df
      
      # Seleccionar columnas finales
    def seleccionar_columnas(df):
        columnas = ['folioviv', 'foliohog', 'id_men']
                    
        return df[columnas]  
      
    return (poblacion.copy()
                     .pipe(filtrar_poblacion_objetivo)
                     .pipe(crear_indicador_menores)
                     .pipe(agrupar_y_contar_menores)
                     .pipe(calcular_id_men)
                     .pipe(seleccionar_columnas)
                     )

# Uso de la funci贸n principal
menores_alimentacion = indicador_menores_alimentacion(poblacion)
```

**Se guarda la base de datos** 
```{python}
menores_alimentacion.to_csv(current_directory + '/Output/Data/' + '/menores22_2.csv', index = False)
```

####### Grado de inseguridad alimentaria 

```{python}
hogares = pd.read_csv(current_directory + "/Bases de datos/hogares.csv", low_memory = False)
```

```{python}
def indicador_alimentacion(hogares):
    # Funciones auxiliares
    def convertir_a_numerico(df):
        columnas = [
            'acc_alim2', 'acc_alim4', 'acc_alim5', 'acc_alim6', 'acc_alim7', 'acc_alim8', 
            'acc_alim11', 'acc_alim12', 'acc_alim13', 'acc_alim14', 'acc_alim15', 'acc_alim16'
        ]
        df[columnas] = df[columnas].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    def crear_indicador_adultos(df):
        indicadores_adultos = {
            'ia_1ad': 'acc_alim4', 'ia_2ad': 'acc_alim5', 'ia_3ad': 'acc_alim6', 
            'ia_4ad': 'acc_alim2', 'ia_5ad': 'acc_alim7', 'ia_6ad': 'acc_alim8'
        }
        
        for indicador, columna in indicadores_adultos.items():
            df[indicador] = np.NaN
            df.loc[df[columna] == 2, indicador] = 0
            df.loc[df[columna].isna(), indicador] = 0
            df.loc[df[columna] == 1, indicador] = 1
        
        return df
    
    def crear_indicador_menores(df):
        indicadores_menores = {
            'ia_7men': 'acc_alim11', 'ia_8men': 'acc_alim12', 'ia_9men': 'acc_alim13', 
            'ia_10men': 'acc_alim14', 'ia_11men': 'acc_alim15', 'ia_12men': 'acc_alim16'
        }
        
        for indicador, columna in indicadores_menores.items():
            df[indicador] = np.NaN
            df.loc[df[columna] == 2, indicador] = 0
            df.loc[df[columna].isna(), indicador] = 0
            df.loc[df[columna] == 1, indicador] = 1
        
        return df
    # Funciones auxiliares
    def merge_menores_alimentacion(df):
        return pd.merge(df, 
                         menores_alimentacion, 
                          on = ['folioviv', 'foliohog'],
                           how = 'left')
                           
        # Funci贸n para convertir variables string a num茅ricas
    def convertir_a_numerico_2(df):
        columnas = [
            'id_men', 'ia_1ad', 'ia_2ad', 'ia_3ad', 'ia_4ad', 'ia_5ad', 'ia_6ad', 'ia_7men', 'ia_8men',
            'ia_9men', 'ia_10men', 'ia_11men', 'ia_12men', 'alim17_1', 'alim17_2', 'alim17_3', 'alim17_4',
            'alim17_5', 'alim17_6', 'alim17_7', 'alim17_8', 'alim17_9', 'alim17_10', 'alim17_11', 'alim17_12'
        ]
        df[columnas] = df[columnas].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    # Funci贸n para calcular los totales de inseguridad alimentaria
    def calcular_totales_inseguridad(df):
        df['tot_iaad'] = np.NaN
        df.loc[df['id_men'] == 0, 'tot_iaad'] = (
                                                 df['ia_1ad'] + df['ia_2ad'] + df['ia_3ad'] + df['ia_4ad'] +
                                                 df['ia_5ad'] + df['ia_6ad']
                                                )
        
        df['tot_iamen'] = np.NaN
        df.loc[df['id_men'] == 1, 'tot_iamen'] = (
                                                  df['ia_1ad'] + df['ia_2ad'] + df['ia_3ad'] + df['ia_4ad'] +
                                                  df['ia_5ad'] + df['ia_6ad'] + df['ia_7men'] + df['ia_8men'] +
                                                  df['ia_9men'] + df['ia_10men'] + df['ia_11men'] + df['ia_12men']
                                                  )
        return df
    
    # Funci贸n para calcular el grado de inseguridad alimentaria
    def calcular_grado_inseguridad(df):
        df['ins_ali'] = np.NaN
        df.loc[(df['tot_iaad'] == 0) | (df['tot_iamen'] == 0), 'ins_ali'] = 0
        df.loc[(df['tot_iaad'].isin([1, 2])) | (df['tot_iamen'].isin([1, 2, 3])), 'ins_ali'] = 1
        df.loc[(df['tot_iaad'].isin([3, 4])) | (df['tot_iamen'].isin([4, 5, 6, 7])), 'ins_ali'] = 2
        df.loc[(df['tot_iaad'].isin([5, 6])) | (df['tot_iamen'] >= 8),'ins_ali'] = 3
        
        return df
    
    # Funci贸n para calcular el indicador de carencia por acceso a la alimentaci贸n
    def calcular_indicador_carencia(df):
        df['ic_ali'] = np.NaN
        df.loc[df['ins_ali'].isin([2, 3]), 'ic_ali'] = 1  # Con carencia
        df.loc[df['ins_ali'].isin([0, 1]), 'ic_ali'] = 0  # Sin carencia
        return df
      
    return (hogares.copy()
                   .pipe(convertir_a_numerico)
                   .pipe(crear_indicador_adultos)
                   .pipe(crear_indicador_menores)
                   .pipe(merge_menores_alimentacion)
                   .pipe(convertir_a_numerico_2)
                   .pipe(calcular_totales_inseguridad)
                   .pipe(calcular_grado_inseguridad)
                   .pipe(calcular_indicador_carencia)
                   )
alimentacion = indicador_alimentacion(hogares)                   
```


###### Limitaci贸n en el consumo de alimentos  

Se considera el n煤mero de d铆as que se consumieron cada uno de los 12 grupos  de alimentos por el ponderador utilizado por el Programa Mundial de Alimentos (`PMA`) de las Naciones Unidas:   

`Grupo 1`: (ma铆z, avena, arroz, sorgo, mijo, pan y otros cereales) y (yuca, papas, camotes y otros tub茅rculos)  
`Grupo 2`: frijoles, ch铆charos, cacahuates, nueces  
`Grupo 3`: vegetales y hojas  
`Grupo 4`: frutas  
`Grupo 5`: carne de res, cabra, aves, cerdo, huevos y pescado  
`Grupo 6`: leche, yogur y otros l谩cteos  
`Grupo 7`: az煤cares y productos azucarados  
`Grupo 8`: aceites, grasas y mantequilla  
`Grupo 9`: especias, t茅, caf茅, sal, polvo de pescado, peque帽as cantidades de leche para el t茅  

El ponderador para el `Grupo 1` es 2, para el `Grupo 2` es 3, para el `Grupo 3` y `Grupo 4` es 1, para el `Grupo 5` y `Grupo 6` es 4, para el `Grupo 7` y `Grupo 8` es 0.5, y para el `Grupo 9` es 0.    


```{python}
def indicador_alimentacion_anexoa(alimentacion):
    # Funci贸n para calcular los diferentes valores de cpond
    def calcular_cpond(df):
        df['cpond1'] = np.where(df['alim17_1'] > df['alim17_2'], df['alim17_1'], df['alim17_2']) * 2
        df['cpond3'] = df['alim17_3'] * 1
        df['cpond4'] = df['alim17_4'] * 1
        df['cpond5'] = df[['alim17_5', 'alim17_6', 'alim17_7']].apply(lambda row: max(row), axis=1) * 4
        df['cpond8'] = df['alim17_8'] * 3
        df['cpond9'] = df['alim17_9'] * 4
        df['cpond10'] = df['alim17_10'] * 0.5
        df['cpond11'] = df['alim17_11'] * 0.5
        df['cpond12'] = df['alim17_12'] * 0
        return df
    
    # Funci贸n para calcular el puntaje total de consumo ponderado de alimentos
    def calcular_tot_cpond(df):
        df['tot_cpond'] = (df['cpond1'] + df['cpond3'] + df['cpond4'] + df['cpond5'] + df['cpond8'] + 
                           df['cpond9'] + df['cpond10'] + df['cpond11'] + df['cpond12'])
        return df
    
    # Funci贸n para categorizar la dieta consumida en los hogares
    def categorizar_dieta(df):
        df['dch'] = np.NaN
        df.loc[df['tot_cpond'].between(0, 28), 'dch'] = 1  # Pobre
        df.loc[(df['tot_cpond'] > 28) & (df['tot_cpond'] <= 42), 'dch'] = 2  # Lim铆trofe
        df.loc[(df['tot_cpond'] > 42) & (~df['tot_cpond'].isna()), 'dch'] = 3  # Aceptable
        
        return df
    
    # Funci贸n para calcular la limitaci贸n en el consumo de alimentos
    def calcular_limitacion_consumo(df):
        df['lca'] = np.NaN
        df.loc[(df['dch'] == 1) | (df['dch'] == 2), 'lca'] = 1  # Limitado
        df.loc[df['dch'] == 3, 'lca'] = 0  # No limitado
        
        return df
      
    return (alimentacion.copy()
                        .pipe(calcular_cpond)
                        .pipe(calcular_tot_cpond)
                        .pipe(categorizar_dieta)
                        .pipe(calcular_limitacion_consumo)
                        )

alimentacion = indicador_alimentacion_anexoa(alimentacion) 
```


###### Indicador de carencia por acceso a la alimentaci贸n nutritiva y de calidad   

Se considera en situaci贸n de carencia por acceso a la alimentaci贸n nutritiva y de calidad a la poblaci贸n en hogares que presenten, al menos, una de las siguientes caracter铆sticas:
  
1. Grado inseguridad alimentaria moderada o severa.   
2. Limitaci贸n en el consumo de alimentos.  


```{python}
def indicador_alimentacion_anexob(alimentacion):
      # Funci贸n para calcular la columna ic_ali_nc
    def calcular_ic_ali_nc(df):
        df['ic_ali_nc'] = np.NaN
        df.loc[(df['ic_ali'] == 0) & (df['lca'] == 0), 'ic_ali_nc'] = 0  # Sin carencia
        df.loc[(df['ic_ali'] == 1) | ((df['lca'] == 1) & (~df['ic_ali'].isna()) & (~df['lca'].isna())), 'ic_ali_nc'] = 1  # Con carencia
        return df
    
    # Funci贸n para seleccionar las columnas finales
    def seleccionar_columnas_finales(df):
        columnas = ['folioviv', 'foliohog', 'ia_1ad', 'ia_2ad', 'ia_3ad', 'ia_4ad', 'ia_5ad', 'ia_6ad',
                    'ia_7men', 'ia_8men', 'ia_9men', 'ia_10men', 'ia_11men', 'ia_12men', 'id_men',
                    'tot_iaad', 'tot_iamen', 'ins_ali', 'dch', 'lca', 'ic_ali', 'ic_ali_nc']
        return df[columnas]
      
    return (alimentacion.copy()
                        .pipe(calcular_ic_ali_nc)
                        .pipe(seleccionar_columnas_finales))
                        
alimentacion = indicador_alimentacion_anexob(alimentacion) 
```


**Se guarda la base de datos** 
```{python}
alimentacion.to_csv(current_directory + '/Output/Data/' + 'ic_ali22_2.csv', index = False)
```


#### VII. Bienestar econ贸mico (ingresos) {.tabset .tabset-pills .top3-tiles}   

##### Opci贸n 1 {.tabset .tabset-pills .top4-tiles}   

###### Ingresos    

Para la construcci贸n del ingreso corriente del hogar es necesario utilizar informaci贸n sobre la condici贸n de ocupaci贸n y los ingresos de los individuos.  
Se utiliza la informaci贸n contenida en la base trabajo.csv para identificar a la poblaci贸n ocupada que declara tener como prestaci贸n laboral aguinaldo, ya sea por su trabajo principal o secundario, a fin de incorporar los ingresos por este concepto en la medici贸n

Creaci贸n del ingreso monetario deflactado a pesos de agosto del 2022   

```{python}
trabajos = pd.read_csv(current_directory + "/Bases de datos/trabajos.csv", low_memory = False)
```


```{python}
aguinaldos = trabajos.copy()

#Convirtiendo variables string a numericas
aguinaldos[['numren', 'id_trabajo', 'pres_2']
           ] = aguinaldos[['numren', 'id_trabajo', 'pres_2']
                          ].apply(pd.to_numeric, errors = 'coerce')

#Generando la base de aguinaldo
aguinaldos = pd.pivot_table(aguinaldos, 
                             index=['folioviv', 'foliohog', 'numren'], 
                              columns = 'id_trabajo', 
                               values=['pres_2'], 
                                aggfunc = np.sum, 
                                 fill_value = 0)
                                 
aguinaldos.columns = [f'{i}{j}' for i, j in aguinaldos.columns]
aguinaldos = aguinaldos.reset_index()

aguinaldos['trab'] = 1 # Poblaci贸n con al menos un empleo 

aguinaldos['aguinaldo1'] = np.where(aguinaldos['pres_21'] == 2, 1, 0) # Aguinaldo trabajo principal
aguinaldos['aguinaldo2'] = np.where(aguinaldos['pres_22'] == 2, 1, 0) # Aguinaldo trabajo secundario

aguinaldos = aguinaldos[['folioviv', 'foliohog', 'numren', 'aguinaldo1', 'aguinaldo2', 'trab']]
```

**Se guarda la base de datos** 
```{python}
aguinaldos.to_csv(current_directory + '/Output/Data/' + 'aguinaldo22.csv', index = False)
```

**Ahora se incorpora a la base de ingresos**

```{python}
ingresos = pd.read_csv(current_directory + "/Bases de datos/ingresos.csv", low_memory = False)
```


```{python}
ingreso_deflactado = ingresos.copy()

ingreso_deflactado = pd.merge(ingresos, 
                               aguinaldos, 
                                on = ['folioviv', 'foliohog', 'numren'], 
                                 how = 'outer') 

ingreso_deflactado = ingreso_deflactado[~(((ingreso_deflactado['clave'] == 'P009') & (ingreso_deflactado['aguinaldo1'] != 1)) |
                                          ((ingreso_deflactado['clave'] == 'P016') & (ingreso_deflactado['aguinaldo2'] != 1)))]
```

Una vez realizado lo anterior, se procede a deflactar el ingreso recibido por los hogares a precios de agosto de 2022. Para ello, se utilizan las variables meses, las cuales toman los valores 2 a 10 e indican el mes en que se recibi贸 el ingreso respectivo.   

**Definici贸n de los deflactores 2022**   

```{python}
# Definici贸n de los deflactores 2022 
dic21 =	0.9475376203	
ene22 =	0.9531433002
feb22 =	0.9610510246	
mar22 =	0.9705661414	
abr22 =	0.9758164180	
may22 =	0.9775368933
jun22 =	0.9857919437	
jul22 =	0.9930938669
ago22 =	1.0000000000
sep22 =	1.0062034038
oct22 =	1.0118979346
nov22 =	1.0177217030
dic22 =	1.0216069077
```

```{python}
#Convirtiendo variables string a numericas
ingreso_deflactado[['mes_1', 'mes_2', 'mes_3', 'mes_4', 'mes_5', 'mes_6', 'ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']
                     ] = ingreso_deflactado[['mes_1', 'mes_2', 'mes_3', 'mes_4', 'mes_5', 'mes_6', 'ing_1', 'ing_2', 'ing_3', 'ing_4',
                                               'ing_5', 'ing_6']
                                              ].apply(pd.to_numeric, errors = 'coerce')

ingreso_deflactado['ing_6'] = np.where(ingreso_deflactado['mes_6'].isna(), 
                                        ingreso_deflactado['ing_6'] ,
                              np.where(ingreso_deflactado['mes_6'] == 2, 
                                        ingreso_deflactado['ing_6'] / feb22,
                              np.where(ingreso_deflactado['mes_6'] == 3, 
                                        ingreso_deflactado['ing_6'] / mar22,
                              np.where(ingreso_deflactado['mes_6'] == 4, 
                                        ingreso_deflactado['ing_6'] / abr22,
                                         ingreso_deflactado['ing_6'] / may22))))
ingreso_deflactado['ing_5'] = np.where(ingreso_deflactado['mes_5'].isna(), 
                                        ingreso_deflactado['ing_5'] ,
                              np.where(ingreso_deflactado['mes_5'] == 3, 
                                        ingreso_deflactado['ing_5'] / mar22,
                              np.where(ingreso_deflactado['mes_5'] == 4, 
                                        ingreso_deflactado['ing_5'] / abr22,
                              np.where(ingreso_deflactado['mes_5'] == 5, 
                                        ingreso_deflactado['ing_5'] / may22,
                                         ingreso_deflactado['ing_5'] / jun22))))
ingreso_deflactado['ing_4'] = np.where(ingreso_deflactado['mes_4'].isna(), 
                                        ingreso_deflactado['ing_4'] ,
                              np.where(ingreso_deflactado['mes_4'] == 4,  
                                        ingreso_deflactado['ing_4'] / abr22,
                              np.where(ingreso_deflactado['mes_4'] == 5, 
                                        ingreso_deflactado['ing_4'] / may22,
                              np.where(ingreso_deflactado['mes_4'] == 6, 
                                        ingreso_deflactado['ing_4'] / jun22,
                                         ingreso_deflactado['ing_4'] / jul22))))
ingreso_deflactado['ing_3'] = np.where(ingreso_deflactado['mes_3'].isna(), 
                                        ingreso_deflactado['ing_3'] ,
                              np.where(ingreso_deflactado['mes_3'] == 5, 
                                        ingreso_deflactado['ing_3'] / may22,
                              np.where(ingreso_deflactado['mes_3'] == 6,  
                                        ingreso_deflactado['ing_3'] / jun22,
                              np.where(ingreso_deflactado['mes_3'] == 7, 
                                        ingreso_deflactado['ing_3'] / jul22,
                                         ingreso_deflactado['ing_3'] / ago22))))
ingreso_deflactado['ing_2'] = np.where(ingreso_deflactado['mes_2'].isna(), 
                                        ingreso_deflactado['ing_2'] ,
                              np.where(ingreso_deflactado['mes_2'] == 6, 
                                        ingreso_deflactado['ing_2'] / jun22,
                              np.where(ingreso_deflactado['mes_2'] == 7, 
                                        ingreso_deflactado['ing_2'] / jul22,
                              np.where(ingreso_deflactado['mes_2'] == 8, 
                                        ingreso_deflactado['ing_2'] / ago22,
                                         ingreso_deflactado['ing_2'] / sep22))))
ingreso_deflactado['ing_1'] = np.where(ingreso_deflactado['mes_1'].isna(), 
                                        ingreso_deflactado['ing_1'] ,
                              np.where(ingreso_deflactado['mes_1'] == 7, 
                                        ingreso_deflactado['ing_1'] / jul22,
                              np.where(ingreso_deflactado['mes_1'] == 8, 
                                        ingreso_deflactado['ing_1'] / ago22,
                              np.where(ingreso_deflactado['mes_1'] == 9, 
                                        ingreso_deflactado['ing_1'] / sep22,
                                         ingreso_deflactado['ing_1'] / oct22))))
```

Se deflactan las claves P008 y P015 (Reparto de utilidades) y P009 y P016 (aguinaldo) con los deflactores de mayo a agosto 2022 y de diciembre de 2021 a agosto 2022, respectivamente, y se obtiene el promedio mensual.   

```{python}
index = ['P008', 'P009', 'P015', 'P016']
```

```{python}
ingreso_deflactado.loc[ingreso_deflactado['clave'].isin(['P008', 'P015']), 'ing_1'] = ingreso_deflactado['ing_1'] / may22 / 12
ingreso_deflactado.loc[ingreso_deflactado['clave'].isin(['P009', 'P016']), 'ing_1'] = ingreso_deflactado['ing_1'] / dic21 / 12

cols = ['ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']
for col in cols:
    ingreso_deflactado.loc[ingreso_deflactado['clave'].isin(index) & ([col] == 0), col] = None
    
# Una vez realizada la deflactaci贸n, se procede a obtener el ingreso mensual promedio en los 煤ltimos seis meses, para cada persona y clave de ingreso
ingreso_deflactado['ing_mens'] = ingreso_deflactado[['ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']].mean(axis = 1, skipna = True)

# Para obtener el ingreso corriente monetario, se seleccionan las claves de ingreso correspondientes
ingreso_deflactado.loc[((ingreso_deflactado['clave'].between('P001', 'P009')) |
                        (ingreso_deflactado['clave'].between('P011', 'P016')) | 
                         (ingreso_deflactado['clave'].between('P018', 'P048')) | 
                          (ingreso_deflactado['clave'].between('P067', 'P081')) | 
                           (ingreso_deflactado['clave'].between('P101', 'P108'))), 'ing_mon'] = ingreso_deflactado['ing_mens']

# Para obtener el ingreso laboral, se seleccionan las claves de ingreso correspondientes
ingreso_deflactado.loc[((ingreso_deflactado['clave'].between('P001', 'P009')) | 
                        (ingreso_deflactado['clave'].between('P011', 'P016')) | 
                         (ingreso_deflactado['clave'].between('P018', 'P022')) | 
                          (ingreso_deflactado['clave'].between('P067', 'P081'))), 'ing_lab'] = ingreso_deflactado['ing_mens']

# Para obtener el ingreso por rentas, se seleccionan las claves de ingreso correspondientes
ingreso_deflactado.loc[ingreso_deflactado['clave'].between('P023', 'P031'), 'ing_ren'] = ingreso_deflactado['ing_mens']

# Para obtener el ingreso por transferencias, se seleccionan las claves de ingreso correspondientes
ingreso_deflactado.loc[((ingreso_deflactado['clave'].between('P032', 'P048')) | 
                        (ingreso_deflactado['clave'].between('P101', 'P108'))), 'ing_tra'] = ingreso_deflactado['ing_mens']

# Se estima el total de ingresos de cada  hogar
ingreso_deflactado = ingreso_deflactado.groupby(['folioviv', 'foliohog'])[['ing_mon', 'ing_lab', 'ing_ren', 'ing_tra']
                                                                          ].sum(numeric_only = True)
ingreso_deflactado = ingreso_deflactado.reset_index()
```

**Se guarda la base de datos** 
```{python}
ingreso_deflactado.to_csv(current_directory + '/Output/Data/' + '/ingreso_deflactado22.csv', index = False)
```

###### No Monetario  

En el caso de la informaci贸n de gasto no monetario, para deflactar se utiliza la decena de levantamiento de la encuesta, la cual se encuentra en la octava posici贸n del folio de la vivienda. En primer lugar se obtiene una variable que identifique la decena de levantamiento.   

Creaci贸n del ingreso no monetario deflactado a pesos de agosto del 2022.  

```{python}
gastoshogar = pd.read_csv(current_directory + "/Bases de datos/gastoshogar.csv", low_memory = False).astype(str)
gastospersona = pd.read_csv(current_directory + "/Bases de datos/gastospersona.csv", low_memory = False).astype(str)

gastoshogar['base'] = 1
```

```{python}
no_monetario = pd.concat([gastoshogar, gastospersona], 
                          ignore_index = True)
                          
no_monetario.loc[no_monetario['base'].isna(), 'base'] = 2

no_monetario.loc[no_monetario['base'] == 2, 'frecuencia'] = no_monetario['frec_rem']

# En el caso de la informaci贸n de gasto no monetario, para deflactar se utiliza la decena de levantamiento de la encuesta, 
# la cual se encuentra en la octava posici贸n del folio de la vivienda. En primer lugar se obtiene una variable que 
# identifique la decena de levantamiento.  

no_monetario['decena'] = no_monetario['folioviv'].astype(str).str.zfill(10).str[7]
```

**Definici贸n de los deflactores**

```{python}
# Definici贸n de los deflactores
d11w07 = 0.9869825057
d11w08 = 1.0000000000
d11w09 = 1.0130754464
d11w10 = 1.0178275200
d11w11 = 1.0207468579

# Rubro 1.2 semanal, Bebidas alcoh贸licas y tabaco		
d12w07 = 0.9923340135
d12w08 = 1.0000000000
d12w09 = 1.0035071112
d12w10 = 1.0111808568
d12w11 = 1.0131982216

# Rubro 2 trimestral, Vestido, calzado y accesorios		
d2t05 = 0.9899050815
d2t06 = 0.9941003723
d2t07 = 0.9997465345
d2t08 = 1.0083352270

# Rubro 3 mensual, viviendas		
d3m07 = 0.9998142481
d3m08 = 1.0000000000
d3m09 = 0.9978682753
d3m10 = 1.0031577830
d3m11 = 1.0197073965

# Rubro 4.2 mensual, Accesorios y art铆culos de limpieza para el hogar		
d42m07 = 0.9894769136
d42m08 = 1.0000000000
d42m09 = 1.0086286240
d42m10 = 1.0182083142
d42m11 = 1.0237613131

# Rubro 4.2 trimestral, Accesorios y art铆culos de limpieza para el hogar		
d42t05 = 0.9787953163
d42t06 = 0.9897197934
d42t07 = 0.9993685126
d42t08 = 1.0089456461

# Rubro 4.1 semestral, Muebles y aparatos d贸mesticos		
d41s02 = 1.0003069312
d41s03 = 0.9993861376
d41s04 = 0.9992122603
d41s05 = 0.9991442214

# Rubro 5.1 trimestral, Salud		
d51t05 = 0.9909917367
d51t06 = 0.9954834527
d51t07 = 0.9994564693
d51t08 = 1.0030487384

# Rubro 6.1.1 semanal, Transporte p煤blico urbano		
d611w07 = 0.9963207274
d611w08 = 1.0000000000
d611w09 = 1.0034865488
d611w10 = 1.0052385833
d611w11 = 1.0064912880

# Rubro 6 mensual, Transporte		
d6m07 = 0.9987845893
d6m08 = 1.0000000000
d6m09 = 1.0001664946
d6m10 = 1.0057274150
d6m11 = 1.0076837268

# Rubro 6 semestral, Transporte		
d6s02 = 0.9808628306
d6s03 = 0.9879901879
d6s04 = 0.9927380596
d6s05 = 0.9969378864

# Rubro 7 mensual, Educaci贸n y esparcimiento		
d7m07 = 0.9961413091
d7m08 = 1.0000000000
d7m09 = 1.0095233900
d7m10 = 1.0144128271
d7m11 = 1.0174522069

# Rubro 2.3 mensual, Accesorios y cuidados del vestido		
d23m07 = 0.9952443607
d23m08 = 1.0000000000
d23m09 = 1.0081869233
d23m10 = 1.0108184343
d23m11 = 1.0072323555

# Rubro 2.3 trimestral,  Accesorios y cuidados del vestido		
d23t05 = 0.9914948875
d23t06 = 0.9956428139
d23t07 = 1.0011437613
d23t08 = 1.0063351192

# INPC semestral		
dINPCs02 = 0.9773093813
dINPCs03 = 0.9838008772
dINPCs04 = 0.9897404209
dINPCs05 = 0.9957540070
```


**Una vez definidos los deflactores, se seleccionan los rubros** 

```{python}
#Convirtiendo variables string a numericas
no_monetario[['gas_nm_tri', 'gasto_nm']] = no_monetario[['gas_nm_tri', 'gasto_nm']
                                                        ].apply(pd.to_numeric, errors = 'coerce')

# Una vez definidos los deflactores, se seleccionan los rubros
no_monetario['gasnomon'] = no_monetario['gas_nm_tri'] / 3
no_monetario.loc[no_monetario['tipo_gasto'] == 'G4', 'esp'] = 1
no_monetario.loc[no_monetario['tipo_gasto'].isin(['G5', 'G6']), 'reg'] = 1
no_monetario = no_monetario.loc[~no_monetario['tipo_gasto'].isin(['G2', 'G3', 'G7'])]

# Control para la frecuencia de los regalos recibidos por el hogar
no_monetario = no_monetario[~(((no_monetario['frecuencia'].between('5', '6')) |
                               (no_monetario['frecuencia'].isna()) |
                                (no_monetario['frecuencia'] == '0')) &
                                 (no_monetario['base'] == 1) &
                                  (no_monetario['tipo_gasto'] == 'G5'))]

# Control para la frecuencia de los regalos recibidos por persona
no_monetario = no_monetario[~(((no_monetario['frecuencia'] == '9') |
                              (no_monetario['frecuencia'].isna())) &
                               (no_monetario['base'] == 2) &
                                (no_monetario['tipo_gasto'] == 'G5'))]

# Se deflactan los rubros del gasto no monetario seg煤n la decena de levantamiento 
no_monetario.loc[(no_monetario['clave'].between('A001', 'A222') |
                   no_monetario['clave'].between('A242', 'A247')), 'ali_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('A223', 'A241')), 'alta_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('H001', 'H122') |
                  (no_monetario['clave'] == 'H136')), 'veca_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('G001', 'G016') |
                   no_monetario['clave'].between('R001', 'R004') |
                    (no_monetario['clave'] == 'R013')), 'viv_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('C001', 'C024')), 'lim_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('I001', 'I026')), 'cris_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('K001', 'K037')), 'ens_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('J001', 'J072')), 'sal_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('B001', 'B007')), 'tpub_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('M001', 'M018') |
                   no_monetario['clave'].between('F007', 'F014')), 'tfor_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('F001', 'F006') |
                   no_monetario['clave'].between('R005', 'R008') |
                    no_monetario['clave'].between('R010', 'R011')), 'com_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('E001', 'E034') |
                   no_monetario['clave'].between('H134', 'H135') |
                    no_monetario['clave'].between('L001', 'L029') |
                     no_monetario['clave'].between('N003', 'N005') |
                      (no_monetario['clave'] == 'R009')), 'edre_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('E002', 'E003') |
                   no_monetario['clave'].between('H134', 'H135')), 'edba_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('D001', 'D026') |
                  (no_monetario['clave'] == 'H132')), 'cuip_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('H123', 'H131') |
                   (no_monetario['clave'] == 'H133')), 'accp_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('N001', 'N002') |
                   no_monetario['clave'].between('N006', 'N016') |
                    no_monetario['clave'].between('T901', 'T915') |
                     (no_monetario['clave'] == 'R012')), 'otr_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('T901', 'T915') |
                  (no_monetario['clave'] == 'N013')), 'reda_nm'] = no_monetario['gasnomon']

# Gasto no monetario en Alimentos deflactado (semanal)
no_monetario['ali_nm'] = np.where(no_monetario['decena'].isin(['1','2','3']), no_monetario['ali_nm']/d11w08, 
                          np.where(no_monetario['decena'].isin(['4','5','6']), no_monetario['ali_nm']/d11w09,
                           np.where(no_monetario['decena'].isin(['7','8','9']), no_monetario['ali_nm']/d11w10,
                                    no_monetario['ali_nm']/d11w11)))

# Gasto no monetario en Alcohol y tabaco deflactado (semanal)
no_monetario['alta_nm'] = np.where(no_monetario['decena'].isin(['1','2','3']), no_monetario['alta_nm']/d12w08,
                           np.where(no_monetario['decena'].isin(['4','5','6']), no_monetario['alta_nm']/d12w09,
                            np.where(no_monetario['decena'].isin(['7','8','9']), no_monetario['alta_nm']/d12w10,
                                      no_monetario['alta_nm']/d12w11)))

# Gasto no monetario en Vestido y calzado deflactado (trimestral)
no_monetario['veca_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['veca_nm']/d2t05,
                           np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['veca_nm']/d2t06,
                            np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['veca_nm']/d2t07,
                                      no_monetario['veca_nm']/d2t08)))

# Gasto no monetario en viviendas y servicios de conservaci贸n deflactado (mensual)
no_monetario['viv_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['viv_nm']/d3m07,
                          np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['viv_nm']/d3m08,
                           np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['viv_nm']/d3m09,
                                     no_monetario['viv_nm']/d3m10)))

# Gasto no monetario en Art铆culos de limpieza deflactado (mensual)
no_monetario['lim_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['lim_nm']/d42m07,
                          np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['lim_nm']/d42m08,
                           np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['lim_nm']/d42m09,
                                     no_monetario['lim_nm']/d42m10)))

# Gasto no monetario en Cristaler铆a y blancos deflactado (trimestral)
no_monetario['cris_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['cris_nm']/d42t05,
                           np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['cris_nm']/d42t06,
                            np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['cris_nm']/d42t07,
                                      no_monetario['cris_nm']/d42t08)))

# Gasto no monetario en Enseres dom茅sticos y muebles deflactado (semestral)
no_monetario['ens_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['ens_nm']/d41s02,
                          np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['ens_nm']/d41s03,
                           np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['ens_nm']/d41s04,
                                     no_monetario['ens_nm']/d41s05)))

# Gasto no monetario en Salud deflactado (trimestral)
no_monetario['sal_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['sal_nm']/d51t05,
                          np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['sal_nm']/d51t06,
                           np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['sal_nm']/d51t07,
                                     no_monetario['sal_nm']/d51t08)))

# Gasto no monetario en Transporte p煤blico deflactado (semanal)
no_monetario['tpub_nm'] = np.where(no_monetario['decena'].isin(['1','2','3']), no_monetario['tpub_nm']/d611w08,
                           np.where(no_monetario['decena'].isin(['4','5','6']), no_monetario['tpub_nm']/d611w09,
                            np.where(no_monetario['decena'].isin(['7','8','9']), no_monetario['tpub_nm']/d611w10,
                                      no_monetario['tpub_nm']/d611w11)))

# Gasto no monetario en Transporte for谩neo deflactado (semestral)
no_monetario['tfor_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['tfor_nm']/d6s02,
                           np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['tfor_nm']/d6s03,
                            np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['tfor_nm']/d6s04,
                                      no_monetario['tfor_nm']/d6s05)))

# Gasto no monetario en Comunicaciones deflactado (mensual)
no_monetario['com_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['com_nm']/d6m07,
                          np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['com_nm']/d6m08,
                           np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['com_nm']/d6m09,
                                     no_monetario['com_nm']/d6m10)))

# Gasto no monetario en Educaci贸n y recreaci贸n deflactado (mensual)
no_monetario['edre_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['edre_nm']/d7m07,
                           np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['edre_nm']/d7m08,
                            np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['edre_nm']/d7m09,
                                      no_monetario['edre_nm']/d7m10)))

# Gasto no monetario en Educaci贸n b谩sica deflactado (mensual)
no_monetario['edba_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['edba_nm']/d7m07,
                           np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['edba_nm']/d7m08,
                            np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['edba_nm']/d7m09,
                                      no_monetario['edba_nm']/d7m10)))

# Gasto no monetario en Cuidado personal deflactado (mensual)
no_monetario['cuip_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['cuip_nm']/d23m07,
                           np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['cuip_nm']/d23m08,
                            np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['cuip_nm']/d23m09,
                                      no_monetario['cuip_nm']/d23m10)))

# Gasto no monetario en Accesorios personales deflactado (trimestral)
no_monetario['accp_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['accp_nm']/d23t05,
                           np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['accp_nm']/d23t06,
                            np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['accp_nm']/d23t07,
                                      no_monetario['accp_nm']/d23t08)))

# Gasto no monetario en Otros gastos y transferencias deflactado (semestral)
no_monetario['otr_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['otr_nm']/dINPCs02,
                          np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['otr_nm']/dINPCs03,
                           np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['otr_nm']/dINPCs04,
                                     no_monetario['otr_nm']/dINPCs05)))

# Gasto no monetario en Regalos Otorgados deflactado
no_monetario['reda_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['reda_nm']/dINPCs02,
                           np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['reda_nm']/dINPCs03,
                            np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['reda_nm']/dINPCs04,
                                      no_monetario['reda_nm']/dINPCs05)))
```

**Se guarda la base de datos** 
```{python}
no_monetario.to_csv(current_directory + '/Output/Data/' + '/ingresonomonetario_def22.csv', index = False)
```

**Construcci贸n de la base de pagos en especie a partir de la base de gasto no monetario**  

```{python}
# Construcci贸n de la base de pagos en especie a partir de la base de gasto no monetario
pagos_especie = no_monetario[no_monetario['esp'] == 1]

pagos_especie = pagos_especie.groupby(['folioviv', 'foliohog'])[['gasto_nm', 'ali_nm', 'alta_nm', 'veca_nm', 'viv_nm',
                                       'lim_nm', 'cris_nm', 'ens_nm', 'sal_nm', 'tpub_nm', 'tfor_nm', 'com_nm', 'edre_nm',
                                       'edba_nm', 'cuip_nm', 'accp_nm', 'otr_nm', 'reda_nm']].sum(numeric_only = True)

pagos_especie = pagos_especie.reset_index()

pagos_especie.columns = ['folioviv', 'foliohog', 'gasto_nm', 'ali_nme', 'alta_nme', 'veca_nme', 'viv_nme', 'lim_nme', 
                         'cris_nme', 'ens_nme', 'sal_nme', 'tpub_nme', 'tfor_nme', 'com_nme', 'edre_nme', 'edba_nme', 
                         'cuip_nme', 'accp_nme', 'otr_nme', 'reda_nme']
```

**Se guarda la base de datos** 
```{python}
pagos_especie.to_csv(current_directory + '/Output/Data/' + '/esp_def22.csv', index = False)
```


**Construcci贸n de base de regalos a partir de la base no monetaria**  

```{python}
# Construcci贸n de base de regalos a partir de la base no monetaria
regalos = no_monetario[no_monetario['reg'] == 1]

regalos = regalos.groupby(['folioviv', 'foliohog'])[['gasto_nm', 'ali_nm', 'alta_nm', 'veca_nm', 'viv_nm', 'lim_nm', 'cris_nm',
                                                     'ens_nm', 'sal_nm', 'tpub_nm', 'tfor_nm', 'com_nm', 'edre_nm', 'edba_nm',
                                                     'cuip_nm', 'accp_nm', 'otr_nm', 'reda_nm']].sum(numeric_only = True)
regalos = regalos.reset_index()

regalos.columns = ['folioviv', 'foliohog', 'gasto_nm', 'ali_nmr', 'alta_nmr', 'veca_nmr', 'viv_nmr', 'lim_nmr', 'cris_nmr',
                   'ens_nmr', 'sal_nmr', 'tpub_nmr', 'tfor_nmr', 'com_nmr', 'edre_nmr', 'edba_nmr', 'cuip_nmr', 'accp_nmr',
                   'otr_nmr', 'reda_nmr']
```

**Se guarda la base de datos**
```{python}
regalos.to_csv(current_directory + '/Output/Data/' + '/reg_def22.csv', index = False)
```

##### Opci贸n 2 {.tabset .tabset-pills .top4-tiles}   

###### Ingresos    

Para la construcci贸n del ingreso corriente del hogar es necesario utilizar informaci贸n sobre la condici贸n de ocupaci贸n y los ingresos de los individuos.  
Se utiliza la informaci贸n contenida en la base trabajo.csv para identificar a la poblaci贸n ocupada que declara tener como prestaci贸n laboral aguinaldo, ya sea por su trabajo principal o secundario, a fin de incorporar los ingresos por este concepto en la medici贸n

Creaci贸n del ingreso monetario deflactado a pesos de agosto del 2022   

```{python}
trabajos = pd.read_csv(current_directory + "/Bases de datos/trabajos.csv", low_memory = False)
```


```{python}
def indicador_aguinaldos(trabajos):
    def convertir_a_numerico(df):
        columnas_a_convertir = ['numren', 'id_trabajo', 'pres_2']
        df[columnas_a_convertir] = df[columnas_a_convertir
                                     ].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    def generar_base_aguinaldo(df):
        df = pd.pivot_table(df, 
                            index = ['folioviv', 'foliohog', 'numren'], 
                            columns = 'id_trabajo', 
                            values = ['pres_2'], 
                            aggfunc = np.sum, 
                            fill_value = 0)
        df.columns = [f'{i}{j}' for i, j in df.columns]
        df = df.reset_index()
        
        return df 
    
    def agregar_columnas_aguinaldo(df):
        df['trab'] = 1  # Poblaci贸n con al menos un empleo 
        df['aguinaldo1'] = np.where(df.get('pres_21', 0) == 2, 1, 0)  # Aguinaldo trabajo principal
        df['aguinaldo2'] = np.where(df.get('pres_22', 0) == 2, 1, 0)  # Aguinaldo trabajo secundario
        
        return df
    
    def seleccionar_columnas_finales(df):
        columnas_finales = ['folioviv', 'foliohog', 'numren', 'aguinaldo1', 'aguinaldo2', 'trab']
        
        return df[columnas_finales]
    
    # Aplicando las funciones utilizando pipe
    return (trabajos.copy()
                    .pipe(convertir_a_numerico)
                    .pipe(generar_base_aguinaldo)
                    .pipe(agregar_columnas_aguinaldo)
                    .pipe(seleccionar_columnas_finales))
                    
aguinaldos = indicador_aguinaldos(trabajos)
```

**Se guarda la base de datos** 
```{python}
aguinaldos.to_csv(current_directory + '/Output/Data/' + 'aguinaldo22_2.csv', index = False)
```

**Ahora se incorpora a la base de ingresos**

```{python}
ingresos = pd.read_csv(current_directory + "/Bases de datos/ingresos.csv", low_memory = False)
```


Se procede a deflactar el ingreso recibido por los hogares a precios de agosto de 2022. Para ello, se utilizan las variables meses, las cuales toman los valores 2 a 10 e indican el mes en que se recibi贸 el ingreso respectivo.   

**Definici贸n de los deflactores 2022**   

```{python}
deflactores = {
    1: 0.9531433002,
    2: 0.9610510246,
    3: 0.9705661414,
    4: 0.9758164180,
    5: 0.9775368933,
    6: 0.9857919437,
    7: 0.9930938669,
    8: 1.0000000000,
    9: 1.0062034038,
    10: 1.0118979346,
    11: 1.0177217030,
    12: 1.0216069077,
    'dic21': 0.9475376203
}
```

```{python}
def indicador_ingreso_deflactado(ingresos):
    def merge_aguinaldos(df, aguinaldos):
        """Fusiona las tablas de ingresos y aguinaldos."""
        return pd.merge(df, 
                         aguinaldos, 
                          on = ['folioviv', 'foliohog', 'numren'], 
                           how = 'outer')
    
    def filtrar_aguinaldos(df):
        """Filtra las filas basadas en las condiciones de aguinaldo."""
        condicion = ~(((df['clave'] == 'P009') & (df['aguinaldo1'] != 1)) |
                      ((df['clave'] == 'P016') & (df['aguinaldo2'] != 1)))
                      
        return df[condicion]
    
    def convertir_a_numerico(df):
        """Convierte columnas espec铆ficas a tipo num茅rico."""
        columnas_a_convertir = ['mes_1', 'mes_2', 'mes_3', 'mes_4', 'mes_5', 'mes_6', 
                                'ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']
        df[columnas_a_convertir] = df[columnas_a_convertir].apply(pd.to_numeric, errors = 'coerce')
        
        return df
    
        # Funci贸n auxiliar para deflactar ingresos
    def deflactar_ingreso(df, col_ingreso, col_mes):
        def deflactar(row):
            mes = row[col_mes]
            ingreso = row[col_ingreso]
            if pd.isna(mes) or pd.isna(ingreso):
                return ingreso
            return ingreso / deflactores.get(mes, 1.0)
    
        df[col_ingreso] = df.apply(deflactar, axis = 1)
        return df

        # Funci贸n auxiliar para deflactar ingresos
        # Aplicar la funci贸n a cada columna de ingreso
    def aplicar_deflactores(df):
        ingresos_meses = [
            ('ing_6', 'mes_6'),
            ('ing_5', 'mes_5'),
            ('ing_4', 'mes_4'),
            ('ing_3', 'mes_3'),
            ('ing_2', 'mes_2'),
            ('ing_1', 'mes_1')
        ]
        
        for col_ingreso, col_mes in ingresos_meses:
            df = deflactar_ingreso(df, col_ingreso, col_mes)
    
        return df

    #def deflactar_ingreso(df, mes_col, ing_col):
    #    """Aplica los deflactores a los ingresos seg煤n el mes correspondiente."""
    #    deflactor_col = f'deflactor_{mes_col}'
    #    df[deflactor_col] = df[mes_col].map(deflactores)
    #    df[ing_col] = df[ing_col] / df[deflactor_col]
        
    #    return df.drop(columns=[deflactor_col])
    
    #def aplicar_deflactores(df):
    #    """Deflacta los ingresos para cada mes."""
    #    for i in range(1, 7):
    #        mes_col = f'mes_{i}'
    #        ing_col = f'ing_{i}'
    #        df = df.pipe(deflactar_ingreso, mes_col, ing_col)
    #        
    #    return df
    
        # Aplicando las funciones utilizando pipe
    return (ingresos.copy()
                    .pipe(merge_aguinaldos, aguinaldos)
                    .pipe(filtrar_aguinaldos)
                    .pipe(convertir_a_numerico)
                    .pipe(aplicar_deflactores)
                    )
    
ingreso_deflactado = indicador_ingreso_deflactado(ingresos)
```

Se deflactan las claves P008 y P015 (Reparto de utilidades) y P009 y P016 (aguinaldo) con los deflactores de mayo a agosto 2022 y de diciembre de 2021 a agosto 2022, respectivamente, y se obtiene el promedio mensual.  

```{python}
# Definici贸n de los deflactores 2022
deflactores = {
    'dic21': 0.9475376203, 'ene22': 0.9531433002, 'feb22': 0.9610510246,
    'mar22': 0.9705661414, 'abr22': 0.9758164180, 'may22': 0.9775368933,
    'jun22': 0.9857919437, 'jul22': 0.9930938669, 'ago22': 1.0000000000,
    'sep22': 1.0062034038, 'oct22': 1.0118979346, 'nov22': 1.0177217030,
    'dic22': 1.0216069077
}
```


```{python}
index = ['P008', 'P009', 'P015', 'P016']
```

```{python}
def indicador_ingreso_deflactado_anexoa(ingreso_deflactado):
    def deflactar_ing_1(df):
        """Aplica deflactores espec铆ficos a ing_1 seg煤n la clave."""
        df.loc[df['clave'].isin(['P008', 'P015']), 'ing_1'] = df['ing_1'] /deflactores['may22'] / 12
        df.loc[df['clave'].isin(['P009', 'P016']), 'ing_1'] = df['ing_1'] /deflactores['dic21'] / 12
      
        return df

    def poner_nulos(df):
        """Pone valores nulos en ciertas columnas si las condiciones se cumplen."""
        cols = ['ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']
        for col in cols:
            df.loc[df['clave'].isin(index) & (df[col] == 0), col] = None
            
        return df
    
    def calcular_ingreso_mensual(df):
        """Calcula el ingreso mensual promedio en los 煤ltimos seis meses."""
        df['ing_mens'] = df[['ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']].mean(axis = 1, skipna = True)
        
        return df
    
    def clasificar_ingresos(df):
        """Clasifica los ingresos en categor铆as espec铆ficas."""
        condiciones_mon = ((df['clave'].between('P001', 'P009')) |
                           (df['clave'].between('P011', 'P016')) | 
                           (df['clave'].between('P018', 'P048')) | 
                           (df['clave'].between('P067', 'P081')) | 
                           (df['clave'].between('P101', 'P108')))
        
        condiciones_lab = ((df['clave'].between('P001', 'P009')) | 
                           (df['clave'].between('P011', 'P016')) | 
                           (df['clave'].between('P018', 'P022')) | 
                           (df['clave'].between('P067', 'P081')))
        
        condiciones_ren = (df['clave'].between('P023', 'P031'))
        condiciones_tra = ((df['clave'].between('P032', 'P048')) | 
                           (df['clave'].between('P101', 'P108')))
        
        df.loc[condiciones_mon, 'ing_mon'] = df['ing_mens']
        df.loc[condiciones_lab, 'ing_lab'] = df['ing_mens']
        df.loc[condiciones_ren, 'ing_ren'] = df['ing_mens']
        df.loc[condiciones_tra, 'ing_tra'] = df['ing_mens']
        
        return df
    
    def sumar_ingresos_hogar(df):
        """Suma los ingresos por hogar."""
        df = df.groupby(['folioviv', 'foliohog'])[['ing_mon', 'ing_lab', 'ing_ren', 'ing_tra']
                                                  ].sum(numeric_only = True).reset_index()
        
        return df
      
    # Aplicando las funciones utilizando pipe
    return(ingreso_deflactado.copy()
                             .pipe(deflactar_ing_1)
                             .pipe(poner_nulos)
                             .pipe(calcular_ingreso_mensual)
                             .pipe(clasificar_ingresos)
                             .pipe(sumar_ingresos_hogar))

ingreso_deflactado = indicador_ingreso_deflactado_anexoa(ingreso_deflactado)
```

**Se guarda la base de datos** 
```{python}
ingreso_deflactado.to_csv(current_directory + '/Output/Data/' + '/ingreso_deflactado22_2.csv', index = False)
```

###### No Monetario  

En el caso de la informaci贸n de gasto no monetario, para deflactar se utiliza la decena de levantamiento de la encuesta, la cual se encuentra en la octava posici贸n del folio de la vivienda. En primer lugar se obtiene una variable que identifique la decena de levantamiento.   

Creaci贸n del ingreso no monetario deflactado a pesos de agosto del 2022.  

```{python}
gastoshogar = pd.read_csv(current_directory + "/Bases de datos/gastoshogar.csv", low_memory = False).astype(str)
gastospersona = pd.read_csv(current_directory + "/Bases de datos/gastospersona.csv", low_memory = False).astype(str)
```

**Definici贸n de los deflactores**

```{python}
# Definici贸n de los deflactores
d11w07 = 0.9869825057
d11w08 = 1.0000000000
d11w09 = 1.0130754464
d11w10 = 1.0178275200
d11w11 = 1.0207468579

# Rubro 1.2 semanal, Bebidas alcoh贸licas y tabaco		
d12w07 = 0.9923340135
d12w08 = 1.0000000000
d12w09 = 1.0035071112
d12w10 = 1.0111808568
d12w11 = 1.0131982216

# Rubro 2 trimestral, Vestido, calzado y accesorios		
d2t05 = 0.9899050815
d2t06 = 0.9941003723
d2t07 = 0.9997465345
d2t08 = 1.0083352270

# Rubro 3 mensual, viviendas		
d3m07 = 0.9998142481
d3m08 = 1.0000000000
d3m09 = 0.9978682753
d3m10 = 1.0031577830
d3m11 = 1.0197073965

# Rubro 4.2 mensual, Accesorios y art铆culos de limpieza para el hogar		
d42m07 = 0.9894769136
d42m08 = 1.0000000000
d42m09 = 1.0086286240
d42m10 = 1.0182083142
d42m11 = 1.0237613131

# Rubro 4.2 trimestral, Accesorios y art铆culos de limpieza para el hogar		
d42t05 = 0.9787953163
d42t06 = 0.9897197934
d42t07 = 0.9993685126
d42t08 = 1.0089456461

# Rubro 4.1 semestral, Muebles y aparatos d贸mesticos		
d41s02 = 1.0003069312
d41s03 = 0.9993861376
d41s04 = 0.9992122603
d41s05 = 0.9991442214

# Rubro 5.1 trimestral, Salud		
d51t05 = 0.9909917367
d51t06 = 0.9954834527
d51t07 = 0.9994564693
d51t08 = 1.0030487384

# Rubro 6.1.1 semanal, Transporte p煤blico urbano		
d611w07 = 0.9963207274
d611w08 = 1.0000000000
d611w09 = 1.0034865488
d611w10 = 1.0052385833
d611w11 = 1.0064912880

# Rubro 6 mensual, Transporte		
d6m07 = 0.9987845893
d6m08 = 1.0000000000
d6m09 = 1.0001664946
d6m10 = 1.0057274150
d6m11 = 1.0076837268

# Rubro 6 semestral, Transporte		
d6s02 = 0.9808628306
d6s03 = 0.9879901879
d6s04 = 0.9927380596
d6s05 = 0.9969378864

# Rubro 7 mensual, Educaci贸n y esparcimiento		
d7m07 = 0.9961413091
d7m08 = 1.0000000000
d7m09 = 1.0095233900
d7m10 = 1.0144128271
d7m11 = 1.0174522069

# Rubro 2.3 mensual, Accesorios y cuidados del vestido		
d23m07 = 0.9952443607
d23m08 = 1.0000000000
d23m09 = 1.0081869233
d23m10 = 1.0108184343
d23m11 = 1.0072323555

# Rubro 2.3 trimestral,  Accesorios y cuidados del vestido		
d23t05 = 0.9914948875
d23t06 = 0.9956428139
d23t07 = 1.0011437613
d23t08 = 1.0063351192

# INPC semestral		
dINPCs02 = 0.9773093813
dINPCs03 = 0.9838008772
dINPCs04 = 0.9897404209
dINPCs05 = 0.9957540070
```


Se cambia la estructura de los deflactores del c贸digo anterior para reducir el c谩lculo como el chunk de la  `Opci贸n 1`.
Se seleccionan los deflactores que solamente pertencen al c谩lculo de los rubros:    

```{python}
# Definici贸n de los deflactores
deflactores = {
    'ali_nm': [1.0000000000, 1.0130754464, 1.0178275200, 1.0207468579],
    'alta_nm': [1.0000000000, 1.0035071112, 1.0111808568, 1.0131982216],
    'veca_nm': [0.9899050815, 0.9941003723, 0.9997465345, 1.0083352270],
    'viv_nm': [0.9998142481, 1.0000000000, 0.9978682753, 1.0031577830],
    'lim_nm': [0.9894769136, 1.0000000000, 1.0086286240, 1.0182083142],
    'cris_nm': [0.9787953163, 0.9897197934, 0.9993685126, 1.0089456461],
    'ens_nm': [1.0003069312, 0.9993861376, 0.9992122603, 0.9991442214],
    'sal_nm': [0.9909917367, 0.9954834527, 0.9994564693, 1.0030487384],
    'tpub_nm': [1.0000000000, 1.0034865488, 1.0052385833, 1.0064912880],
    'tfor_nm': [0.9808628306, 0.9879901879, 0.9927380596, 0.9969378864],
    'com_nm': [0.9987845893, 1.0000000000, 1.0001664946, 1.0057274150],
    'edre_nm': [0.9961413091, 1.0000000000, 1.0095233900, 1.0144128271],
    'edba_nm': [0.9961413091, 1.0000000000, 1.0095233900, 1.0144128271],
    'cuip_nm': [0.9952443607, 1.0000000000, 1.0081869233, 1.0108184343],
    'accp_nm': [0.9914948875, 0.9956428139, 1.0011437613, 1.0063351192],
    'otr_nm': [0.9773093813, 0.9838008772, 0.9897404209, 0.9957540070],
    'reda_nm': [0.9773093813, 0.9838008772, 0.9897404209, 0.9957540070]
}
deflactores.keys()
```


```{python}
def indicador_no_monetario(gastoshogar):
    # Definir funciones auxiliares
    def merge_gastopersonas(df):
        df['base'] = 1
        df = pd.concat([df, gastospersona], ignore_index = True)
        return df
    
    def establecer_base_frecuencia(df):
        df.loc[df['base'].isna(), 'base'] = 2
        df.loc[df['base'] == 2, 'frecuencia'] = df['frec_rem']
        
        return df
    
    def definir_decena(df):
        df['decena'] = df['folioviv'].astype(str).str.zfill(10).str[7]
        
        return df
    
    def convertir_variables(df):
        df[['gas_nm_tri', 'gasto_nm']] = df[['gas_nm_tri', 'gasto_nm']].apply(pd.to_numeric, errors = 'coerce')
        
        return df
    
    def seleccionar_rubros(df):
        df['gasnomon'] = df['gas_nm_tri'] / 3
        df.loc[df['tipo_gasto'] == 'G4', 'esp'] = 1
        df.loc[df['tipo_gasto'].isin(['G5', 'G6']), 'reg'] = 1
        df = df.loc[~df['tipo_gasto'].isin(['G2', 'G3', 'G7'])]
        
        return df
    
    def controlar_frecuencia_regalos(df):
        df = df[~(((df['frecuencia'].between('5', '6')) |
                   (df['frecuencia'].isna()) |
                    (df['frecuencia'] == '0')) &
                     (df['base'] == 1) &
                      (df['tipo_gasto'] == 'G5'))]
    
        df = df[~(((df['frecuencia'] == '9') |
                   (df['frecuencia'].isna())) &
                    (df['base'] == 2) &
                     (df['tipo_gasto'] == 'G5'))]
        return df
    
    def deflactar_rubros(df):
        rubros = [
            ('A001', 'A222', 'ali_nm'),
            ('A242', 'A247', 'ali_nm'),
            ('A223', 'A241', 'alta_nm'),
            ('H001', 'H122', 'veca_nm'),
            ('H136', 'H136', 'veca_nm'),
            ('G001', 'G016', 'viv_nm'),
            ('R001', 'R004', 'viv_nm'),
            ('R013', 'R013', 'viv_nm'),
            ('C001', 'C024', 'lim_nm'),
            ('I001', 'I026', 'cris_nm'),
            ('K001', 'K037', 'ens_nm'),
            ('J001', 'J072', 'sal_nm'),
            ('B001', 'B007', 'tpub_nm'),
            ('M001', 'M018', 'tfor_nm'),
            ('F007', 'F014', 'tfor_nm'),
            ('F001', 'F006', 'com_nm'),
            ('R005', 'R008', 'com_nm'),
            ('R010', 'R011', 'com_nm'),
            ('E001', 'E034', 'edre_nm'),
            ('H134', 'H135', 'edre_nm'),
            ('L001', 'L029', 'edre_nm'),
            ('N003', 'N005', 'edre_nm'),
            ('R009', 'R009', 'edre_nm'),
            ('E002', 'E003', 'edba_nm'),
            ('H134', 'H135', 'edba_nm'),
            ('D001', 'D026', 'cuip_nm'),
            ('H132', 'H132', 'cuip_nm'),
            ('H123', 'H131', 'accp_nm'),
            ('H133', 'H133', 'accp_nm'),
            ('N001', 'N002', 'otr_nm'),
            ('N006', 'N016', 'otr_nm'),
            ('T901', 'T915', 'otr_nm'),
            ('R012', 'R012', 'otr_nm'),
            ('N013', 'N013', 'reda_nm')
        ]
    
        for inicio, fin, columna in rubros:
            df.loc[df['clave'].between(inicio, fin), columna] = df['gasnomon']
        
        return df

        # Funci贸n auxiliar para deflactar seg煤n los deflactores y la decena
    def deflactar(df, col_name, deflactores):
        deflact_values = deflactores[col_name]
        if len(deflact_values) == 4:
            conditions = [
                df['decena'].isin(['1', '2']),
                df['decena'].isin(['3', '4', '5']),
                df['decena'].isin(['6', '7', '8']),
                df['decena'].isin(['9', '10', '11', '0'])
            ]
        else:
            conditions = [
                df['decena'].isin(['1', '2', '3']),
                df['decena'].isin(['4', '5', '6']),
                df['decena'].isin(['7', '8', '9']),
                df['decena'].isin(['10', '11', '12', '0'])
            ]
    
        return np.select(conditions, deflact_values, default = df[col_name])

        # Aplicar deflactores utilizando pipe
    def aplicar_deflactores(df):
        for col_name in deflactores.keys():
            df[col_name] = deflactar(df, col_name, deflactores)
        
        return df
    
    # Aplicar funciones utilizando pipe
    return (gastoshogar.copy()
                       .pipe(merge_gastopersonas)
                       .pipe(establecer_base_frecuencia)
                       .pipe(definir_decena)
                       .pipe(convertir_variables)
                       .pipe(seleccionar_rubros)
                       .pipe(controlar_frecuencia_regalos)
                       .pipe(deflactar_rubros)
                       .pipe(aplicar_deflactores))
                  
no_monetario = indicador_no_monetario(gastoshogar)
```

**Se guarda la base de datos** 
```{python}
no_monetario.to_csv(current_directory + '/Output/Data/' + '/ingresonomonetario_def22_2.csv', index = False)
```

**Construcci贸n de la base de pagos en especie a partir de la base de gasto no monetario**  

```{python}
def indicador_pagos_especie(no_monetario):
    # Funci贸n para filtrar pagos en especie
    def filtrar_pagos_especie(df):
        return df[df['esp'] == 1]

    # Funci贸n para agrupar y sumar gastos no monetarios
    def agrupar_y_sumar(df):
        columnas_gasto = ['gasto_nm', 'ali_nm', 'alta_nm', 'veca_nm', 'viv_nm', 'lim_nm', 'cris_nm', 'ens_nm', 
                          'sal_nm', 'tpub_nm', 'tfor_nm', 'com_nm', 'edre_nm', 'edba_nm', 'cuip_nm', 'accp_nm', 
                          'otr_nm', 'reda_nm']
        df_agrupado = df.groupby(['folioviv', 'foliohog'])[columnas_gasto
                                                          ].sum(numeric_only = True).reset_index()
        return df_agrupado
  
    # Funci贸n para renombrar las columnas
    def renombrar_columnas(df):
        nuevas_columnas = ['folioviv', 'foliohog', 'gasto_nm', 'ali_nme', 'alta_nme', 'veca_nme', 'viv_nme', 'lim_nme', 
                           'cris_nme', 'ens_nme', 'sal_nme', 'tpub_nme', 'tfor_nme', 'com_nme', 'edre_nme', 'edba_nme', 
                           'cuip_nme', 'accp_nme', 'otr_nme', 'reda_nme']
        df.columns = nuevas_columnas
        return df

    # Construcci贸n de la base de pagos en especie utilizando pipe
    return (no_monetario.copy()
                        .pipe(filtrar_pagos_especie)
                        .pipe(agrupar_y_sumar)
                        .pipe(renombrar_columnas))

pagos_especie = indicador_pagos_especie(no_monetario)
```

**Se guarda la base de datos** 
```{python}
pagos_especie.to_csv(current_directory + '/Output/Data/' + '/esp_def22_2.csv', index = False)
```


**Construcci贸n de base de regalos a partir de la base no monetaria**  

```{python}
# Construcci贸n de base de regalos a partir de la base no monetaria
regalos = no_monetario[no_monetario['reg'] == 1]

regalos = regalos.groupby(['folioviv', 'foliohog'])[['gasto_nm', 'ali_nm', 'alta_nm', 'veca_nm', 'viv_nm', 'lim_nm', 'cris_nm',
                                                     'ens_nm', 'sal_nm', 'tpub_nm', 'tfor_nm', 'com_nm', 'edre_nm', 'edba_nm',
                                                     'cuip_nm', 'accp_nm', 'otr_nm', 'reda_nm']].sum(numeric_only = True)
regalos = regalos.reset_index()

regalos.columns = ['folioviv', 'foliohog', 'gasto_nm', 'ali_nmr', 'alta_nmr', 'veca_nmr', 'viv_nmr', 'lim_nmr', 'cris_nmr',
                   'ens_nmr', 'sal_nmr', 'tpub_nmr', 'tfor_nmr', 'com_nmr', 'edre_nmr', 'edba_nmr', 'cuip_nmr', 'accp_nmr',
                   'otr_nmr', 'reda_nmr']
```

**Se guarda la base de datos**
```{python}
regalos.to_csv(current_directory + '/Output/Data/' + '/reg_def22.csv', index = False)
```



### Construcci贸n del ingreso corriente total   {.tabset .tabset-pills .top2-tiles} 

#### Ingreso corriente total {.tabset .tabset-pills .top3-tiles}

##### Opci贸n 1  

```{python}
concentradohogar = pd.read_csv(current_directory + "/Bases de datos/concentradohogar.csv", low_memory = False)
ingreso_deflactado = pd.read_csv(current_directory + '/Output/Data/' + '/ingreso_deflactado22.csv', low_memory = False)
pagos_especie = pd.read_csv(current_directory + '/Output/Data/' + '/esp_def22.csv', low_memory = False)
regalos = pd.read_csv(current_directory + '/Output/Data/' + '/reg_def22.csv', low_memory = False)
```

```{python}
ingreso_corriente = concentradohogar[['folioviv', 'foliohog', 'tam_loc', 'factor', 'tot_integ', 'est_dis', 'upm', 'ubica_geo']]

# Incorporaci贸n de la base de ingreso monetario deflactado
ingreso_corriente = pd.merge(ingreso_corriente, 
                              ingreso_deflactado, 
                               on = ['folioviv', 'foliohog'], 
                                how = 'left')

# Incorporaci贸n de la base de ingreso no monetario deflactado: pago en especie
ingreso_corriente = pd.merge(ingreso_corriente,
                              pagos_especie, 
                               on = ['folioviv', 'foliohog'], 
                                how = 'left')

# Incorporaci贸n de la base de ingreso no monetario deflactado: regalos en especie
ingreso_corriente = pd.merge(ingreso_corriente, 
                              regalos,
                               on = ['folioviv', 'foliohog'], 
                                how = 'left')

ingreso_corriente.loc[ingreso_corriente['tam_loc'] == 4, 'rururb'] = 1 # Rural
ingreso_corriente.loc[ingreso_corriente['tam_loc'] <= 3, 'rururb'] = 0 # Urbano

# Ingreso corriente no monetario pago especie
ingreso_corriente['pago_esp'] = ingreso_corriente[['ali_nme', 'alta_nme', 'veca_nme', 'viv_nme', 'lim_nme', 'cris_nme', 'ens_nme', 'sal_nme',
                                                   'tpub_nme', 'tfor_nme', 'com_nme', 'edre_nme', 'cuip_nme', 'accp_nme', 'otr_nme']
                                                  ].sum(axis = 1)

# Ingreso corriente no monetario regalos especie
ingreso_corriente['reg_esp'] = ingreso_corriente[['ali_nmr', 'alta_nmr', 'veca_nmr', 'viv_nmr', 'lim_nmr', 'cris_nmr', 'ens_nmr', 'sal_nmr',
                                                  'tpub_nmr', 'tfor_nmr', 'com_nmr', 'edre_nmr', 'cuip_nmr', 'accp_nmr', 'otr_nmr']
                                                  ].sum(axis = 1)

# Ingreso corriente no monetario
ingreso_corriente['nomon'] = ingreso_corriente[['pago_esp', 'reg_esp']].sum(axis = 1)

# Se construye el Ingreso Corriente Total con el ingreso monetario y el ingreso no monetario 
ingreso_corriente['ict'] = ingreso_corriente[['ing_mon', 'nomon']].sum(axis = 1)

ingreso_corriente = ingreso_corriente[['folioviv', 'foliohog', 'ubica_geo', 'tam_loc', 'est_dis', 'upm', 'factor', 'tot_integ', 'ing_mon',
                                       'ing_lab', 'ing_ren', 'ing_tra', 'ali_nme', 'alta_nme', 'veca_nme', 'viv_nme', 'lim_nme', 'cris_nme',
                                       'ens_nme', 'sal_nme', 'tpub_nme', 'tfor_nme', 'com_nme', 'edre_nme', 'edba_nme', 'cuip_nme', 'accp_nme',
                                       'otr_nme', 'reda_nme', 'ali_nmr', 'alta_nmr', 'veca_nmr', 'viv_nmr', 'lim_nmr', 'cris_nmr', 'ens_nmr',
                                       'sal_nmr', 'tpub_nmr', 'tfor_nmr', 'com_nmr', 'edre_nmr', 'edba_nmr', 'cuip_nmr', 'accp_nmr', 'otr_nmr',
                                       'reda_nmr', 'rururb', 'pago_esp', 'reg_esp', 'nomon', 'ict']]
```

**Se guarda la base de datos**
```{python}
ingreso_corriente.to_csv(current_directory + '/Output/Data/' + '/ingresotot22.csv', index = False)
```

##### Opci贸n 2  

```{python}
concentradohogar = pd.read_csv(current_directory + "/Bases de datos/concentradohogar.csv", low_memory = False)
ingreso_deflactado = pd.read_csv(current_directory + '/Output/Data/' + '/ingreso_deflactado22.csv', low_memory = False)
pagos_especie = pd.read_csv(current_directory + '/Output/Data/' + '/esp_def22.csv', low_memory = False)
regalos = pd.read_csv(current_directory + '/Output/Data/' + '/reg_def22.csv', low_memory = False)
```

```{python}
ingreso_corriente = concentradohogar[['folioviv', 'foliohog', 'tam_loc', 'factor', 'tot_integ', 'est_dis', 'upm', 'ubica_geo']]

# Incorporaci贸n de la base de ingreso monetario deflactado
ingreso_corriente = pd.merge(ingreso_corriente, 
                              ingreso_deflactado, 
                               on = ['folioviv', 'foliohog'], 
                                how = 'left')

# Incorporaci贸n de la base de ingreso no monetario deflactado: pago en especie
ingreso_corriente = pd.merge(ingreso_corriente,
                              pagos_especie, 
                               on = ['folioviv', 'foliohog'], 
                                how = 'left')

# Incorporaci贸n de la base de ingreso no monetario deflactado: regalos en especie
ingreso_corriente = pd.merge(ingreso_corriente, 
                              regalos,
                               on = ['folioviv', 'foliohog'], 
                                how = 'left')

ingreso_corriente.loc[ingreso_corriente['tam_loc'] == 4, 'rururb'] = 1 # Rural
ingreso_corriente.loc[ingreso_corriente['tam_loc'] <= 3, 'rururb'] = 0 # Urbano

# Ingreso corriente no monetario pago especie
ingreso_corriente['pago_esp'] = ingreso_corriente[['ali_nme', 'alta_nme', 'veca_nme', 'viv_nme', 'lim_nme', 'cris_nme', 'ens_nme', 'sal_nme',
                                                   'tpub_nme', 'tfor_nme', 'com_nme', 'edre_nme', 'cuip_nme', 'accp_nme', 'otr_nme']
                                                  ].sum(axis = 1)

# Ingreso corriente no monetario regalos especie
ingreso_corriente['reg_esp'] = ingreso_corriente[['ali_nmr', 'alta_nmr', 'veca_nmr', 'viv_nmr', 'lim_nmr', 'cris_nmr', 'ens_nmr', 'sal_nmr',
                                                  'tpub_nmr', 'tfor_nmr', 'com_nmr', 'edre_nmr', 'cuip_nmr', 'accp_nmr', 'otr_nmr']
                                                  ].sum(axis = 1)

# Ingreso corriente no monetario
ingreso_corriente['nomon'] = ingreso_corriente[['pago_esp', 'reg_esp']].sum(axis = 1)

# Se construye el Ingreso Corriente Total con el ingreso monetario y el ingreso no monetario 
ingreso_corriente['ict'] = ingreso_corriente[['ing_mon', 'nomon']].sum(axis = 1)

ingreso_corriente = ingreso_corriente[['folioviv', 'foliohog', 'ubica_geo', 'tam_loc', 'est_dis', 'upm', 'factor', 'tot_integ', 'ing_mon',
                                       'ing_lab', 'ing_ren', 'ing_tra', 'ali_nme', 'alta_nme', 'veca_nme', 'viv_nme', 'lim_nme', 'cris_nme',
                                       'ens_nme', 'sal_nme', 'tpub_nme', 'tfor_nme', 'com_nme', 'edre_nme', 'edba_nme', 'cuip_nme', 'accp_nme',
                                       'otr_nme', 'reda_nme', 'ali_nmr', 'alta_nmr', 'veca_nmr', 'viv_nmr', 'lim_nmr', 'cris_nmr', 'ens_nmr',
                                       'sal_nmr', 'tpub_nmr', 'tfor_nmr', 'com_nmr', 'edre_nmr', 'edba_nmr', 'cuip_nmr', 'accp_nmr', 'otr_nmr',
                                       'reda_nmr', 'rururb', 'pago_esp', 'reg_esp', 'nomon', 'ict']]
```

**Se guarda la base de datos**
```{python}
ingreso_corriente.to_csv(current_directory + '/Output/Data/' + '/ingresotot22.csv', index = False)
```

#### Construcci贸n del tama帽o de hogar con econom铆as de escala y escalas de equivalencia {.tabset .tabset-pills .top2-tiles}  

##### Opci贸n 1 {.tabset .tabset-pills .top3-tiles}  

```{python}
tam_hogar_escala = poblacion.copy()

# Poblaci贸n objetivo: no se incluye a hu茅spedes ni trabajadores dom茅sticos
tam_hogar_escala = tam_hogar_escala.loc[~((tam_hogar_escala['parentesco'] >= 400) & (tam_hogar_escala['parentesco'] < 500) |
                                          (tam_hogar_escala['parentesco'] >= 700) & (tam_hogar_escala['parentesco'] < 800))]

# Total de integrantes del hogar
tam_hogar_escala['ind'] = 1

tam_hogar_escala['tot_ind'] = tam_hogar_escala.groupby(['folioviv', 'foliohog'])['ind'].transform('sum')

# Escalas de equivalencia 
tam_hogar_escala.loc[(tam_hogar_escala['edad'] >= 0) & (tam_hogar_escala['edad'] <= 5), 'n_05'] = 1
tam_hogar_escala.loc[(tam_hogar_escala['edad'] < 0) | (tam_hogar_escala['edad'] > 5), 'n_05'] = 0

tam_hogar_escala.loc[(tam_hogar_escala['edad'] >= 6) & (tam_hogar_escala['edad'] <= 12), 'n_6_12'] = 1
tam_hogar_escala.loc[(tam_hogar_escala['edad'] < 6) | (tam_hogar_escala['edad'] > 12), 'n_6_12'] = 0

tam_hogar_escala.loc[(tam_hogar_escala['edad'] >= 13) & (tam_hogar_escala['edad'] <= 18), 'n_13_18'] = 1
tam_hogar_escala.loc[(tam_hogar_escala['edad'] < 13) | (tam_hogar_escala['edad'] > 18), 'n_13_18'] = 0

tam_hogar_escala.loc[(tam_hogar_escala['edad'] >= 19), 'n_19'] = 1
tam_hogar_escala.loc[(tam_hogar_escala['edad'] < 19), 'n_19'] = 0

tam_hogar_escala.loc[tam_hogar_escala['n_05'] == 1, 'tamhogesc'] = tam_hogar_escala['n_05'] * .7031
tam_hogar_escala.loc[tam_hogar_escala['n_6_12'] == 1, 'tamhogesc'] = tam_hogar_escala['n_6_12'] * .7382
tam_hogar_escala.loc[tam_hogar_escala['n_13_18'] == 1, 'tamhogesc'] = tam_hogar_escala['n_13_18'] * .7057
tam_hogar_escala.loc[tam_hogar_escala['n_19'] == 1, 'tamhogesc'] = tam_hogar_escala['n_19'] * .9945
tam_hogar_escala.loc[tam_hogar_escala['tot_ind'] == 1, 'tamhogesc'] = 1

tam_hogar_escala = tam_hogar_escala.groupby(['folioviv', 'foliohog'])['tamhogesc'].sum().reset_index()
```

**Se guarda la base de datos**
```{python}
tam_hogar_escala.to_csv(current_directory + '/Output/Data/' + '/tamhogesc22.csv', index = False)
```

##### Opci贸n 2 {.tabset .tabset-pills .top3-tiles}  

```{python}
tam_hogar_escala = poblacion.copy()

# Poblaci贸n objetivo: no se incluye a hu茅spedes ni trabajadores dom茅sticos
tam_hogar_escala = tam_hogar_escala.loc[~((tam_hogar_escala['parentesco'] >= 400) & (tam_hogar_escala['parentesco'] < 500) |
                                          (tam_hogar_escala['parentesco'] >= 700) & (tam_hogar_escala['parentesco'] < 800))]

# Total de integrantes del hogar
tam_hogar_escala['ind'] = 1

tam_hogar_escala['tot_ind'] = tam_hogar_escala.groupby(['folioviv', 'foliohog'])['ind'].transform('sum')

# Escalas de equivalencia 
tam_hogar_escala.loc[(tam_hogar_escala['edad'] >= 0) & (tam_hogar_escala['edad'] <= 5), 'n_05'] = 1
tam_hogar_escala.loc[(tam_hogar_escala['edad'] < 0) | (tam_hogar_escala['edad'] > 5), 'n_05'] = 0

tam_hogar_escala.loc[(tam_hogar_escala['edad'] >= 6) & (tam_hogar_escala['edad'] <= 12), 'n_6_12'] = 1
tam_hogar_escala.loc[(tam_hogar_escala['edad'] < 6) | (tam_hogar_escala['edad'] > 12), 'n_6_12'] = 0

tam_hogar_escala.loc[(tam_hogar_escala['edad'] >= 13) & (tam_hogar_escala['edad'] <= 18), 'n_13_18'] = 1
tam_hogar_escala.loc[(tam_hogar_escala['edad'] < 13) | (tam_hogar_escala['edad'] > 18), 'n_13_18'] = 0

tam_hogar_escala.loc[(tam_hogar_escala['edad'] >= 19), 'n_19'] = 1
tam_hogar_escala.loc[(tam_hogar_escala['edad'] < 19), 'n_19'] = 0

tam_hogar_escala.loc[tam_hogar_escala['n_05'] == 1, 'tamhogesc'] = tam_hogar_escala['n_05'] * .7031
tam_hogar_escala.loc[tam_hogar_escala['n_6_12'] == 1, 'tamhogesc'] = tam_hogar_escala['n_6_12'] * .7382
tam_hogar_escala.loc[tam_hogar_escala['n_13_18'] == 1, 'tamhogesc'] = tam_hogar_escala['n_13_18'] * .7057
tam_hogar_escala.loc[tam_hogar_escala['n_19'] == 1, 'tamhogesc'] = tam_hogar_escala['n_19'] * .9945
tam_hogar_escala.loc[tam_hogar_escala['tot_ind'] == 1, 'tamhogesc'] = 1

tam_hogar_escala = tam_hogar_escala.groupby(['folioviv', 'foliohog'])['tamhogesc'].sum().reset_index()
```

**Se guarda la base de datos**
```{python}
tam_hogar_escala.to_csv(current_directory + '/Output/Data/' + '/tamhogesc22.csv', index = False)
```

#### Bienestar econ贸mico {.tabset .tabset-pills .top2-tiles}  

##### Opci贸n 1 {.tabset .tabset-pills .top3-tiles}  

Incorporaci贸n de la informaci贸n sobre el tama帽o del hogar ajustado

```{python}
ingreso_corriente = pd.read_csv(current_directory + '/Output/Data/' + '/ingresotot22.csv', low_memory = False)
tam_hogar_escala = pd.read_csv(current_directory + '/Output/Data/' + '/tamhogesc22.csv', low_memory = False)
```

**Indicadores de Bienestar econ贸mico**    

`LP I`: Valor de la Canasta alimentaria   
`LP II`: Valor monetario de la canasta alimentaria m谩s el valor monetario de la canasta no alimentaria (ver Anexo A del documento metodol贸gico).    

En este programa se construyen los indicadores de bienestar econ贸mico mediante las 2 l铆neas definidas por CONEVAL, denomin谩ndolas:   
  
`lp1` : L铆nea de Pobreza Extrema por Ingresos (`LPEI`)   
`lp2` : L铆nea de Pobreza por Ingresos (`LPI`)    

Para m谩s informaci贸n, se sugiere consultar el documento metodol贸gico de Construcci贸n de las l铆neas de pobreza por ingresos. Disponible en: https://www.coneval.org.mx/InformesPublicaciones/InformesPublicaciones/Documents/Lineas_pobreza.pdf     

```{python}
#L铆nea de pobreza extrema por ingresos (LPEI)
# Valor monetario de la canasta alimentaria
lp1_urb = 2086.21
lp1_rur = 1600.18

# L铆nea de pobreza por ingresos (LPI)
# Valor monetario de la canasta alimentaria m谩s el valor monetario de la canasta no alimentaria
lp2_urb = 4158.35
lp2_rur = 2970.76
```


```{python}
# Incorporaci贸n de la informaci贸n sobre el tama帽o del hogar ajustado
p_ingreso = pd.merge(ingreso_corriente, 
                      tam_hogar_escala, 
                       on = ['folioviv', 'foliohog'], 
                        how = 'left')

# Informaci贸n per c谩pita
p_ingreso['ictpc'] = p_ingreso['ict'] / p_ingreso['tamhogesc']     

# Se identifica a los hogares bajo lp1
p_ingreso.loc[(p_ingreso['ictpc'] < lp1_urb) & (p_ingreso['rururb'] == 0), 'plp_e'] = 1
p_ingreso.loc[(p_ingreso['ictpc'] >= lp1_urb) & (p_ingreso['rururb'] == 0), 'plp_e'] = 0
p_ingreso.loc[(p_ingreso['ictpc'] < lp1_rur) & (p_ingreso['rururb'] == 1), 'plp_e'] = 1
p_ingreso.loc[(p_ingreso['ictpc'] >= lp1_rur) & (p_ingreso['rururb'] == 1), 'plp_e'] = 0

# Se identifica a los hogares bajo lp2
p_ingreso.loc[(p_ingreso['ictpc'] < lp2_urb) & (p_ingreso['rururb'] == 0), 'plp'] = 1
p_ingreso.loc[(p_ingreso['ictpc'] >= lp2_urb) & (p_ingreso['rururb'] == 0), 'plp'] = 0
p_ingreso.loc[(p_ingreso['ictpc'] < lp2_rur) & (p_ingreso['rururb'] == 1), 'plp'] = 1
p_ingreso.loc[(p_ingreso['ictpc'] >= lp2_rur) & (p_ingreso['rururb'] == 1), 'plp'] = 0

p_ingreso = p_ingreso[['folioviv', 'foliohog', 'factor', 'tam_loc', 'rururb', 'tamhogesc', 'ict', 'ictpc',
                       'plp_e', 'plp', 'est_dis', 'upm', 'ubica_geo', 'tot_integ', 'ing_mon', 'ing_lab', 'ing_ren',
                       'ing_tra', 'nomon', 'pago_esp', 'reg_esp']]
```


**Se guarda la base de datos**
```{python}
p_ingreso.to_csv(current_directory + '/Output/Data/' + '/p_ingresos22.csv', index = False)
```


##### Opci贸n 2 {.tabset .tabset-pills .top3-tiles}  

Incorporaci贸n de la informaci贸n sobre el tama帽o del hogar ajustado

```{python}
ingreso_corriente = pd.read_csv(current_directory + '/Output/Data/' + '/ingresotot22.csv', low_memory = False)
tam_hogar_escala = pd.read_csv(current_directory + '/Output/Data/' + '/tamhogesc22.csv', low_memory = False)
```

**Indicadores de Bienestar econ贸mico**    

`LP I`: Valor de la Canasta alimentaria   
`LP II`: Valor monetario de la canasta alimentaria m谩s el valor monetario de la canasta no alimentaria (ver Anexo A del documento metodol贸gico).    

En este programa se construyen los indicadores de bienestar econ贸mico mediante las 2 l铆neas definidas por CONEVAL, denomin谩ndolas:   
  
`lp1` : L铆nea de Pobreza Extrema por Ingresos (`LPEI`)   
`lp2` : L铆nea de Pobreza por Ingresos (`LPI`)    

Para m谩s informaci贸n, se sugiere consultar el documento metodol贸gico de Construcci贸n de las l铆neas de pobreza por ingresos. Disponible en: https://www.coneval.org.mx/InformesPublicaciones/InformesPublicaciones/Documents/Lineas_pobreza.pdf     

```{python}
#L铆nea de pobreza extrema por ingresos (LPEI)
# Valor monetario de la canasta alimentaria
lp1_urb = 2086.21
lp1_rur = 1600.18

# L铆nea de pobreza por ingresos (LPI)
# Valor monetario de la canasta alimentaria m谩s el valor monetario de la canasta no alimentaria
lp2_urb = 4158.35
lp2_rur = 2970.76
```


```{python}
# Incorporaci贸n de la informaci贸n sobre el tama帽o del hogar ajustado
p_ingreso = pd.merge(ingreso_corriente, 
                      tam_hogar_escala, 
                       on = ['folioviv', 'foliohog'], 
                        how = 'left')

# Informaci贸n per c谩pita
p_ingreso['ictpc'] = p_ingreso['ict'] / p_ingreso['tamhogesc']     

# Se identifica a los hogares bajo lp1
p_ingreso.loc[(p_ingreso['ictpc'] < lp1_urb) & (p_ingreso['rururb'] == 0), 'plp_e'] = 1
p_ingreso.loc[(p_ingreso['ictpc'] >= lp1_urb) & (p_ingreso['rururb'] == 0), 'plp_e'] = 0
p_ingreso.loc[(p_ingreso['ictpc'] < lp1_rur) & (p_ingreso['rururb'] == 1), 'plp_e'] = 1
p_ingreso.loc[(p_ingreso['ictpc'] >= lp1_rur) & (p_ingreso['rururb'] == 1), 'plp_e'] = 0

# Se identifica a los hogares bajo lp2
p_ingreso.loc[(p_ingreso['ictpc'] < lp2_urb) & (p_ingreso['rururb'] == 0), 'plp'] = 1
p_ingreso.loc[(p_ingreso['ictpc'] >= lp2_urb) & (p_ingreso['rururb'] == 0), 'plp'] = 0
p_ingreso.loc[(p_ingreso['ictpc'] < lp2_rur) & (p_ingreso['rururb'] == 1), 'plp'] = 1
p_ingreso.loc[(p_ingreso['ictpc'] >= lp2_rur) & (p_ingreso['rururb'] == 1), 'plp'] = 0

p_ingreso = p_ingreso[['folioviv', 'foliohog', 'factor', 'tam_loc', 'rururb', 'tamhogesc', 'ict', 'ictpc',
                       'plp_e', 'plp', 'est_dis', 'upm', 'ubica_geo', 'tot_integ', 'ing_mon', 'ing_lab', 'ing_ren',
                       'ing_tra', 'nomon', 'pago_esp', 'reg_esp']]
```


**Se guarda la base de datos**
```{python}
p_ingreso.to_csv(current_directory + '/Output/Data/' + '/p_ingresos22.csv', index = False)
```

## Pobreza multidimensional  {.tabset .tabset-pills .top3-tiles} 

### Integraci贸n de las bases  

**Se vuelven a cargar las bases de datos**  

```{python}
# Rezago eductivo 
rezago_educativo = pd.read_csv(current_directory + '/Output/Data/' + '/ic_rezedu22.csv', low_memory = False)
# Carencia por acceso a los servicios de salud
salud = pd.read_csv(current_directory + '/Output/Data/' + '/ic_asalud22.csv', low_memory = False)
# Carencia por acceso a la seguridad social
seguridad_social = pd.read_csv(current_directory + '/Output/Data/' + '/ic_segsoc22.csv', low_memory = False)
# Carencia por calidad y espacios de la vivienda
calidad_viviendas = pd.read_csv(current_directory + '/Output/Data/' + '/ic_cev22.csv', low_memory = False)
# Carencia por acceso a los servicios b谩sicos de la vivienda
servicios_basicos = pd.read_csv(current_directory + '/Output/Data/' + '/ic_sbv22.csv', low_memory = False)
# Carencia por acceso a la alimentaci贸n nutritiva y de calidad 
alimentacion = pd.read_csv(current_directory + '/Output/Data/' + '/ic_ali22.csv', low_memory = False)
# L铆nea de pobreza por ingresos (LPI)
p_ingreso = pd.read_csv(current_directory + '/Output/Data/' + '/p_ingresos22.csv', low_memory = False)
```


#### Opci贸n 1 {.tabset .tabset-pills .top4-tiles}  

Se integran las seis bases de datos.  

```{python}
pobreza = pd.merge(rezago_educativo, 
                    salud, 
                     on = ['folioviv', 'foliohog', 'numren'], 
                      how = 'left')
pobreza = pd.merge(pobreza, 
                    seguridad_social, 
                     on = ['folioviv', 'foliohog', 'numren'], 
                      how = 'left')
pobreza = pd.merge(pobreza, 
                    calidad_viviendas, 
                     on = ['folioviv', 'foliohog'], 
                      how = 'left')
pobreza = pd.merge(pobreza, 
                    servicios_basicos, 
                     on = ['folioviv', 'foliohog'], 
                      how = 'left')
pobreza = pd.merge(pobreza, 
                    alimentacion, 
                     on = ['folioviv', 'foliohog'], 
                      how = 'left')
pobreza = pd.merge(pobreza, 
                    p_ingreso, 
                     on = ['folioviv', 'foliohog'], 
                      how = 'left')

pobreza['ing_mon'].fillna(0, inplace = True)
pobreza['ing_lab'].fillna(0, inplace = True)
pobreza['ing_ren'].fillna(0, inplace = True)
pobreza['ing_tra'].fillna(0, inplace = True)

# Se eliminan posibles duplicados
pobreza = pobreza.drop_duplicates(subset = ['folioviv', 'foliohog', 'numren'], keep = 'first', index = False)

pobreza['folioviv'] = pobreza['folioviv'].astype(str).str.zfill(10)
pobreza['ent'] = pobreza['folioviv'].str[:2].astype(int)

entidad = {
           1: 'Aguascalientes',
           2: 'Baja California',
           3: 'Baja California Sur',
           4: 'Campeche',
           5: 'Coahuila',
           6: 'Colima',
           7: 'Chiapas',
           8: 'Chihuahua',
           9: 'Ciudad de M茅xico',
           10: 'Durango',
           11: 'Guanajuato',
           12: 'Guerrero',
           13: 'Hidalgo',
           14: 'Jalisco',
           15: 'M茅xico',
           16: 'Michoac谩n',
           17: 'Morelos',
           18: 'Nayarit',
           19: 'Nuevo Le贸n',
           20: 'Oaxaca',
           21: 'Puebla',
           22: 'Quer茅taro',
           23: 'Quintana Roo',
           24: 'San Luis Potos铆',
           25: 'Sinaloa',
           26: 'Sonora',
           27: 'Tabasco',
           28: 'Tamaulipas',
           29: 'Tlaxcala',
           30: 'Veracruz',
           31: 'Yucat谩n',
           32: 'Zacatecas'}
           
pobreza['entidad'] = pobreza['ent'].map(entidad)
```


### ndice de Privaci贸n Social {.tabset .tabset-pills .top3-tiles} 

#### Opci贸n 1 {.tabset .tabset-pills .top4-tiles} 

```{python}
pobreza['i_privacion'] = pobreza[['ic_rezedu', 'ic_asalud', 'ic_segsoc', 'ic_cv', 'ic_sbv', 'ic_ali_nc']].sum(axis = 1)

pobreza.loc[pobreza['ic_rezedu'].isna() |
             pobreza['ic_asalud'].isna() |
              pobreza['ic_segsoc'].isna() |
               pobreza['ic_cv'].isna() |
                pobreza['ic_sbv'].isna() |
                 pobreza['ic_ali'].isna(), 'i_privacion'] = np.NaN
```


### Pobreza multidimensional {.tabset .tabset-pills .top3-tiles}  

#### Opci贸n 1 {.tabset .tabset-pills .top4-tiles}  

```{python}
# Pobreza
pobreza.loc[(pobreza['plp'] == 1) &
             (pobreza['i_privacion'] >= 1) &
              (~pobreza['i_privacion'].isna()), 'pobreza'] = 1 # Pobre
pobreza.loc[((pobreza['plp'] == 0) | (pobreza['i_privacion'] == 0)) &
             (~pobreza['plp'].isna()) &
              (~pobreza['i_privacion'].isna()), 'pobreza'] = 0 # No pobre

# Pobreza extrema
pobreza.loc[(pobreza['plp_e'] == 1) &
             (pobreza['i_privacion'] >= 3) &
              (~pobreza['i_privacion'].isna()), 'pobreza_e'] = 1 # Pobre extremo
pobreza.loc[((pobreza['plp_e'] == 0) | (pobreza['i_privacion'] < 3)) &
             (~pobreza['plp_e'].isna()) &
              (~pobreza['i_privacion'].isna()), 'pobreza_e'] = 0 # No pobre extremo

# Pobreza moderada
pobreza.loc[(pobreza['pobreza'] == 1) &
             (pobreza['pobreza_e'] == 0), 'pobreza_m'] = 1 # Pobre moderado
pobreza.loc[(pobreza['pobreza'] == 0) | ((pobreza['pobreza'] == 1) &
             (pobreza['pobreza_e'] == 1)), 'pobreza_m'] = 0 # No pobre moderado
```


### Poblaci贸n vulnerable {.tabset .tabset-pills .top3-tiles}  

#### Opci贸n 1 {.tabset .tabset-pills .top4-tiles}  

```{python}
# Vulnerables por carencias
pobreza['vul_car'] = 0  
pobreza.loc[(pobreza['plp'] == 0) &
             (pobreza['i_privacion'] >= 1) &
              (~pobreza['i_privacion'].isna()), 'vul_car'] = 1 # Vulnerable
pobreza.loc[pd.isna(pobreza['pobreza']), 'vul_car'] = pd.NA # No vulnerable

# Vulnerables por ingresos
pobreza['vul_ing'] = 0  
pobreza.loc[(pobreza['plp'] == 1) &
             (pobreza['i_privacion'] == 0), 'vul_ing'] = 1 # Vulnerable
pobreza.loc[pd.isna(pobreza['pobreza']), 'vul_ing'] = pd.NA # No vulnerable
```


### Poblaci贸n no pobre y no vulnerable {.tabset .tabset-pills .top3-tiles}  

#### Opci贸n 1 {.tabset .tabset-pills .top4-tiles}  

```{python}
# Poblaci贸n no pobre y no vulnerable
pobreza['no_pobv'] = 0  
pobreza.loc[(pobreza['plp'] == 0) &
             (pobreza['i_privacion'] == 0), 'no_pobv'] = 1 # Vulnerable
pobreza.loc[pd.isna(pobreza['pobreza']), 'no_pobv'] = pd.NA # No vulnerable
```


### Poblaci贸n con carencias sociales {.tabset .tabset-pills .top3-tiles}  

#### Opci贸n 1 {.tabset .tabset-pills .top4-tiles}    

```{python}
# Poblaci贸n con al menos una carencia
pobreza['carencias'] = 0
pobreza.loc[(pobreza['i_privacion'] >= 1) &
             (~pobreza['i_privacion'].isna()), 'carencias'] = 1 # Poblaci贸n con al menos una carencia social
pobreza.loc[pd.isna(pobreza['pobreza']), 'carencias'] = pd.NA # Poblaci贸n sin carencias sociales

# Poblaci贸n con tres o m谩s carencias
pobreza['carencias3'] = 0
pobreza.loc[(pobreza['i_privacion'] >= 3) &
             (~pobreza['i_privacion'].isna()), 'carencias3'] = 1 # Poblaci贸n con al menos tres carencias sociales
pobreza.loc[pd.isna(pobreza['pobreza']), 'carencias3'] = pd.NA # Poblaci贸n con menos de tres carencias sociales
```


### Cuadrantes {.tabset .tabset-pills .top3-tiles}  

#### Opci贸n 1 {.tabset .tabset-pills .top4-tiles}  

```{python}
pobreza['cuadrantes'] = np.NaN
pobreza.loc[(pobreza['plp'] == 1) &
             (pobreza['i_privacion'] >= 1) &
              (~pobreza['i_privacion'].isna()), 'cuadrantes'] = 1 # Pobres
pobreza.loc[(pobreza['plp'] == 0) &
             (pobreza['i_privacion'] >= 1) &
              (~pobreza['i_privacion'].isna()), 'cuadrantes'] = 2 # Vulnerables por carencias
pobreza.loc[(pobreza['plp'] == 1) &
             (pobreza['i_privacion'] == 0), 'cuadrantes'] = 3 # Vulnerables por ingresos 
pobreza.loc[(pobreza['plp'] == 0) &
             (pobreza['i_privacion'] == 0), 'cuadrantes'] = 4 # No pobres y no vulnerables
```


### Profundidad en el espacio del bienestar econ贸mico {.tabset .tabset-pills .top3-tiles}  

#### Opci贸n 1 {.tabset .tabset-pills .top4-tiles}    

```{python}
#L铆nea de pobreza extrema por ingresos (LPEI)
# Valor monetario de la canasta alimentaria
lp1_urb = 2086.21
lp1_rur = 1600.18

# L铆nea de pobreza por ingresos (LPI)
# Valor monetario de la canasta alimentaria m谩s el valor monetario de la canasta no alimentaria
lp2_urb = 4158.35
lp2_rur = 2970.76
```


```{python}
# FGT (a=1)
# Distancia normalizada del ingreso respecto a la l铆nea de pobreza por ingresos
pobreza.loc[(pobreza['rururb'] == 1) &
             (pobreza['plp'] == 1), 'prof1'] = (lp2_rur - pobreza['ictpc']) / lp2_rur
pobreza.loc[(pobreza['rururb'] == 0) &
             (pobreza['plp'] == 1), 'prof1'] = (lp2_urb - pobreza['ictpc']) / lp2_urb
pobreza.loc[(pobreza['prof1'].isna()) &
             (pobreza['ictpc'].notna()), 'prof1'] = 0

# Distancia normalizada del ingreso respecto a la l铆nea de pobreza extrema por ingresos
pobreza.loc[(pobreza['rururb'] == 1) &
             (pobreza['plp_e'] == 1), 'prof_e1'] = (lp1_rur - pobreza['ictpc']) / lp1_rur
pobreza.loc[(pobreza['rururb'] == 0) &
             (pobreza['plp_e'] == 1), 'prof_e1'] = (lp1_urb - pobreza['ictpc']) / lp1_urb
pobreza.loc[(pobreza['prof_e1'].isna()) &
             (pobreza['ictpc'].notna()), 'prof_e1'] = 0
```


### Profundidad de la privaci贸n social {.tabset .tabset-pills .top3-tiles}  

#### Opci贸n 1 {.tabset .tabset-pills .top4-tiles}    

```{python}
pobreza['profun'] = pobreza['i_privacion'] / 6

#   Intensidad de la privaci贸n social      
            
# Intensidad de la privaci贸n social: pobres
pobreza['int_pob'] = pobreza['profun']*pobreza['pobreza']

# Intensidad de la privaci贸n social: pobres extremos
pobreza['int_pobe']= pobreza['profun']*pobreza['pobreza_e']

# Intensidad de la privaci贸n social: poblaci贸n vulnerable por carencias
pobreza['int_vulcar']=pobreza['profun']*pobreza['vul_car']

# Intensidad de la privaci贸n social: poblaci贸n con carencias sociales
pobreza['int_caren'] = pobreza['profun'] * pobreza['carencias']

pobreza = pobreza[['folioviv', 'foliohog', 'numren', 'est_dis', 'upm', 'factor', 'tam_loc', 'rururb', 'ent', 'ubica_geo',
                   'edad', 'sexo', 'parentesco', 'ic_rezedu', 'anac_e', 'inas_esc', 'niv_ed', 'ic_asalud', 'ic_segsoc', 'sa_dir',
                   'ss_dir', 's_salud', 'par', 'jef_ss', 'cony_ss', 'hijo_ss', 'pea', 'jub', 'pam', 'ing_pam', 'ic_cv', 'icv_pisos',
                   'icv_muros', 'icv_techos', 'icv_hac', 'ic_sbv', 'isb_agua', 'isb_dren', 'isb_luz', 'isb_combus', 'ic_ali_nc',
                   'id_men', 'tot_iaad', 'tot_iamen', 'ins_ali', 'ic_ali', 'lca', 'dch', 'plp_e', 'plp', 'pobreza', 'pobreza_e',
                   'pobreza_m', 'vul_car', 'vul_ing', 'no_pobv', 'i_privacion', 'carencias', 'carencias3', 'cuadrantes', 'prof1',
                   'prof_e1', 'profun', 'int_pob', 'int_pobe', 'int_vulcar', 'int_caren', 'tamhogesc', 'ictpc', 'ict', 'ing_mon',
                   'ing_lab', 'ing_ren', 'ing_tra', 'nomon', 'pago_esp', 'reg_esp', 'hli', 'discap']]
```

**Se guarda la base de datos**
```{python}
pobreza.to_csv(current_directory + '/Output/Data/' + 'pobreza_22.csv', index = False)
```

## Resultados 

### Nivel nacional 

```{python}
base = pobreza[~np.isnan(pobreza['pobreza'])]
base_pobreza = pobreza[pobreza['pobreza'] == 1]

nac= [
      ['pobreza', np.average(a = base['pobreza'], 
                             weights  = base['factor']) * 100 ,
                  np.average(a = base[base['pobreza'] == 1]['pobreza'], 
                             weights = base[base['pobreza'] == 1]['factor'], returned = True)[1]/1000000],     
      ['pobreza_m', np.average(a = base['pobreza_m'], 
                               weights = base['factor']) * 100 ,
                    np.average(a = base[base['pobreza_m'] == 1]['pobreza_m'], 
                               weights = base[base['pobreza_m'] == 1]['factor'], returned = True)[1]/1000000], 
      ['pobreza_e', np.average(a = base['pobreza_e'], 
                               weights  = pobreza[~np.isnan(pobreza['pobreza_e'])]['factor']) * 100 ,
                    np.average(a = base[base['pobreza_e'] == 1]['pobreza_e'], 
                               weights = base[base['pobreza_e'] == 1]['factor'], returned = True)[1]/1000000],     
      ['vul_car', np.average(a = base['vul_car'], 
                             weights = pobreza[~np.isnan(pobreza['vul_car'] )]['factor']) * 100 ,
                  np.average(a = base[base['vul_car'] == 1]['vul_car'], 
                             weights = base[base['vul_car'] == 1]['factor'], returned = True)[1]/1000000],
      ['vul_ing', np.average(a = base['vul_ing'], 
                             weights = pobreza[~np.isnan(pobreza['vul_car'])]['factor']) * 100 ,
                  np.average(a = base[base['vul_ing'] == 1]['vul_ing'], 
                             weights = base[base['vul_ing'] == 1]['factor'], returned = True)[1]/1000000],      
      ['no_pobv', np.average(a = base['no_pobv'], 
                             weights = pobreza[~np.isnan(pobreza['no_pobv'])]['factor']) * 100 ,
                  np.average(a = base[base['no_pobv'] == 1]['no_pobv'], 
                             weights = base[base['no_pobv'] == 1]['factor'], returned = True)[1]/1000000], 
      ['carencias', np.average(a = base['carencias'], 
                               weights=pobreza[~np.isnan(pobreza['carencias'])]['factor']) * 100 ,
                    np.average(a = base[base['carencias'] == 1]['carencias'], 
                               weights = base[base['carencias'] == 1]['factor'], returned = True)[1]/1000000],
      ['carencias3', np.average(a = base['carencias3'], 
                                weights=pobreza[~np.isnan(pobreza['carencias3'])]['factor']) * 100 ,
                     np.average(a = base[base['carencias3'] == 1]['carencias3'], 
                                weights = base[base['carencias3'] == 1]['factor'], returned = True)[1]/1000000],  
      ['ic_rezedu', np.average(a = base['ic_rezedu'], 
                               weights = base['factor']) * 100 ,
                    np.average(a = base[base['ic_rezedu'] == 1]['ic_rezedu'], 
                               weights = base[base['ic_rezedu'] == 1]['factor'], returned = True)[1]/1000000],     
      ['ic_asalud', np.average(a = base['ic_asalud'], 
                               weights = base['factor']) * 100 ,
                    np.average(a = base[base['ic_asalud'] == 1]['ic_asalud'], 
                               weights = base[base['ic_asalud'] == 1]['factor'], returned = True)[1]/1000000], 
      ['ic_segsoc', np.average(a = base['ic_segsoc'], 
                               weights = base['factor']) * 100 ,
                    np.average(a = base[base['ic_segsoc'] == 1]['ic_segsoc'], 
                               weights = base[base['ic_segsoc'] == 1]['factor'], returned = True)[1]/1000000],       
      ['ic_cv', np.average(a = base['ic_cv'], 
                           weights = base['factor']) * 100 , 
                np.average(a = base[base['ic_cv'] == 1]['ic_cv'], 
                           weights = base[base['ic_cv'] == 1]['factor'], returned = True)[1]/1000000],         
      ['ic_sbv', np.average(a = base['ic_sbv'], 
                            weights = base['factor']) * 100 ,
                 np.average(a = base[base['ic_sbv'] == 1]['ic_sbv'], 
                            weights = base[base['ic_sbv'] == 1]['factor'], returned = True)[1]/1000000],            
      ['ic_ali_nc', np.average(a = base['ic_ali_nc'], 
                               weights = base['factor']) * 100 ,
                    np.average(a = base[base['ic_ali_nc'] == 1]['ic_ali_nc'], 
                               weights = base[base['ic_ali_nc'] == 1]['factor'], returned = True)[1]/1000000],      
      ['plp_e', np.average(a = base['plp_e'], 
                           weights = base['factor']) * 100 ,
                np.average(a = base[base['plp_e'] == 1]['plp_e'], 
                           weights = base[base['plp_e'] == 1]['factor'], returned = True)[1]/1000000],
      ['plp', np.average(a = base['plp'], 
                         weights = base['factor']) * 100 ,
              np.average(a = base[base['plp'] == 1]['plp'], 
                         weights = base[base['plp'] == 1]['factor'], returned = True)[1]/1000000]]

titulos = ['Indicador', 'Porcentaje', 'Millones de personas']

print(tabulate(nac, titulos, tablefmt = 'grid', floatfmt = ('.6f')))
```

**Se guarda la base de datos**
```{python}
nac = pd.DataFrame(nac)
nac.to_csv(current_directory + '/Output/' + 'indice de pobreza a nivel nacional.csv', index = False)
```

### Porcentaje y n煤mero de personas por indicador de pobreza, entidad federativa.   

```{python}
ids = np.unique(pobreza['ent'])

pob_ent_por =[list(j) for j in  zip([np.average(a = base[base['ent'] == i]['pobreza'], 
                                                weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                    [np.average(a = base[base['ent'] == i]['pobreza_m'], 
                                                weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                    [np.average(a = base[base['ent'] == i]['pobreza_e'], 
                                                weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                    [np.average(a = base[base['ent'] == i]['vul_car'], 
                                                weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                    [np.average(a = base[base['ent'] == i]['vul_ing'], 
                                                weights = base[base['ent'] == i]['factor']) * 100 for i in ids])]

titulos = ['pobreza', 'pobreza_m', 'pobreza_e', 'vul_car', 'vul_ing', 'no_pobv']   

print(tabulate(pob_ent_por, titulos, floatfmt = ('.6f')))    

pob_ent_tot =[list(j) for j in  zip([np.average(a = base[base['pobreza'] == 1][base['ent'] == i]['pobreza'], 
                                                weights = base[base['pobreza'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],         
                                    [np.average(a = base[base['pobreza_m'] == 1][base['ent'] == i]['pobreza_m'], 
                                                weights = base[base['pobreza_m'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                    [np.average(a = base[base['pobreza_e'] == 1][base['ent'] == i]['pobreza_e'], 
                                                weights = base[base['pobreza_e'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                    [np.average(a = base[base['vul_car'] == 1][base['ent'] == i]['vul_car'], 
                                                weights = base[base['vul_car'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                    [np.average(a = base[base['vul_ing'] == 1][base['ent'] == i]['vul_ing'], 
                                                weights = base[base['vul_ing'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids])]

print(tabulate(pob_ent_tot, titulos, floatfmt = ('.0f')))    
```


**Se guarda la base de datos**
```{python}
pob_ent_tot = pd.DataFrame(pob_ent_tot)
pob_ent_tot.to_csv(current_directory + '/Output/' + 'indice de pobreza a nivel estatal.csv', index = False)
```

### Porcentaje y n煤mero de personas por indicador de carencia social, entidad federativa.    

```{python}
ids = np.unique(pobreza['ent'])

care_ent_por =[list(j) for j in  zip([np.average(a = base[base['ent'] == i]['ic_rezedu'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                     [np.average(a = base[base['ent'] == i]['ic_asalud'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                     [np.average(a = base[base['ent'] == i]['ic_segsoc'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                     [np.average(a = base[base['ent'] == i]['ic_cv'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                     [np.average(a = base[base['ent'] == i]['ic_sbv'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                     [np.average(a = base[base['ent'] == i]['ic_ali_nc'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                     [np.average(a = base[base['ent'] == i]['carencias'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                     [np.average(a = base[base['ent'] == i]['carencias3'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                     [np.average(a = base[base['ent'] == i]['plp_e'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                     [np.average(a = base[base['ent'] == i]['plp'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids])]

titulos = ['ic_rezedu', 'ic_asalud', 'ic_segsoc', 'ic_cv', 'ic_sbv', 'ic_ali_nc', 'carencias', 'carencias3', 'plp_e', 'plp']   

print(tabulate(care_ent_por, titulos,floatfmt=('.6f')))    

care_ent_tot =[list(j) for j in  zip([np.average(a = base[base['ic_rezedu'] == 1][base['ent'] == i]['ic_rezedu'], 
                                                 weights = base[base['ic_rezedu'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],           
                                     [np.average(a = base[base['ic_asalud'] == 1][base['ent'] == i]['ic_asalud'], 
                                                 weights = base[base['ic_asalud'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                     [np.average(a = base[base['ic_segsoc'] == 1][base['ent'] == i]['ic_segsoc'], 
                                                 weights = base[base['ic_segsoc'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                     [np.average(a = base[base['ic_cv'] == 1][base['ent'] == i]['ic_cv'], 
                                                 weights = base[base['ic_cv'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                     [np.average(a = base[base['ic_sbv'] == 1][base['ent'] == i]['ic_sbv'], 
                                                 weights = base[base['ic_sbv'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                     [np.average(a = base[base['ic_ali_nc'] == 1][base['ent'] == i]['ic_ali_nc'], 
                                                 weights = base[base['ic_ali_nc'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                     [np.average(a = base[base['carencias'] == 1][base['ent'] == i]['carencias'], 
                                                 weights = base[base['carencias'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                     [np.average(a = base[base['carencias3'] == 1][base['ent'] == i]['carencias3'], 
                                                 weights = base[base['carencias3'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                     [np.average(a = base[base['plp_e'] == 1][base['ent'] == i]['plp_e'], 
                                                 weights = base[base['plp_e'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                     [np.average(a = base[base['plp'] == 1][base['ent'] == i]['plp'], 
                                                 weights = base[base['plp'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids])]

titulos = ['ic_rezedu', 'ic_asalud', 'ic_segsoc', 'ic_cv', 'ic_sbv', 'ic_ali_nc', 'carencias', 'carencias3', 'plp_e', 'plp']   

print(tabulate(care_ent_tot, titulos, floatfmt = ('.0f')))
```


**Se guarda la base de datos**
```{python}
care_ent_tot = pd.DataFrame(care_ent_tot)
care_ent_tot.columns = ['ic_rezedu', 'ic_asalud', 'ic_segsoc', 'ic_cv', 'ic_sbv', 'ic_ali_nc', 'carencias', 'carencias3', 'plp_e', 'plp']   
care_ent_tot.to_csv(current_directory + '/Output/' + 'indicadores de carencia a nivel estatal.csv', index = False)
```
