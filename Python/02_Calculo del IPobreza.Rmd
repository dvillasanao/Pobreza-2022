---
title: "C치lculo del 칤ndice"
subtitle: '칈ndice de pobreza 2022 / Python'
author: "Diana Villasana Ocampo"
output:
   html_document:
      highlight: tango
      theme: flatly
      toc: yes
      toc_depth: 2
      toc_float:
        collapsed: yes
---

\usepackage{color}

```{=html}
<style>
code.r{
  font-size: 10px;
}
pre {
  font-size: 12px
}
</style>

<style>
body {
text-align: justify;
font-style: normal;
font-family: "Montserrat";
font-size: 12px
}
h1.title {
  font-size: 40px;
  color: #000D3B;
}
h1 {
  font-size: 30px;
  color: #B6854D;
}
h2 {
 font-size: 27px;
  color: #172984;
}
h3 {
  font-size: 20px;
  color: #172984;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 16px;
}
h7 {
  font-size: 16px;
}
</style>
```

```{=html}
<style>
.nav>li>a {
    position: relative;
    display: block;
    padding: 10px 15px;
    color: #0A2687;
}
.nav-pills>li.active>a, .nav-pills > li.active > a:hover, .nav-pills > li.active > a:focus {
    color: #ffffff;
    background-color: #09C2BC;
}
.top1-tiles a:nth-of-type(1):hover, .top-tiles1 a:nth-of-type(1):focus{
    color: #ffffff;
    background: #0A6A87
}
.top2-tiles a:nth-of-type(1):hover, .top2-tiles a:nth-of-type(1):focus{
    color: #ffffff;
    background: #0A6CC8
}
.top3-tiles a:nth-of-type(1):hover, .top2-tiles a:nth-of-type(1):focus{
    color: #ffffff;
    background: #596AB7
}
.top4-tiles a:nth-of-type(1):hover, .top2-tiles a:nth-of-type(1):focus{
    color: #ffffff;
    background: #A92AA4
}
</style>
```

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = FALSE, cache.lazy = FALSE, 
                         eval = FALSE, class.source = "fold-show")
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
options(digits = 2, encoding = "UTF8")
options(reticulate.repl.quiet = TRUE) #Python REPL in the R session, which can be used to interactively run Python code. All code executed within the REPL is run within the Python main module, and any generated Python objects will persist in the Python session
modo_notdebug = TRUE #es para separar las configuraciones de lo que ser칤a un despliegue a producci칩n y un ambiente local, el ALLOWED_HOST es un settings para definir los dominios permitidos cuando estar치 en modo producci칩n,
```   
 

```{r, echo=FALSE}
rm(list = ls())
```

```{r, echo=FALSE}
setwd(here::here())
```

游댳 Se define un `conda environment` a utilizar:

```{r,eval=FALSE}
#Se utiliza {reticulate} para instalar miniconda con:
require(reticulate)
#reticulate::install_miniconda()
##Se visualiza la configuraci칩n de python: que tengo actualemente.  
#reticulate::py_config()
reticulate::repl_python() #can be used to interactively run Python code
# Se define un `conda environment` a utilizar:
#reticulate::conda_create(envname='Pobreza-2022', 
  #                        python_version="3.11.5")
```

```{python, eval = FALSE}
# Eliminar todas las variables en el entorno de trabajo actual
for name in dir():
    if not name.startswith('_'):
        del globals()[name]
```


**Ubicaci칩n del proyecto** 
```{r}
root_dir = rprojroot::find_rstudio_root_file()
```

```{python}
import os
# Cambia el directorio de trabajo al directorio actual del script
os.path.dirname(os.getcwd())
current_directory = r.root_dir
os.chdir(current_directory)
os.getcwd()
```

**Se intalan la paqueter칤as de pyton** 
```{python}
# Se instalan los paquetes y librer칤as a utilizar en el programa
#pip install pandas
#pip install numpy
#pip install tabulate
import pandas as pd 
import numpy as np
from tabulate import tabulate
```


## Medici칩n multidimensional del 칤ndice de pobreza 2022 {.tabset .tabset-pills .top1-tiles}       

Se sigue la estructura del 칤ndice de pobreza, presentado en la p치gina oficial del CONEVAL.   

De acuerdo con los Lineamientos y criterios generales para la definici칩n, identificaci칩n y medici칩n de la pobreza (2018) que se pueden consultar en el [Diario Oficial de la Federaci칩n](https://www.dof.gob.mx/nota_detalle.php?codigo=5542421&fecha=30/10/2018) y la Metodolog칤a para la medici칩n multidimensional de la pobreza en M칠xico, tercera edici칩n (https://www.coneval.org.mx/InformesPublicaciones/InformesPublicaciones/Documents/Metodologia-medicion-multidimensional-3er-edicion.pdf).   

Siguiendo la estructura del c치lculo del 칤ndice multidimensional de la pobreza, se simplifican los c칩digos para entender el orden del c치lculo de los indicadores sociodemogr치ficos.      


### Indicadores de carencias sociales  {.tabset .tabset-pills .top2-tiles}    

#### I. Indicador de rezago educativo  {.tabset .tabset-pills .top3-tiles}     

```{python}
poblacion = pd.read_csv(current_directory + "/Bases de datos/poblacion.csv", low_memory = False)
```

**Indicador de carencia por rezago educativo `ic_rezedu`**

Se considera en situaci칩n de carencia por rezago educativo a la poblaci칩n que cumpla con alguno de los siguientes criterios:

1. Tiene de tres a 21 a침os, no cuenta con la educaci칩n obligatoria y no asiste a un centro de educaci칩n formal. 
2. Tiene 22 a침os o m치s, naci칩 a partir del a침o 1998 y no ha terminado la educaci칩n obligatoria (media superior).   
3. Tiene 16 a침os o m치s, naci칩 entre 1982 y 1997 y no cuenta con el nivel de educaci칩n obligatorio vigente en el momento en que deb칤a haberlo cursado (secundaria completa).   
4. Tiene 16 a침os o m치s, naci칩 antes de 1982 y no cuenta con el nivel de educaci칩n obligatorio vigente en el momento en que deb칤a haberlo cursado (primaria completa).	  

##### Opci칩n 1     

```{python}
import pandas as pd
import numpy as np

rezago_educativo = poblacion.copy()

# Convirtiendo variables string a numericas
rezago_educativo[['parentesco','edad','asis_esc','nivelaprob','gradoaprob','antec_esc','hablaind'
                ]] = rezago_educativo[['parentesco','edad','asis_esc','nivelaprob','gradoaprob','antec_esc','hablaind']].apply(pd.to_numeric, errors = 'coerce')
       
# Poblaci칩n objetivo: no se incluye a hu칠spedes ni trabajadores dom칠sticos
rezago_educativo = rezago_educativo[~((rezago_educativo['parentesco'] >= 400) & (rezago_educativo['parentesco'] < 500) |
                                      (rezago_educativo['parentesco'] >= 700) & (rezago_educativo['parentesco'] < 800))
                                      ]

# A침o de nacimiento
rezago_educativo['anac_e'] = 2022 - rezago_educativo['edad'].fillna(0)

# Inasistencia escolar (se reporta para personas de 3 a침os o m치s)
rezago_educativo['inas_esc'] = np.NaN
rezago_educativo.loc[(rezago_educativo['asis_esc'] == 1), 'inas_esc'] = 0 # S칤 asiste
rezago_educativo.loc[(rezago_educativo['asis_esc'] == 2), 'inas_esc'] = 1 # No asiste

# Nivel educativo
rezago_educativo['niv_ed'] = np.NaN
# Con primaria incompleta o menos
rezago_educativo.loc[(rezago_educativo['nivelaprob'] < 2) | ((rezago_educativo['nivelaprob'] == 2) & (rezago_educativo['gradoaprob'] < 6)), 'niv_ed'] = 0
# Primaria completa o secundaria incompleta
rezago_educativo.loc[((rezago_educativo['nivelaprob'] == 2) & (rezago_educativo['gradoaprob'] == 6)) |
                      ((rezago_educativo['nivelaprob'] == 3) & (rezago_educativo['gradoaprob'] < 3)) |
                       (((rezago_educativo['nivelaprob'] == 5) | (rezago_educativo['nivelaprob'] == 6)) & 
                        (rezago_educativo['gradoaprob'] < 3) &                   
                         (rezago_educativo['antec_esc'] == 1)), 'niv_ed'] = 1
# Secundaria completa o media superior incompleta
rezago_educativo.loc[((rezago_educativo['nivelaprob'] == 3) & (rezago_educativo['gradoaprob'] == 3)) |
                      ((rezago_educativo['nivelaprob'] == 4) & (rezago_educativo['gradoaprob'] < 3)) |
                       ((rezago_educativo['nivelaprob'] == 5) & (rezago_educativo['antec_esc'] == 1) & (rezago_educativo['gradoaprob'] >= 3)) |
                        ((rezago_educativo['nivelaprob'] == 6) & (rezago_educativo['antec_esc'] == 1) & (rezago_educativo['gradoaprob'] >= 3)) |
                         ((rezago_educativo['nivelaprob'] == 5) & (rezago_educativo['antec_esc'] == 2) & (rezago_educativo['gradoaprob'] < 3)) |
                          ((rezago_educativo['nivelaprob'] == 6) & (rezago_educativo['antec_esc'] == 2) & (rezago_educativo['gradoaprob'] < 3)), 'niv_ed'] = 2
# Media superior completa o mayor nivel educativo
rezago_educativo.loc[((rezago_educativo['nivelaprob'] == 4) & (rezago_educativo['gradoaprob'] == 3)) |
                      ((rezago_educativo['nivelaprob'] == 5) & (rezago_educativo['antec_esc'] == 2) & (rezago_educativo['gradoaprob'] >= 3)) |
                       ((rezago_educativo['nivelaprob'] == 6) & (rezago_educativo['antec_esc'] == 2) & (rezago_educativo['gradoaprob'] >= 3)) |
                        ((rezago_educativo['nivelaprob'] == 5) & (rezago_educativo['antec_esc'] > 2)) |
                         ((rezago_educativo['nivelaprob'] == 6) & (rezago_educativo['antec_esc'] > 2)) |
                          ((rezago_educativo['nivelaprob'] >= 7) & (~rezago_educativo['nivelaprob'].isna())), 'niv_ed'] = 3

# Indicador de carencia por rezago educativo
rezago_educativo['ic_rezedu'] = np.NaN
# Presenta carencia
rezago_educativo.loc[(rezago_educativo['anac_e'] >= 1998) & (rezago_educativo['edad'].between(3, 21)) &
                      (rezago_educativo['inas_esc'] == 1) & (rezago_educativo['niv_ed'] < 3), 'ic_rezedu'] = 1 # Presenta carencia
rezago_educativo.loc[((rezago_educativo['anac_e'] >= 1982) & (rezago_educativo['anac_e'] <= 1997)) &
                      (rezago_educativo['edad'] >= 16) & (rezago_educativo['niv_ed'] < 2), 'ic_rezedu'] = 1 # Presenta carencia
rezago_educativo.loc[(rezago_educativo['anac_e'] <= 1981) & (rezago_educativo['edad'] >= 16) &  
                      (rezago_educativo['niv_ed'] == 0), 'ic_rezedu'] = 1 # Presenta carencia
rezago_educativo.loc[(rezago_educativo['anac_e'] >= 1998) & (rezago_educativo['edad'] >= 22) & 
                      (rezago_educativo['niv_ed'] < 3), 'ic_rezedu'] = 1 # Presenta carencia
                      
# No presenta carencia
rezago_educativo.loc[(rezago_educativo['edad'].between(0, 2)), 'ic_rezedu'] = 0 # No presenta carencia
rezago_educativo.loc[(rezago_educativo['anac_e'] >= 1998) & (rezago_educativo['edad'].between(3, 21)) &
                      (rezago_educativo['inas_esc'] == 0), 'ic_rezedu'] = 0 # No presenta carencia
rezago_educativo.loc[(rezago_educativo['niv_ed'] == 3), 'ic_rezedu'] = 0 # No presenta carencia
rezago_educativo.loc[((rezago_educativo['anac_e'] >= 1982) & (rezago_educativo['anac_e'] <= 1997)) &
                       (rezago_educativo['edad'] >= 16) & ((rezago_educativo['niv_ed'] >= 2) &
                        (~rezago_educativo['niv_ed'].isna())), 'ic_rezedu'] = 0 # No presenta carencia
rezago_educativo.loc[(rezago_educativo['anac_e'] <= 1981) &
                      (rezago_educativo['edad'] >= 16) &
                       ((rezago_educativo['niv_ed'] >= 1) & (~rezago_educativo['niv_ed'].isna())), 'ic_rezedu'] = 0 # No presenta carencia
                      
# Hablante de lengua ind칤gena
rezago_educativo['hli'] = np.NaN
rezago_educativo.loc[(rezago_educativo['hablaind'] == 1) & (rezago_educativo['edad'] >= 3), 'hli'] = 1 # Habla lengua ind칤gena
rezago_educativo.loc[(rezago_educativo['hablaind'] == 2) & (rezago_educativo['edad'] >= 3), 'hli'] = 0 # No habla lengua ind칤gena

rezago_educativo = rezago_educativo[['folioviv', 'foliohog', 'numren', 'edad', 'anac_e', 'inas_esc', 'niv_ed',
                                     'ic_rezedu', 'parentesco', 'hli'
                                     ]]
```

**Se guarda la base de datos** 
```{python}
#del [[rezedu]] # Eliminamos el data.frame "rezedu"  
rezago_educativo.to_csv(current_directory + '/Output/Data/' + 'ic_rezedu22.csv', index = False)
```

##### Opci칩n 2  

```{python}
def indicador_rezago_educativo(poblacion):
    def convert_to_numeric(df):
        cols_to_convert = ['parentesco','edad','asis_esc','nivelaprob','gradoaprob','antec_esc','hablaind']
        df[cols_to_convert] = df[cols_to_convert].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    def filter_population(df):
        return df[~((df['parentesco'] >= 400) & (df['parentesco'] < 500) | (df['parentesco'] >= 700) & (df['parentesco'] < 800))]
    
    def add_birth_year(df):
        df['anac_e'] = 2022 - df['edad'].fillna(0)
        return df
    
    def add_inas_esc(df):
        df['inas_esc'] = np.NaN
        df.loc[(df['asis_esc'] == 1), 'inas_esc'] = 0
        df.loc[(df['asis_esc'] == 2), 'inas_esc'] = 1
        return df
    
    def add_niv_ed(df):
        df['niv_ed'] = np.NaN
        df.loc[(df['nivelaprob'] < 2) | ((df['nivelaprob'] == 2) & (df['gradoaprob'] < 6)), 'niv_ed'] = 0
        df.loc[((df['nivelaprob'] == 2) & (df['gradoaprob'] == 6)) |
               ((df['nivelaprob'] == 3) & (df['gradoaprob'] < 3)) |
               (((df['nivelaprob'] == 5) | (df['nivelaprob'] == 6)) & (df['gradoaprob'] < 3) & (df['antec_esc'] == 1)), 'niv_ed'] = 1
        df.loc[((df['nivelaprob'] == 3) & (df['gradoaprob'] == 3)) |
               ((df['nivelaprob'] == 4) & (df['gradoaprob'] < 3)) |
               ((df['nivelaprob'] == 5) & (df['antec_esc'] == 1) & (df['gradoaprob'] >= 3)) |
               ((df['nivelaprob'] == 6) & (df['antec_esc'] == 1) & (df['gradoaprob'] >= 3)) |
               ((df['nivelaprob'] == 5) & (df['antec_esc'] == 2) & (df['gradoaprob'] < 3)) |
               ((df['nivelaprob'] == 6) & (df['antec_esc'] == 2) & (df['gradoaprob'] < 3)), 'niv_ed'] = 2
        df.loc[((df['nivelaprob'] == 4) & (df['gradoaprob'] == 3)) |
               ((df['nivelaprob'] == 5) & (df['antec_esc'] == 2) & (df['gradoaprob'] >= 3)) |
               ((df['nivelaprob'] == 6) & (df['antec_esc'] == 2) & (df['gradoaprob'] >= 3)) |
               ((df['nivelaprob'] == 5) & (df['antec_esc'] > 2)) |
               ((df['nivelaprob'] == 6) & (df['antec_esc'] > 2)) |
               ((df['nivelaprob'] >= 7) & (~df['nivelaprob'].isna())), 'niv_ed'] = 3
        return df
    
    def add_ic_rezedu(df):
        df['ic_rezedu'] = np.NaN
        df.loc[(df['anac_e'] >= 1998) & (df['edad'].between(3, 21)) &
               (df['inas_esc'] == 1) & (df['niv_ed'] < 3), 'ic_rezedu'] = 1
        df.loc[((df['anac_e'] >= 1982) & (df['anac_e'] <= 1997)) &
               (df['edad'] >= 16) & (df['niv_ed'] < 2), 'ic_rezedu'] = 1
        df.loc[(df['anac_e'] <= 1981) & (df['edad'] >= 16) & (df['niv_ed'] == 0), 'ic_rezedu'] = 1
        df.loc[(df['anac_e'] >= 1998) & (df['edad'] >= 22) & (df['niv_ed'] < 3), 'ic_rezedu'] = 1
        df.loc[(df['edad'].between(0, 2)), 'ic_rezedu'] = 0
        df.loc[(df['anac_e'] >= 1998) & (df['edad'].between(3, 21)) & (df['inas_esc'] == 0), 'ic_rezedu'] = 0
        df.loc[(df['niv_ed'] == 3), 'ic_rezedu'] = 0
        df.loc[((df['anac_e'] >= 1982) & (df['anac_e'] <= 1997)) & (df['edad'] >= 16) &
               ((df['niv_ed'] >= 2) & (~df['niv_ed'].isna())), 'ic_rezedu'] = 0
        df.loc[(df['anac_e'] <= 1981) & (df['edad'] >= 16) &
               ((df['niv_ed'] >= 1) & (~df['niv_ed'].isna())), 'ic_rezedu'] = 0
        return df
    
    def add_hli(df):
        df['hli'] = np.NaN
        df.loc[(df['hablaind'] == 1) & (df['edad'] >= 3), 'hli'] = 1
        df.loc[(df['hablaind'] == 2) & (df['edad'] >= 3), 'hli'] = 0
        return df
      
    def seleccionar_columnas(df):
        columnas = ['folioviv', 'foliohog', 'numren', 'edad', 'anac_e', 'inas_esc', 'niv_ed',
                    'ic_rezedu', 'parentesco', 'hli']
        return df[columnas]
      
    return (poblacion.copy()
                     .pipe(convert_to_numeric)
                     .pipe(filter_population)
                     .pipe(add_birth_year)
                     .pipe(add_inas_esc)
                     .pipe(add_niv_ed)
                     .pipe(add_ic_rezedu)
                     .pipe(add_hli)
                     .pipe(seleccionar_columnas)
           )

## Indicador de rezago educativo 
rezago_educativo = indicador_rezago_educativo(poblacion)
```

**Se guarda la base de datos** 
```{python}
#del [[rezedu]] # Eliminamos el data.frame "rezedu"  
rezago_educativo.to_csv(current_directory + '/Output/Data/' + 'ic_rezedu22_2.csv', index = False)
```

#### II. Indicador de carencia por acceso a los servicios de salud  {.tabset .tabset-pills .top3-tiles}       

```{python}
#del [[trabajos]] # Eliminamos el data.frame "trabajos" 
ocupados = pd.read_csv(current_directory + "/Bases de datos/trabajos.csv", low_memory = False)
```

**Indicador de carencia por servicios de salud `ic_asalud`**  

Se considera en situaci칩n de carencia por acceso a servicios de salud a la poblaci칩n que:    
 
 1. No se encuentra inscrita al Seguro Popular* o afiliada a alguna instituci칩n  por prestaci칩n laboral, contrataci칩n voluntaria o afiliaci칩n de un familiar por parentesco directo a recibir servicios m칠dicos por alguna instituci칩n que los preste como: las instituciones de seguridad social (`IMSS`, `ISSSTE federal o estatal`, `Pemex`, `Ej칠rcito` o `Marina`), los servicios m칠dicos privados, u otra instituci칩n m칠dica.      
 
 - Se reporta la poblaci칩n que respondi칩 estar afiliado o inscrito al Seguro Popular, o que tiene derecho a los servicios del
 Instituto de Salud para el Bienestar (`INSABI`), lo anterior de acuerdo con el cuestionario de la ENIGH 2022.     
 

##### Opci칩n 1     
 
```{python}
#Convirtiendo variables string a numericas
ocupados[['subor', 'indep', 'tiene_suel','pago','id_trabajo']
         ] = ocupados[['subor', 'indep', 'tiene_suel','pago','id_trabajo']
                      ].apply(pd.to_numeric, errors = 'coerce')

# Tipo de trabajador: identifica la poblaci칩n subordinada e independiente
ocupados['tipo_trab'] = np.NaN
# Subordinados
ocupados.loc[(ocupados['subor'] == 1), 'tipo_trab'] = 1
# Independientes que reciben un pago
ocupados.loc[(ocupados['subor'] == 2) & (ocupados['indep'] == 1) & (ocupados['tiene_suel'] == 1), 'tipo_trab'] = 2
ocupados.loc[(ocupados['subor'] == 2) & (ocupados['indep'] == 2) & (ocupados['pago'] == 1), 'tipo_trab'] = 2
#Independientes que no reciben un pago
ocupados.loc[(ocupados['subor'] == 2) & (ocupados['indep'] == 1) & (ocupados['tiene_suel'] == 2), 'tipo_trab'] = 3
ocupados.loc[(ocupados['subor'] == 2) & (ocupados['indep'] == 2) & ((ocupados['pago'] == 2) | (ocupados['pago'] == 3)), 'tipo_trab'] = 3

# Ocupaci칩n principal o secundaria
ocupados['ocupa'] = np.NaN
ocupados.loc[(ocupados['id_trabajo'] == 1), 'ocupa'] = 1
ocupados.loc[(ocupados['id_trabajo'] == 2), 'ocupa'] = 1

ocupados = ocupados[['folioviv', 'foliohog', 'numren', 'id_trabajo', 'tipo_trab', 'ocupa']]

# Distinci칩n de prestaciones en trabajo principal y secundario
ocupados = pd.pivot_table(ocupados, 
                          index = ['folioviv', 'foliohog', 'numren'], 
                          columns = 'id_trabajo', 
                          values = ['tipo_trab', 'ocupa'], 
                          aggfunc = np.sum, 
                          fill_value = 0)
                          
ocupados.columns = [f'{i}{j}' for i, j in ocupados.columns]
ocupados = ocupados.reset_index()

# Identificaci칩n de la poblaci칩n trabajadora (toda la que reporta al menos un empleo en la base de trabajos.csv)
ocupados['trab'] = 1
ocupados = ocupados[['folioviv', 'foliohog', 'numren', 'trab'] + [col for col in ocupados.columns if col.startswith('tipo_trab') or col.startswith('ocupa')]]
```

**Se guarda la base de datos** 
```{python}
ocupados.to_csv(current_directory + '/Output/Data/' + 'ocupados22.csv', index = False)
```

**Indicador de carencia por acceso a los servicios de salud** 

```{python}
#Indicador de carencia por acceso a los servicios de salud
salud = poblacion.copy()
# Poblaci칩n objetivo: no se incluye a hu칠spedes ni trabajadores dom칠sticos
salud = salud.loc[~((salud['parentesco'] >= 400) & (salud['parentesco'] < 500) |
                    (salud['parentesco'] >= 700) & (salud['parentesco'] < 800))]

salud = pd.merge(salud, 
                  ocupados, 
                   on = ['folioviv', 'foliohog', 'numren'], 
                    how = 'left')

#Convirtiendo variables string a numericas
salud[['parentesco', 'trab', 'edad', 'act_pnea1', 'act_pnea2','ocupa1', 'atemed', 'inst_1', 'inst_2', 'inst_3', 'inst_4', 'inst_5', 'inst_6', 
       'inscr_1', 'inscr_2', 'inscr_3', 'inscr_4', 'inscr_5', 'inscr_6', 'inscr_7', 'asis_esc', 'pop_insabi', 'segvol_2']
      ] = salud[['parentesco', 'trab', 'edad', 'act_pnea1', 'act_pnea2','ocupa1', 'atemed', 'inst_1', 'inst_2', 'inst_3', 'inst_4', 'inst_5', 
                 'inst_6', 'inscr_1', 'inscr_2', 'inscr_3', 'inscr_4', 'inscr_5', 'inscr_6', 'inscr_7', 'asis_esc', 'pop_insabi', 'segvol_2']
                 ].apply(pd.to_numeric, errors = 'coerce')

# PEA (personas de 16 a침os o m치s)
salud['pea'] = np.NaN
salud.loc[(salud['trab'] == 1) & (salud['edad'] >= 16) & 
           (~salud['edad'].isna()), 'pea'] = 1 # PEA: ocupada
salud.loc[((salud['act_pnea1'] == 1) | (salud['act_pnea2'] == 1)) & 
           (salud['edad'] >= 16) & (~salud['edad'].isna()),'pea'] = 2 # PEA: desocupada
salud.loc[((salud['edad'] >= 16) & (~salud['edad'].isna()) &
           (((salud['act_pnea1'] != 1) | (salud['act_pnea1'].isna())) &
            ((salud['act_pnea2'] != 1) | (salud['act_pnea2'].isna()))) &
             (((salud['act_pnea1'] >= 2) & (salud['act_pnea1'] <= 6)) |
              ((salud['act_pnea2'] >= 2) & (salud['act_pnea2'] <= 6)))),'pea'] = 0 # PNEA
   
# Tipo de trabajo
## Ocupaci칩n principal
salud['tipo_trab1'] = np.where(salud['pea'] == 1, 
                                salud['tipo_trab1'], 
                                 salud['tipo_trab1']) # Depende de un patr칩n, jefe o superior 
salud['tipo_trab1'] = np.where((salud['pea'] == 0) | (salud['pea'] == 2), 
                                 np.NaN, 
                                  salud['tipo_trab1']) # No depende de un jefe y recibe o tiene asignado un sueldo
salud['tipo_trab1'] = np.where(salud['pea'].isna(), 
                                np.NaN, 
                                 salud['tipo_trab1']) # No depende de un jefe y no recibe o no tiene asignado un sueldo
## Ocupaci칩n secundaria
salud['tipo_trab2'] = np.where(salud['pea'] == 1, 
                                salud['tipo_trab2'], 
                                 salud['tipo_trab2']) # Depende de un patr칩n, jefe o superior
salud['tipo_trab2'] = np.where((salud['pea'] == 0) | (salud['pea'] == 2), 
                                 np.NaN, 
                                  salud['tipo_trab2']) # No depende de un jefe y recibe o tiene asignado un sueldo
salud['tipo_trab2'] = np.where(salud['pea'].isna(), 
                                np.NaN, 
                                 salud['tipo_trab2']) # No depende de un jefe y no recibe o no tiene asignado un sueldo

# Servicios m칠dicos prestaciones laborales
salud['smlab1'] = np.NaN
## Ocupaci칩n principal
salud.loc[(salud['ocupa1'] == 1), 'smlab1'] = 0 # Sin servicios m칠dicos
salud.loc[((salud['ocupa1'] == 1) & (salud['atemed'] == 1) &
           ((salud['inst_1'] == 1) | (salud['inst_2'] == 2) | (salud['inst_3'] == 3) | (salud['inst_4'] == 4)) & 
            (salud['inscr_1'] == 1), 'smlab1')] = 1 # Con servicios m칠dicos

## Ocupaci칩n secundaria
salud['smlab2'] = np.NaN
salud.loc[(salud['ocupa2'] == 1), 'smlab2'] = 0 # Sin servicios m칠dicos
salud.loc[((salud['ocupa2'] == 1) & (salud['atemed'] == 1) &
           ((salud['inst_1'] == 1) | (salud['inst_2'] == 2) | (salud['inst_3'] == 3) | (salud['inst_4'] == 4)) & 
            (salud['inscr_1'] == 1), 'smlab2')] = 1 # Con servicios m칠dicos

# Contrataci칩n voluntaria de servicios m칠dicos
salud['smcv'] = np.NaN
salud.loc[((salud['edad'] >= 12) & (~salud['edad'].isna())), 'smcv'] = 0 # No cuenta
salud.loc[((salud['atemed'] == 1) & ((salud['inst_1'] == 1) | 
           (salud['inst_2'] == 2) | (salud['inst_3'] == 3) | 
            (salud['inst_4'] == 4)) & (salud['inscr_6'] == 6) & 
             (salud['edad'] >= 12) & (~salud['edad'].isna())), 'smcv'] = 1 # S칤 cuenta

# Acceso directo a servicios de salud
salud['sa_dir'] = np.NaN
## Ocupaci칩n principal
salud.loc[((salud['tipo_trab1'] == 1) & (salud['smlab1'] == 1)), 'sa_dir'] = 1 # Con acceso
salud.loc[((salud['tipo_trab1'] == 2) & ((salud['smlab1'] == 1) | (salud['smcv'] == 1))), 'sa_dir'] = 1 # Con acceso
salud.loc[((salud['tipo_trab1'] == 3) & ((salud['smlab1'] == 1) | (salud['smcv'] == 1))), 'sa_dir'] = 1 # Con acceso

## Ocupaci칩n secundaria
salud.loc[((salud['tipo_trab2'] == 1) & (salud['smlab2'] == 1)), 'sa_dir'] = 1 # Con acceso
salud.loc[((salud['tipo_trab2'] == 2) & ((salud['smlab2'] == 1) | (salud['smcv'] == 1))), 'sa_dir'] = 1 # Con acceso
salud.loc[((salud['tipo_trab2'] == 3) & ((salud['smlab2'] == 1) | (salud['smcv'] == 1))), 'sa_dir'] = 1 # Con acceso
salud.loc[(salud['sa_dir'].isna()), 'sa_dir'] = 0 # Sin acceso

# N칰cleos familiares
salud['par'] = np.NaN
salud.loc[((salud['parentesco'] >= 100) & (salud['parentesco'] < 200)), 'par'] = 1 # Jefe o jefa del hogar
salud.loc[((salud['parentesco'] >= 200) & (salud['parentesco'] < 300)), 'par'] = 2 # C칩nyuge del  jefe/a
salud.loc[((salud['parentesco'] >= 300) & (salud['parentesco'] < 400)), 'par'] = 3 # Hijo del jefe/a
salud.loc[((salud['parentesco'] == 601)), 'par'] = 4 # Padre o Madre del jefe/a
salud.loc[((salud['parentesco'] == 615)), 'par'] = 5 # Suegro del jefe/a
salud.loc[(salud['par'].isna()), 'par'] = 6 # Sin acceso

# Asimismo, se utilizar치 la informaci칩n relativa a la asistencia a la escuela
salud['inas_esc'] = np.NaN
salud.loc[((salud['asis_esc'] == 1)), 'inas_esc'] = 0 # S칤 asiste
salud.loc[((salud['asis_esc'] == 2)), 'inas_esc'] = 1 # No asiste

# En primer lugar se identifican los principales parentescos respecto a la jefatura del hogar y si ese miembro cuenta con acceso directo
salud['jef'] = np.NaN
salud.loc[((salud['par'] == 1) & (salud['sa_dir'] == 1)), 'jef'] = 1
salud.loc[((((salud['inst_2'] == 2) | (salud['inst_3'] == 3)) & (salud['inscr_6'] == 6)) &
           ((salud['inst_1'].isna()) & (salud['inst_4'].isna()) & (salud['inst_6'].isna())) &
            ((salud['inscr_1'].isna()) & (salud['inscr_2'].isna()) & (salud['inscr_3'].isna()) &
             (salud['inscr_4'].isna()) & (salud['inscr_5'].isna()) & (salud['inscr_7'].isna()))), 'jef'] = np.NaN

salud['cony'] = np.NaN
salud.loc[((salud['par'] == 2) & (salud['sa_dir'] == 1)), 'cony'] = 1
salud.loc[((((salud['inst_2'] == 2) | (salud['inst_3'] == 3)) & (salud['inscr_6'] == 6)) &
           ((salud['inst_1'].isna()) & (salud['inst_4'].isna()) & (salud['inst_6'].isna())) &
            ((salud['inscr_1'].isna()) & (salud['inscr_2'].isna()) & (salud['inscr_3'].isna()) &
             (salud['inscr_4'].isna()) & (salud['inscr_5'].isna()) & (salud['inscr_7'].isna()))), 'cony'] = np.NaN

salud['hijo'] = np.NaN
salud.loc[((salud['par'] == 3) & (salud['sa_dir'] == 1)), 'hijo'] = 1
salud.loc[((((salud['inst_2'] == 2) | (salud['inst_3'] == 3)) & (salud['inscr_6'] == 6)) &
           ((salud['inst_1'].isna()) & (salud['inst_4'].isna()) & (salud['inst_6'].isna())) &
            ((salud['inscr_1'].isna()) & (salud['inscr_2'].isna()) & (salud['inscr_3'].isna()) &
             (salud['inscr_4'].isna()) & (salud['inscr_5'].isna()) & (salud['inscr_7'].isna()))), 'hijo'] = np.NaN

salud = salud.groupby(['folioviv', 'foliohog']).apply(lambda x: pd.Series({'jef_sa': x['jef'].sum(skipna = True),
                                                                           'cony_sa': x['cony'].sum(skipna = True),
                                                                           'hijo_sa': x['hijo'].sum(skipna = True)})).reset_index().merge(salud, on = ['folioviv', 'foliohog'])

salud.loc[(salud['jef_sa'] > 0), 'jef_sa'] = 1 # Acceso directo a servicios de salud de la jefatura del hogar
salud.loc[(salud['cony_sa'] > 0), 'cony_sa'] = 1 # Acceso directo a servicios de salud del c칩nyuge de la jefatura del hogar
salud.loc[(salud['hijo_sa'] > 0), 'hijo_sa'] = 1 # Acceso directo a servicios de salud de hijos(as) de la jefatura del hogar

# Otros n칰cleos familiares: se identifica a la poblaci칩n con acceso a servicios de salud mediante otros n칰cleos familiares a trav칠s de la 
# afiliaci칩n o inscripci칩n a servicios de salud por alg칰n familiar dentro o fuera del hogar, muerte del asegurado o por contrataci칩n propia; 

salud['s_salud'] = np.NaN
salud.loc[((~salud['pop_insabi'].isna()) & (~salud['atemed'].isna())), 's_salud'] = 0 # No cuenta
salud.loc[((salud['atemed'] == 1) & ((salud['inst_1'] == 1) | (salud['inst_2'] == 2) | (salud['inst_3'] == 3) | (salud['inst_4'] == 4)) &
           ((salud['inscr_3'] == 3) | (salud['inscr_4'] == 4) | (salud['inscr_6'] == 6) | (salud['inscr_7'] == 7))), 's_salud'] = 1 # S칤 cuenta

# Indicador de carencia por servicios de salud
# Indicador de carencia por acceso a los servicios de salud
salud['ic_asalud'] = np.NaN

## Acceso directo
salud.loc[((salud['sa_dir'] == 1)), 'ic_asalud'] = 0 

## Parentesco directo: jefatura
salud.loc[((salud['par'] == 1) & (salud['cony_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia
salud.loc[((salud['par'] == 1) & (salud['pea'] == 0) & (salud['hijo_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia

## Parentesco directo: c칩nyuge
salud.loc[((salud['par'] == 2) & (salud['jef_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia
salud.loc[((salud['par'] == 2) & (salud['pea'] == 0) & (salud['hijo_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia

## Parentesco directo: descendientes
salud.loc[((salud['par'] == 3) & (salud['edad'] < 16) & (salud['jef_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia
salud.loc[((salud['par'] == 3) & (salud['edad'] < 16) & (salud['cony_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia
salud.loc[((salud['par'] == 3) & (salud['edad'].between(16, 25)) & (salud['inas_esc'] == 0) & (salud['jef_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia
salud.loc[((salud['par'] == 3) & (salud['edad'].between(16, 25)) & (salud['inas_esc'] == 0) & (salud['cony_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia

## Parentesco directo: ascendientes
salud.loc[((salud['par'] == 4) & (salud['pea'] == 0) & (salud['jef_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia
salud.loc[((salud['par'] == 5) & (salud['pea'] == 0) & (salud['cony_sa'] == 1)), 'ic_asalud'] = 0 # No presenta carencia

## Otros n칰cleos familiares
salud.loc[((salud['s_salud'] == 1)), 'ic_asalud'] = 0 # No presenta carencia

## Acceso reportado
salud.loc[((salud['pop_insabi'] == 1) | 
           ((salud['pop_insabi'] == 2) & (salud['atemed'] == 1) & ((salud['inst_1'] == 1) | 
            (salud['inst_2'] == 2) | 
             (salud['inst_3'] == 3) | 
              (salud['inst_4'] == 4) | 
               (salud['inst_5'] == 5) | 
                (salud['inst_6'] == 6))) | 
                 (salud['segvol_2'] == 2)), 'ic_asalud'] = 0 # No presenta carencia
salud.loc[(salud['ic_asalud'].isna()), 'ic_asalud'] = 1 # Presenta carencia

# Poblaci칩n con presencia de discapacidad, sea f칤sica o mental
salud['discap'] = np.NaN
salud.loc[((salud['disc_camin'] == '3') | (salud['disc_camin'] == '4')), 'discap'] = 0 # Sin presencia de discapacidad
salud.loc[((salud['disc_ver'] == '3') | (salud['disc_ver'] == '4')), 'discap'] = 0 # Sin presencia de discapacidad
salud.loc[((salud['disc_brazo'] == '3') | (salud['disc_brazo'] == '4')), 'discap'] = 0 # Sin presencia de discapacidad
salud.loc[((salud['disc_apren'] == '3') | (salud['disc_apren'] == '4')), 'discap'] = 0 # Sin presencia de discapacidad
salud.loc[((salud['disc_oir'] == '3') | (salud['disc_oir'] == '4')), 'discap'] = 0 # Sin presencia de discapacidad
salud.loc[((salud['disc_vest'] == '3') | (salud['disc_vest'] == '4')), 'discap'] = 0 # Sin presencia de discapacidad
salud.loc[((salud['disc_habla'] == '3') | (salud['disc_habla'] == '4')), 'discap'] = 0 # Sin presencia de discapacidad
salud.loc[((salud['disc_acti'] == '3') | (salud['disc_acti'] == '4')), 'discap'] = 0 # Sin presencia de discapacidad
salud.loc[((salud['disc_camin'] == '&') | (salud['disc_ver'] == '&') |
          (salud['disc_brazo'] == '&') | (salud['disc_apren'] == '&') |
          (salud['disc_oir'] == '&') | (salud['disc_vest'] == '&') &
          (salud['disc_habla'] == '&') | (salud['disc_acti'] == '&')), 'discap'] = np.NaN # Sin presencia de discapacidad
salud.loc[((salud['disc_camin'] == '1') | (salud['disc_camin'] == '2')), 'discap'] = 1 # Con presencia de discapacidad
salud.loc[((salud['disc_ver'] == '1') | (salud['disc_ver'] == '2')), 'discap'] = 1 # Con presencia de discapacidad
salud.loc[((salud['disc_brazo'] == '1') | (salud['disc_brazo'] == '2')), 'discap'] = 1 # Con presencia de discapacidad
salud.loc[((salud['disc_apren'] == '1') | (salud['disc_apren'] == '2')), 'discap'] = 1 # Con presencia de discapacidad
salud.loc[((salud['disc_oir'] == '1') | (salud['disc_oir'] == '2')), 'discap'] = 1 # Con presencia de discapacidad
salud.loc[((salud['disc_vest'] == '1') | (salud['disc_vest'] == '2')), 'discap'] = 1 # Con presencia de discapacidad
salud.loc[((salud['disc_habla'] == '1') | (salud['disc_habla'] == '2')), 'discap'] = 1 # Con presencia de discapacidad
salud.loc[((salud['disc_acti'] == '1') | (salud['disc_acti'] == '2')), 'discap'] = 1 # Con presencia de discapacidad

salud = salud[['folioviv', 'foliohog', 'numren', 'sexo', 'pop_insabi', 'atemed', 'inst_1', 'inst_2', 'inst_3', 'inst_4', 'inst_5', 'inst_6', 
               'inscr_1', 'inscr_2', 'inscr_3', 'inscr_4', 'inscr_5', 'inscr_6', 'inscr_7', 'inscr_8', 'segvol_1', 'segvol_2', 'segvol_3', 
               'segvol_4', 'segvol_5', 'segvol_6', 'segvol_7', 'sa_dir', 'jef_sa', 'cony_sa', 'hijo_sa', 'ic_asalud', 'discap']]
```


```{python}
salud.to_csv(current_directory + '/Output/Data/' + '/ic_asalud22.csv', index = False)
```

##### Opci칩n 2  

```{python}
#del [[trabajos]] # Eliminamos el data.frame "trabajos" 
ocupados = pd.read_csv(current_directory + "/Bases de datos/trabajos.csv", low_memory = False)
```

```{python}
def indicador_ocupados(poblacion):
    def convert_to_numeric(df):
        cols_to_convert = ['subor', 'indep', 'tiene_suel', 'pago', 'id_trabajo']
        df[cols_to_convert] = df[cols_to_convert].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    def add_tipo_trab(df):
        df['tipo_trab'] = np.NaN
        df.loc[(df['subor'] == 1), 'tipo_trab'] = 1
        df.loc[(df['subor'] == 2) & (df['indep'] == 1) & (df['tiene_suel'] == 1), 'tipo_trab'] = 2
        df.loc[(df['subor'] == 2) & (df['indep'] == 2) & (df['pago'] == 1), 'tipo_trab'] = 2
        df.loc[(df['subor'] == 2) & (df['indep'] == 1) & (df['tiene_suel'] == 2), 'tipo_trab'] = 3
        df.loc[(df['subor'] == 2) & (df['indep'] == 2) & ((df['pago'] == 2) | (df['pago'] == 3)), 'tipo_trab'] = 3
        return df
    
    def add_ocupa(df):
        df['ocupa'] = np.NaN
        df.loc[df['id_trabajo'].isin([1, 2]), 'ocupa'] = 1
        return df
    
    def pivot_and_finalize(df):
        df = df[['folioviv', 'foliohog', 'numren', 'id_trabajo', 'tipo_trab', 'ocupa']]
        df = pd.pivot_table(df, index=['folioviv', 'foliohog', 'numren'], columns='id_trabajo', 
                            values=['tipo_trab', 'ocupa'], aggfunc = np.sum, fill_value=0)
        df.columns = [f'{i}{j}' for i, j in df.columns]
        df = df.reset_index()
        df['trab'] = 1
        df = df[['folioviv', 'foliohog', 'numren', 'trab'] + 
                [col for col in df.columns if col.startswith('tipo_trab') or col.startswith('ocupa')]]
        return df
    
    return (ocupados.copy()
                    .pipe(convert_to_numeric)
                    .pipe(add_tipo_trab)
                    .pipe(add_ocupa)
                    .pipe(pivot_and_finalize))

ocupados = indicador_ocupados(ocupados)
```

**Se guarda la base de datos** 
```{python}
ocupados.to_csv(current_directory + '/Output/Data/' + 'ocupados22_2.csv', index = False)
```

**Indicador de carencia por acceso a los servicios de salud** 

```{python}
def indicador_salud(poblacion):
  
    def filter_poblacion(df):
        return df.loc[~((df['parentesco'] >= 400) & (df['parentesco'] < 500) |
                         (df['parentesco'] >= 700) & (df['parentesco'] < 800))]
    
    def merge_ocupados(df, ocupados):
        return pd.merge(df, ocupados, 
                         on = ['folioviv', 'foliohog', 'numren'], 
                          how = 'left')
    def convert_to_numeric(df):
        columnas = ['parentesco', 'trab', 'edad', 'act_pnea1', 'act_pnea2', 'ocupa1', 'ocupa2', 'atemed', 
                    'inst_1', 'inst_2', 'inst_3', 'inst_4', 'inst_5', 'inst_6', 
                    'inscr_1', 'inscr_2', 'inscr_3', 'inscr_4', 'inscr_5', 'inscr_6', 
                    'inscr_7', 'asis_esc', 'pop_insabi', 'segvol_2']
        df[columnas] = df[columnas].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    def define_pea(df):
        df['pea'] = np.NaN
        df.loc[(df['trab'] == 1) & (df['edad'] >= 16) & (~df['edad'].isna()), 'pea'] = 1
        df.loc[((df['act_pnea1'] == 1) | (df['act_pnea2'] == 1)) & (df['edad'] >= 16) & (~df['edad'].isna()), 'pea'] = 2
        df.loc[((df['edad'] >= 16) & (~df['edad'].isna()) &
                   (((df['act_pnea1'] != 1) | (df['act_pnea1'].isna())) &
                    ((df['act_pnea2'] != 1) | (df['act_pnea2'].isna()))) &
                   (((df['act_pnea1'] >= 2) & (df['act_pnea1'] <= 6)) |
                    ((df['act_pnea2'] >= 2) & (df['act_pnea2'] <= 6)))), 'pea'] = 0
        return df
    
    def define_tipo_trab(df):
        df['tipo_trab1'] = np.where(df['pea'] == 1, df['tipo_trab1'], df['tipo_trab1'])
        df['tipo_trab1'] = np.where((df['pea'] == 0) | (df['pea'] == 2), np.NaN, df['tipo_trab1'])
        df['tipo_trab1'] = np.where(df['pea'].isna(), np.NaN, df['tipo_trab1'])
        df['tipo_trab2'] = np.where(df['pea'] == 1, df['tipo_trab2'], df['tipo_trab2'])
        df['tipo_trab2'] = np.where((df['pea'] == 0) | (df['pea'] == 2), np.NaN, df['tipo_trab2'])
        df['tipo_trab2'] = np.where(df['pea'].isna(), np.NaN, df['tipo_trab2'])
        return df
      
    def servicios_medicos_ocupacion_principal(df):
        df['smlab1'] = np.NaN
        df.loc[(df['ocupa1'] == 1), 'smlab1'] = 0
        df.loc[((df['ocupa1'] == 1) & (df['atemed'] == 1) &
                ((df['inst_1'] == 1) | (df['inst_2'] == 2) | 
                 (df['inst_3'] == 3) | (df['inst_4'] == 4)) & 
                  (df['inscr_1'] == 1)), 'smlab1'] = 1
        return df
    
    def servicios_medicos_ocupacion_secundaria(df):
        df['smlab2'] = np.NaN
        df.loc[(df['ocupa2'] == 1), 'smlab2'] = 0
        df.loc[(df['ocupa2'] == 1) & (df['atemed'] == 1) &
                ((df['inst_1'] == 1) | (df['inst_2'] == 2) | 
                  (df['inst_3'] == 3) | (df['inst_4'] == 4)) & 
                   (df['inscr_1'] == 1), 'smlab2'] = 1
        return df
    
    def contratacion_voluntaria_servicios_medicos(df):
        df['smcv'] = np.NaN
        df.loc[((df['edad'] >= 12) & (~df['edad'].isna())), 'smcv'] = 0
        df.loc[((df['atemed'] == 1) &
                ((df['inst_1'] == 1) | (df['inst_2'] == 2) | 
                  (df['inst_3'] == 3) | (df['inst_4'] == 4)) & 
                   (df['inscr_6'] == 6) & (df['edad'] >= 12) & 
                    (~df['edad'].isna())), 'smcv'] = 1
        return df
    
    def acceso_directo_servicios_salud(df):
        df['sa_dir'] = np.NaN
        # Ocupaci칩n principal 
        df.loc[((df['tipo_trab1'] == 1) & (df['smlab1'] == 1)), 'sa_dir'] = 1
        df.loc[((df['tipo_trab1'] == 2) & ((df['smlab1'] == 1) | (df['smcv'] == 1))), 'sa_dir'] = 1
        df.loc[((df['tipo_trab1'] == 3) & ((df['smlab1'] == 1) | (df['smcv'] == 1))), 'sa_dir'] = 1
        # Ocupaci칩n secundaria
        df.loc[((df['tipo_trab2'] == 1) & (df['smlab2'] == 1)), 'sa_dir'] = 1
        df.loc[((df['tipo_trab2'] == 2) & ((df['smlab2'] == 1) | (df['smcv'] == 1))), 'sa_dir'] = 1
        df.loc[((df['tipo_trab2'] == 3) & ((df['smlab2'] == 1) | (df['smcv'] == 1))), 'sa_dir'] = 1
        df.loc[(df['sa_dir'].isna()), 'sa_dir'] = 0
        return df
    
    def definir_nucleos_familiares(df):
        df['par'] = np.NaN
        df.loc[((df['parentesco'] >= 100) & (df['parentesco'] < 200)), 'par'] = 1
        df.loc[((df['parentesco'] >= 200) & (df['parentesco'] < 300)), 'par'] = 2
        df.loc[((df['parentesco'] >= 300) & (df['parentesco'] < 400)), 'par'] = 3
        df.loc[(df['parentesco'] == 601), 'par'] = 4
        df.loc[(df['parentesco'] == 615), 'par'] = 5
        df.loc[(df['par'].isna()), 'par'] = 6
        return df
      
    def asistencia_escuela(df):
        df['inas_esc'] = np.NaN
        df.loc[(df['asis_esc'] == 1), 'inas_esc'] = 0
        df.loc[(df['asis_esc'] == 2), 'inas_esc'] = 1
        return df
    
    def identificar_jefes_conyuges_hijos(df):
        df['jef'] = np.NaN
        df.loc[(df['par'] == 1) & (df['sa_dir'] == 1), 'jef'] = 1
        df.loc[((((df['inst_2'] == 2) | (df['inst_3'] == 3)) & (df['inscr_6'] == 6)) &
                ((df['inst_1'].isna()) & (df['inst_4'].isna()) & (df['inst_6'].isna())) &
                 ((df['inscr_1'].isna()) & (df['inscr_2'].isna()) & (df['inscr_3'].isna()) &
                  (df['inscr_4'].isna()) & (df['inscr_5'].isna()) & (df['inscr_7'].isna()))), 'jef'] = np.NaN
    
        df['cony'] = np.NaN
        df.loc[(df['par'] == 2) & (df['sa_dir'] == 1), 'cony'] = 1
        df.loc[((((df['inst_2'] == 2) | (df['inst_3'] == 3)) & (df['inscr_6'] == 6)) &
                ((df['inst_1'].isna()) & (df['inst_4'].isna()) & (df['inst_6'].isna())) &
                 ((df['inscr_1'].isna()) & (df['inscr_2'].isna()) & (df['inscr_3'].isna()) &
                  (df['inscr_4'].isna()) & (df['inscr_5'].isna()) & (df['inscr_7'].isna()))), 'cony'] = np.NaN
    
        df['hijo'] = np.NaN
        df.loc[(df['par'] == 3) & (df['sa_dir'] == 1), 'hijo'] = 1
        df.loc[((((df['inst_2'] == 2) | (df['inst_3'] == 3)) & (df['inscr_6'] == 6)) &
                ((df['inst_1'].isna()) & (df['inst_4'].isna()) & (df['inst_6'].isna())) &
                 ((df['inscr_1'].isna()) & (df['inscr_2'].isna()) & (df['inscr_3'].isna()) &
                  (df['inscr_4'].isna()) & (df['inscr_5'].isna()) & (df['inscr_7'].isna()))), 'hijo'] = np.NaN
        return df
    
    def calcular_acceso_servicios(df):
        df_agg = (df.groupby(['folioviv', 'foliohog']).apply(lambda x: pd.Series({'jef_sa': x['jef'].sum(skipna = True),
                                                                                  'cony_sa': x['cony'].sum(skipna = True),
                                                                                  'hijo_sa': x['hijo'].sum(skipna = True)})
                                                                                  ).reset_index())
        df = df_agg.merge(df, on=['folioviv', 'foliohog'])
        df.loc[df['jef_sa'] > 0, 'jef_sa'] = 1
        df.loc[df['cony_sa'] > 0, 'cony_sa'] = 1
        df.loc[df['hijo_sa'] > 0, 'hijo_sa'] = 1
        return df
    
    def acceso_servicios_salud(df):
        df['s_salud'] = np.NaN
        df.loc[(~df['pop_insabi'].isna()) & 
                (~df['atemed'].isna()), 's_salud'] = 0
        df.loc[(df['atemed'] == 1) & ((df['inst_1'] == 1) |
                (df['inst_2'] == 2) | 
                 (df['inst_3'] == 3) | (df['inst_4'] == 4)) & 
                  ((df['inscr_3'] == 3) | (df['inscr_4'] == 4) | 
                   (df['inscr_6'] == 6) | (df['inscr_7'] == 7)), 's_salud'] = 1
        return df
    
    def indicador_carencia_acceso_salud(df):
        df['ic_asalud'] = np.NaN
    
        # Acceso directo
        df.loc[(df['sa_dir'] == 1), 'ic_asalud'] = 0 
    
        # Parentesco directo: jefatura
        df.loc[(df['par'] == 1) & (df['cony_sa'] == 1), 'ic_asalud'] = 0
        df.loc[(df['par'] == 1) & (df['pea'] == 0) & (df['hijo_sa'] == 1), 'ic_asalud'] = 0
    
        # Parentesco directo: c칩nyuge
        df.loc[(df['par'] == 2) & (df['jef_sa'] == 1), 'ic_asalud'] = 0
        df.loc[(df['par'] == 2) & (df['pea'] == 0) & (df['hijo_sa'] == 1), 'ic_asalud'] = 0
    
        # Parentesco directo: descendientes
        df.loc[(df['par'] == 3) & (df['edad'] < 16) & (df['jef_sa'] == 1), 'ic_asalud'] = 0
        df.loc[(df['par'] == 3) & (df['edad'] < 16) & (df['cony_sa'] == 1), 'ic_asalud'] = 0
        df.loc[(df['par'] == 3) & (df['edad'].between(16, 25)) & (df['inas_esc'] == 0) & (df['jef_sa'] == 1), 'ic_asalud'] = 0
        df.loc[(df['par'] == 3) & (df['edad'].between(16, 25)) & (df['inas_esc'] == 0) & (df['cony_sa'] == 1), 'ic_asalud'] = 0
    
        # Parentesco directo: ascendientes
        df.loc[(df['par'] == 4) & (df['pea'] == 0) & (df['jef_sa'] == 1), 'ic_asalud'] = 0
        df.loc[(df['par'] == 5) & (df['pea'] == 0) & (df['cony_sa'] == 1), 'ic_asalud'] = 0
    
        # Otros n칰cleos familiares
        df.loc[(df['s_salud'] == 1), 'ic_asalud'] = 0
    
        # Acceso reportado
        df.loc[(df['pop_insabi'] == 1) | ((df['pop_insabi'] == 2) & (df['atemed'] == 1) & 
                                          ((df['inst_1'] == 1) | (df['inst_2'] == 2) | (df['inst_3'] == 3) | 
                                           (df['inst_4'] == 4) | (df['inst_5'] == 5) | (df['inst_6'] == 6))) | 
                                            (df['segvol_2'] == 2), 'ic_asalud'] = 0
        df.loc[df['ic_asalud'].isna(), 'ic_asalud'] = 1
        return df
    
    def presencia_discapacidad(df):
        df['discap'] = np.NaN
        df.loc[(df['disc_camin'] == '3') | (df['disc_camin'] == '4'), 'discap'] = 0
        df.loc[(df['disc_ver'] == '3') | (df['disc_ver'] == '4'), 'discap'] = 0
        df.loc[(df['disc_brazo'] == '3') | (df['disc_brazo'] == '4'), 'discap'] = 0
        df.loc[(df['disc_apren'] == '3') | (df['disc_apren'] == '4'), 'discap'] = 0
        df.loc[(df['disc_oir'] == '3') | (df['disc_oir'] == '4'), 'discap'] = 0
        df.loc[(df['disc_vest'] == '3') | (df['disc_vest'] == '4'), 'discap'] = 0
        df.loc[(df['disc_habla'] == '3') | (df['disc_habla'] == '4'), 'discap'] = 0
        df.loc[(df['disc_acti'] == '3') | (df['disc_acti'] == '4'), 'discap'] = 0
        df.loc[(df['disc_camin'] == '&') | (df['disc_ver'] == '&') |
                (df['disc_brazo'] == '&') | (df['disc_apren'] == '&') |
                 (df['disc_oir'] == '&') | (df['disc_vest'] == '&') &
                  (df['disc_habla'] == '&') | (df['disc_acti'] == '&'), 'discap'] = np.NaN
        df.loc[(df['disc_camin'] == '1') | (df['disc_camin'] == '2'), 'discap'] = 1
        df.loc[(df['disc_ver'] == '1') | (df['disc_ver'] == '2'), 'discap'] = 1
        df.loc[(df['disc_brazo'] == '1') | (df['disc_brazo'] == '2'), 'discap'] = 1
        df.loc[(df['disc_apren'] == '1') | (df['disc_apren'] == '2'), 'discap'] = 1
        df.loc[(df['disc_oir'] == '1') | (df['disc_oir'] == '2'), 'discap'] = 1
        df.loc[(df['disc_vest'] == '1') | (df['disc_vest'] == '2'), 'discap'] = 1
        df.loc[(df['disc_habla'] == '1') | (df['disc_habla'] == '2'), 'discap'] = 1
        df.loc[(df['disc_acti'] == '1') | (df['disc_acti'] == '2'), 'discap'] = 1
        return df
    
    def seleccionar_columnas(df):
        columnas = ['folioviv', 'foliohog', 'numren', 'sexo', 'pop_insabi', 'atemed', 'inst_1', 'inst_2', 'inst_3', 'inst_4', 
                    'inst_5', 'inst_6', 'inscr_1', 'inscr_2', 'inscr_3', 'inscr_4', 'inscr_5', 'inscr_6', 'inscr_7', 'inscr_8', 
                    'segvol_1', 'segvol_2', 'segvol_3', 'segvol_4', 'segvol_5', 'segvol_6', 'segvol_7', 'sa_dir', 'jef_sa', 
                    'cony_sa', 'hijo_sa', 'ic_asalud', 'discap']
        return df[columnas]
      
    return (poblacion.copy()
                     .pipe(filter_poblacion)
                     .pipe(merge_ocupados, ocupados)
                     .pipe(convert_to_numeric)
                     .pipe(define_pea)
                     .pipe(define_tipo_trab)
                     .pipe(servicios_medicos_ocupacion_principal)
                     .pipe(servicios_medicos_ocupacion_secundaria)
                     .pipe(contratacion_voluntaria_servicios_medicos)
                     .pipe(acceso_directo_servicios_salud)
                     .pipe(definir_nucleos_familiares)
                     .pipe(asistencia_escuela)
                     .pipe(identificar_jefes_conyuges_hijos)
                     .pipe(calcular_acceso_servicios)
                     .pipe(acceso_servicios_salud)
                     .pipe(indicador_carencia_acceso_salud)
                     .pipe(presencia_discapacidad)
                     .pipe(seleccionar_columnas))

# Indiccador de salud
salud = indicador_salud(poblacion)
```

**Se guarda la base de datos** 
```{python}
salud.to_csv(current_directory + '/Output/Data/' + 'ic_asalud22_2.csv', index = False)
```

#### III. Indicador de carencia por acceso a la seguridad social {.tabset .tabset-pills .top3-tiles}  

```{python}
# Prestaciones laborales
trabajos = pd.read_csv(current_directory + "/Bases de datos/trabajos.csv", low_memory = False) 
```

##### Opci칩n 1 {.tabset .tabset-pills .top4-tiles} 

###### Prestaciones laborales

```{python}
prestaciones = trabajos.copy()

#Convirtiendo variables string a numericas
prestaciones[['subor', 'indep', 'tiene_suel', 'pago', 'pres_8', 'id_trabajo']] = prestaciones[['subor', 'indep', 'tiene_suel', 'pago', 'pres_8', 'id_trabajo']
                                                                                             ].apply(pd.to_numeric, errors = 'coerce')

# Tipo de trabajador: identifica la poblaci칩n subordinada e independiente
prestaciones['tipo_trab'] = np.NaN
## Subordinados
prestaciones.loc[(prestaciones['subor'] == 1), 'tipo_trab'] = 1

## Independientes que reciben un pago
prestaciones.loc[((prestaciones['subor'] == 2) & (prestaciones['indep'] == 1) & (prestaciones['tiene_suel'] == 1)), 'tipo_trab'] = 2
prestaciones.loc[((prestaciones['subor'] == 2) & (prestaciones['indep'] == 2) & (prestaciones['pago'] == 1)), 'tipo_trab'] = 2

## Independientes que no reciben un pago
prestaciones.loc[((prestaciones['subor'] == 2) & (prestaciones['indep'] == 1) & (prestaciones['tiene_suel'] == 2)), 'tipo_trab'] = 3
prestaciones.loc[((prestaciones['subor'] == 2) & (prestaciones['indep'] == 2) & ((prestaciones['pago'] == 2) | (prestaciones['pago'] == 3))), 'tipo_trab'] = 3
 

# Ahorro para el retiro o pensi칩n para la vejez (SAR, Afore)
prestaciones['aforlab'] = np.NaN
prestaciones.loc[(prestaciones['pres_8'].isna()), 'aforlab'] = 0 
prestaciones.loc[(prestaciones['pres_8'] == 8), 'aforlab'] = 1 

# Ocupaci칩n principal o secundaria
prestaciones['ocupa'] = np.NaN
prestaciones.loc[(prestaciones['id_trabajo'] == 1), 'ocupa'] = 1 
prestaciones.loc[(prestaciones['id_trabajo'] == 2), 'ocupa'] = 1 

# Distinci칩n de prestaciones en trabajo principal y secundario
prestaciones = prestaciones[['folioviv', 'foliohog', 'numren', 'id_trabajo', 'tipo_trab', 'aforlab', 'ocupa']]

prestaciones = pd.pivot_table(prestaciones, 
                               index = ['folioviv', 'foliohog', 'numren'], 
                                columns = 'id_trabajo', 
                                 values = ['tipo_trab', 'aforlab', 'ocupa'], 
                                  aggfunc = np.sum, 
                                   fill_value = 0)
prestaciones.columns = [f'{i}{j}' for i, j in prestaciones.columns]
prestaciones = prestaciones.reset_index()

#Identificaci칩n de la poblaci칩n trabajadora (toda la que reporta al menos un empleo en la base de trabajos.csv)
prestaciones['trab'] = 1
prestaciones = prestaciones[['folioviv', 'foliohog', 'numren', 'trab', 'tipo_trab1', 'tipo_trab2', 'aforlab1', 'aforlab2', 'ocupa1', 'ocupa2']]
```

**Se guarda la base de datos** 
```{python}
prestaciones.to_csv(current_directory + '/Output/Data/' + '/prestaciones22.csv', index = False)
```

###### Ingresos por jubilaciones o pensiones

```{python}
# Ingresos por jubilaciones o pensiones
pensiones = pd.read_csv(current_directory + "/Bases de datos/ingresos.csv", low_memory = False)

pensiones = pensiones[((pensiones['clave'] == 'P032') | (pensiones['clave'] == 'P033') | 
                       (pensiones['clave'] == 'P104') | (pensiones['clave'] == 'P045'))]
```


```{python}
# Definici칩n de los deflactores 2022 
dic21 =	0.9475376203	
ene22 =	0.9531433002
feb22 =	0.9610510246	
mar22 =	0.9705661414	
abr22 =	0.9758164180	
may22 =	0.9775368933
jun22 =	0.9857919437	
jul22 =	0.9930938669
ago22 =	1.0000000000
sep22 =	1.0062034038
oct22 =	1.0118979346
nov22 =	1.0177217030
dic22 =	1.0216069077
```

```{python}
#Convirtiendo variables string a numericas
pensiones[['mes_1', 'mes_2', 'mes_3', 'mes_4', 'mes_5', 'mes_6', 'ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']
          ] = pensiones[['mes_1', 'mes_2', 'mes_3', 'mes_4', 'mes_5', 'mes_6', 'ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']].apply(pd.to_numeric, errors = 'coerce')
          
# Se deflactan los ingresos por jubilaciones, pensionesiones y programas de adultos mayores de acuerdo con el mes de levantamiento
pensiones['ing_6'] = np.where(pensiones['mes_6'].isna(), pensiones['ing_6'] ,
                      np.where(pensiones['mes_6'] == 2, pensiones['ing_6'] / feb22,
                       np.where(pensiones['mes_6'] == 3, pensiones['ing_6'] / mar22,
                        np.where(pensiones['mes_6'] == 4, pensiones['ing_6'] / abr22,
                         pensiones['ing_6'] / may22))))
pensiones['ing_5'] = np.where(pensiones['mes_5'].isna(), pensiones['ing_5'] ,
                      np.where(pensiones['mes_5'] == 3, pensiones['ing_5'] / mar22,
                       np.where(pensiones['mes_5'] == 4, pensiones['ing_5'] / abr22,
                        np.where(pensiones['mes_5'] == 5, pensiones['ing_5'] / may22,
                         pensiones['ing_5'] / jun22))))
pensiones['ing_4'] = np.where(pensiones['mes_4'].isna(), pensiones['ing_4'] ,
                      np.where(pensiones['mes_4'] == 4, pensiones['ing_4'] / abr22,
                       np.where(pensiones['mes_4'] == 5, pensiones['ing_4'] / may22,
                        np.where(pensiones['mes_4'] == 6, pensiones['ing_4'] / jun22,
                         pensiones['ing_4'] / jul22 ))))
pensiones['ing_3'] = np.where(pensiones['mes_3'].isna(), pensiones['ing_3'] ,
                      np.where(pensiones['mes_3'] == 5, pensiones['ing_3'] / may22,
                       np.where(pensiones['mes_3'] == 6, pensiones['ing_3'] / jun22,
                        np.where(pensiones['mes_3'] == 7, pensiones['ing_3'] / jul22,
                         pensiones['ing_3'] / ago22))))
pensiones['ing_2'] = np.where(pensiones['mes_2'].isna(), pensiones['ing_2'] ,
                      np.where(pensiones['mes_2'] == 6, pensiones['ing_2'] / jun22,
                       np.where(pensiones['mes_2'] == 7, pensiones['ing_2'] / jul22,
                        np.where(pensiones['mes_2'] == 8, pensiones['ing_2'] / ago22,
                         pensiones['ing_2'] / sep22))))
pensiones['ing_1'] = np.where(pensiones['mes_1'].isna(), pensiones['ing_1'] ,
                      np.where(pensiones['mes_1'] == 7, pensiones['ing_1'] / jul22,
                       np.where(pensiones['mes_1'] == 8, pensiones['ing_1'] / ago22,
                        np.where(pensiones['mes_1'] == 9, pensiones['ing_1'] / sep22,
                         pensiones['ing_1'] / oct22 ))))

# Ingreso promedio mensual por programas de adultos mayores
pensiones['ing_pam'] = np.where((pensiones['clave'] == 'P104') | (pensiones['clave'] == 'P045'),
                                  np.apply_along_axis(np.mean, 1, pensiones[['ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']]), 0)
# Ingreso promedio mensual por jubilaciones y pensiones
pensiones['ing_pens'] = np.where((pensiones['clave'] == 'P032') | (pensiones['clave'] == 'P033'),
                                   np.apply_along_axis(np.mean, 1, pensiones[['ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']]), 0)

pensiones = pensiones.groupby(['folioviv', 'foliohog', 'numren'])[['ing_pens', 'ing_pam']].sum(numeric_only = True)
pensiones = pensiones.reset_index()
```


**Se guarda la base de datos** 
```{python}
pensiones.to_csv(current_directory + '/Output/Data/' + '/pensiones22.csv', index = False)
```


###### Construcci칩n del indicador

**Indicador de carencia por acceso a la seguridad social** 

Se encuentra en situaci칩n de carencia por acceso a la seguridad social a la poblaci칩n que:    
1. No disponga de acceso directo a la seguridad social.   
2. No cuente con parentesco directo con alguna persona dentro del hogar que tenga acceso directo.    
3. No recibe servicios m칠dicos por parte de alg칰n familiar dentro o fuera del hogar, por muerte del asegurado o por contrataci칩n propia.  
4. No recibe ingreso por parte de un programa de adultos mayores donde el monto sea mayor o igual al valor promedio de la canasta alimentaria rural y urbana.    

```{python}
# Valor monetario de las l칤neas de pobreza extrema por ingresos rural y urbana
lp1_urb = 2086.21
lp1_rur = 1600.18
lp_pam = (lp1_urb + lp1_rur)/2
```

 
 
```{python}
# Construcci칩n del indicador
seguridad_social = poblacion.copy()

# Poblaci칩n objetivo: no se incluye a hu칠spedes ni trabajadores dom칠sticos
seguridad_social = seguridad_social[~((seguridad_social['parentesco'] >= 400) & (seguridad_social['parentesco'] < 500) |
                   (seguridad_social['parentesco'] >= 700) & (seguridad_social['parentesco'] < 800))]

# Integraci칩n de bases
seguridad_social = pd.merge(seguridad_social, prestaciones, 
                             on = ['folioviv', 'foliohog', 'numren'], 
                              how = 'left')
seguridad_social = pd.merge(seguridad_social, pensiones, 
                    on = ['folioviv', 'foliohog', 'numren'], 
                     how = 'left')

#Convirtiendo variables string a numericas
seguridad_social[['parentesco', 'trab', 'edad', 'act_pnea1', 'act_pnea2','ocupa1', 'atemed', 'trabajo_mp',
                  'inst_1', 'inst_2', 'inst_3', 'inst_4', 'inst_5', 'inst_6', 'inscr_1', 'inscr_2', 'inscr_3', 
                  'inscr_4', 'inscr_5', 'inscr_6', 'inscr_7', 'asis_esc', 'pop_insabi', 'segvol_1']
                 ] = seguridad_social[['parentesco', 'trab', 'edad', 'act_pnea1', 'act_pnea2','ocupa1', 'atemed', 'trabajo_mp',
                                       'inst_1', 'inst_2', 'inst_3', 'inst_4', 'inst_5', 'inst_6', 'inscr_1', 'inscr_2', 'inscr_3', 
                                       'inscr_4', 'inscr_5', 'inscr_6', 'inscr_7', 'asis_esc', 'pop_insabi', 'segvol_1']].apply(pd.to_numeric, errors = 'coerce')

# PEA (personas de 16 a침os o m치s)
seguridad_social['pea'] = np.NaN
seguridad_social.loc[(seguridad_social['trab'] == 1) & (seguridad_social['edad'] >= 16) & 
                      (~seguridad_social['edad'].isna()), 'pea'] = 1 # PEA: ocupada
seguridad_social.loc[((seguridad_social['act_pnea1'] == 1) | (seguridad_social['act_pnea2'] == 1)) & 
                      (seguridad_social['edad'] >= 16) & (~seguridad_social['edad'].isna()), 'pea'] = 2 # PEA: desocupada
seguridad_social.loc[((seguridad_social['edad'] >= 16) & (~seguridad_social['edad'].isna()) &
                      (((seguridad_social['act_pnea1'] != 1) | (seguridad_social['act_pnea1'].isna())) &
                       ((seguridad_social['act_pnea2'] != 1) | (seguridad_social['act_pnea2'].isna()))) &
                        (((seguridad_social['act_pnea1'] >= 2) & (seguridad_social['act_pnea1'] <= 6)) |
                         ((seguridad_social['act_pnea2'] >= 2) & (seguridad_social['act_pnea2'] <= 6)))), 'pea'] = 0 # PNEA

# Acceso directo a la seguridad social
## Ocupaci칩n principal
seguridad_social['tipo_trab1'] = np.where(seguridad_social['pea'] == 1, 
                                           seguridad_social['tipo_trab1'], 
                                            seguridad_social['tipo_trab1']) # Depende de un patr칩n, jefe o superior 
seguridad_social['tipo_trab1'] = np.where((seguridad_social['pea'] == 0) | (seguridad_social['pea'] == 2), 
                                            np.NaN, 
                                             seguridad_social['tipo_trab1']) # No depende de un jefe y recibe o tiene asignado un sueldo
seguridad_social['tipo_trab1'] = np.where(seguridad_social['pea'].isna(), 
                                           np.NaN, 
                                            seguridad_social['tipo_trab1']) # No depende de un jefe y no recibe o no tiene asignado un sueldo
## Ocupaci칩n secundaria
seguridad_social['tipo_trab2'] = np.where(seguridad_social['pea'] == 1, 
                                           seguridad_social['tipo_trab2'], 
                                            seguridad_social['tipo_trab2']) # Depende de un patr칩n, jefe o superior
seguridad_social['tipo_trab2'] = np.where((seguridad_social['pea'] == 0) | (seguridad_social['pea'] == 2), 
                                            np.NaN, 
                                             seguridad_social['tipo_trab2']) # No depende de un jefe y recibe o tiene asignado un sueldo
seguridad_social['tipo_trab2'] = np.where(seguridad_social['pea'].isna(), 
                                           np.NaN, 
                                            seguridad_social['tipo_trab2']) # No depende de un jefe y no recibe o no tiene asignado un sueldo
## Jubilados y pensionados
seguridad_social['jub'] = np.NaN
seguridad_social.loc[((seguridad_social['trabajo_mp'] == 2) & ((seguridad_social['act_pnea1'] == 2) | 
                      (seguridad_social['act_pnea2'] == 2))), 'jub'] = 1 # Poblaci칩n pensionada o jubilada
seguridad_social.loc[((seguridad_social['ing_pens'] > 0) & (~seguridad_social['ing_pens'].isna())), 'jub'] = 1 # Poblaci칩n pensionada o jubilada
seguridad_social.loc[(seguridad_social['inscr_2'] == 2), 'jub'] = 1 # Poblaci칩n pensionada o jubilada
seguridad_social.loc[(seguridad_social['jub'].isna()), 'jub'] = 0 # Poblaci칩n no pensionada o jubilada

# Prestaciones b치sicas

# Prestaciones laborales (Servicios m칠dicos)
## Ocupaci칩n principal
seguridad_social['smlab1'] = np.NaN
seguridad_social.loc[(seguridad_social['ocupa1'] == 1), 'smlab1'] = 0 # Con servicios m칠dicos
seguridad_social.loc[((seguridad_social['ocupa1'] == 1) & (seguridad_social['atemed'] == 1) & 
                      ((seguridad_social['inst_1'] == 1) | (seguridad_social['inst_2'] == 2) | 
                       (seguridad_social['inst_3'] == 3) | (seguridad_social['inst_4'] == 4)) & 
                        (seguridad_social['inscr_1'] == 1)), 'smlab1'] = 1 # Sin servicios m칠dicos
## Ocupaci칩n secundaria
seguridad_social['smlab2'] = np.NaN
seguridad_social.loc[(seguridad_social['ocupa2'] == 1), 'smlab2'] = 0 # Con servicios m칠dicos
seguridad_social.loc[((seguridad_social['ocupa2'] == 1) & (seguridad_social['atemed'] == 1) & 
                      ((seguridad_social['inst_1'] == 1) | (seguridad_social['inst_2'] == 2) | 
                       (seguridad_social['inst_3'] == 3) | (seguridad_social['inst_4'] == 4)) & 
                        (seguridad_social['inscr_1'] == 1)), 'smlab2'] = 1 # Sin servicios m칠dicos

# Contrataci칩n voluntaria: servicios m칠dicos y ahorro para el retiro o pensi칩n para la vejez (SAR, Afore, Haber de retiro)
## Servicios m칠dicos
seguridad_social['smcv'] = np.NaN
seguridad_social.loc[((seguridad_social['edad'] >= 12) & (~seguridad_social['edad'].isna())), 'smcv'] = 0 # No cuenta
seguridad_social.loc[((seguridad_social['atemed'] == 1) & ((seguridad_social['inst_1'] == 1) |
                      (seguridad_social['inst_2'] == 2) | (seguridad_social['inst_3'] == 3) |
                       (seguridad_social['inst_4'] == 4)) & (seguridad_social['inscr_6'] == 6) & 
                        ((seguridad_social['edad'] >= 12) & (~seguridad_social['edad'].isna()))), 'smcv'] = 1 # S칤 cuenta
                        
## SAR o Afore
seguridad_social['aforecv'] = np.NaN              
seguridad_social.loc[((seguridad_social['segvol_1'].isna()) & ((seguridad_social['edad'] >= 12) & 
                      (~seguridad_social['edad'].isna()))), 'aforecv'] = 0 # No cuenta    
seguridad_social.loc[((seguridad_social['segvol_1'] == 1) & ((seguridad_social['edad'] >= 12) & 
                      (~seguridad_social['edad'].isna()))), 'aforecv'] = 1 # S칤 cuenta 
                      
## Acceso directo a la seguridad social
seguridad_social['ss_dir'] = np.NaN
seguridad_social.loc[(seguridad_social['ss_dir'].isna()), 'ss_dir'] = 0 # Sin acceso

## Ocupaci칩n principal
seguridad_social.loc[((seguridad_social['tipo_trab1'] == 1) & (seguridad_social['smlab1'] == 1)), 'ss_dir'] = 1 # Con acceso
seguridad_social.loc[((seguridad_social['tipo_trab1'] == 2) & ((seguridad_social['smlab1'] == 1) |
                      (seguridad_social['smcv'] == 1)) & ((seguridad_social['aforlab1'] == 1) | 
                       (seguridad_social['aforecv'] == 1))), 'ss_dir'] = 1 # Con acceso
seguridad_social.loc[((seguridad_social['tipo_trab1'] == 3) & ((seguridad_social['smlab1'] == 1) | 
                       (seguridad_social['smcv'] == 1)) & (seguridad_social['aforecv'] == 1)), 'ss_dir'] = 1 # Con acceso

## Ocupaci칩n secundaria
seguridad_social.loc[((seguridad_social['tipo_trab2'] == 1) & (seguridad_social['smlab2'] == 1)), 'ss_dir'] = 1 # Con acceso
seguridad_social.loc[((seguridad_social['tipo_trab2'] == 2) & ((seguridad_social['smlab2'] == 1) | 
                      (seguridad_social['smcv'] == 1)) & ((seguridad_social['aforlab2'] == 1) | 
                       (seguridad_social['aforecv'] == 1))), 'ss_dir'] = 1 # Con acceso
seguridad_social.loc[((seguridad_social['tipo_trab2'] == 3) & ((seguridad_social['smlab2'] == 1) | 
                       (seguridad_social['smcv'] == 1)) & (seguridad_social['aforecv'] == 1)), 'ss_dir'] = 1 # Con acceso   

## Jubilados y pensionados
seguridad_social.loc[(seguridad_social['jub'] == 1), 'ss_dir'] = 1 # Con acceso 

## N칰cleos familiares   
seguridad_social['par'] = np.NaN
seguridad_social.loc[((seguridad_social['parentesco'] >= 100) & (seguridad_social['parentesco'] < 200)), 'par'] = 1 # Jefe o jefa del hogar
seguridad_social.loc[((seguridad_social['parentesco'] >= 200) & (seguridad_social['parentesco'] < 300)), 'par'] = 2 # C칩nyuge del  jefe/a
seguridad_social.loc[((seguridad_social['parentesco'] >= 300) & (seguridad_social['parentesco'] < 400)), 'par'] = 3 # Hijo del jefe/a
seguridad_social.loc[((seguridad_social['parentesco'] == 601)), 'par'] = 4 # Padre o Madre del jefe/a
seguridad_social.loc[((seguridad_social['parentesco'] == 615)), 'par'] = 5 # Suegro del jefe/a
seguridad_social.loc[(seguridad_social['par'].isna()), 'par'] = 6 # Sin acceso

# Asimismo, se utilizar치 la informaci칩n relativa a la asistencia a la escuela
seguridad_social['inas_esc'] = np.NaN
seguridad_social.loc[((seguridad_social['asis_esc'] == 1)), 'inas_esc'] = 0 # S칤 asiste
seguridad_social.loc[((seguridad_social['asis_esc'] == 2)), 'inas_esc'] = 1 # No asiste

# En primer lugar se identifican los principales parentescos respecto a la jefatura del hogar y si ese miembro cuenta con acceso directo
seguridad_social['jef'] = np.NaN
seguridad_social.loc[((seguridad_social['par'] == 1) & (seguridad_social['ss_dir'] == 1)), 'jef'] = 1
seguridad_social.loc[((((seguridad_social['inst_2'] == 2) | (seguridad_social['inst_3'] == 3)) & (seguridad_social['inscr_6'] == 6)) & 
                      ((seguridad_social['inst_1'].isna()) & (seguridad_social['inst_4'].isna()) & (seguridad_social['inst_6'].isna())) &
                       ((seguridad_social['inscr_1'].isna()) & (seguridad_social['inscr_2'].isna()) & (seguridad_social['inscr_3'].isna()) &
                        (seguridad_social['inscr_4'].isna()) & (seguridad_social['inscr_5'].isna()) & (seguridad_social['inscr_7'].isna()))), 'jef'] = np.NaN

seguridad_social['cony'] = np.NaN
seguridad_social.loc[((seguridad_social['par'] == 2) & (seguridad_social['ss_dir'] == 1)), 'cony'] = 1
seguridad_social.loc[((((seguridad_social['inst_2'] == 2) | (seguridad_social['inst_3'] == 3)) & (seguridad_social['inscr_6'] == 6)) &
                      ((seguridad_social['inst_1'].isna()) & (seguridad_social['inst_4'].isna()) & (seguridad_social['inst_6'].isna())) &
                       ((seguridad_social['inscr_1'].isna()) & (seguridad_social['inscr_2'].isna()) & (seguridad_social['inscr_3'].isna()) &
                        (seguridad_social['inscr_4'].isna()) & (seguridad_social['inscr_5'].isna()) & (seguridad_social['inscr_7'].isna()))), 'cony'] = np.NaN

seguridad_social['hijo'] = np.NaN
seguridad_social.loc[((seguridad_social['par'] == 3) & (seguridad_social['ss_dir'] == 1) & (seguridad_social['jub'] == 1) & 
                      ((seguridad_social['edad'] > 25) & (~seguridad_social['edad'].isna()))), 'hijo'] = 1
seguridad_social.loc[((seguridad_social['par'] == 3) & (seguridad_social['ss_dir'] == 1) & (seguridad_social['jub'] == 0)), 'hijo'] = 1
seguridad_social.loc[((((seguridad_social['inst_2'] == 2) | (seguridad_social['inst_3'] == 3)) & (seguridad_social['inscr_6'] == 6)) &
                      ((seguridad_social['inst_1'].isna()) & (seguridad_social['inst_4'].isna()) & (seguridad_social['inst_6'].isna())) &
                       ((seguridad_social['inscr_1'].isna()) & (seguridad_social['inscr_2'].isna()) & (seguridad_social['inscr_3'].isna()) &
                        (seguridad_social['inscr_4'].isna()) & (seguridad_social['inscr_5'].isna()) & (seguridad_social['inscr_7'].isna()))), 'hijo'] = np.NaN

seguridad_social = seguridad_social.groupby(['folioviv', 'foliohog']
                                           ).apply(lambda x: pd.Series({'jef_ss': x['jef'].sum(skipna=True),
                                                                        'cony_ss': x['cony'].sum(skipna=True),
                                                                        'hijo_ss': x['hijo'].sum(skipna=True)})
                                                                      ).reset_index().merge(seguridad_social, 
                                                                                             on = ['folioviv', 'foliohog'])

seguridad_social.loc[(seguridad_social['jef_ss'] > 0), 'jef_ss'] = 1 # Acceso directo a servicios de salud de la jefatura del hogar
seguridad_social.loc[(seguridad_social['cony_ss'] > 0), 'cony_ss'] = 1 # Acceso directo a servicios de salud del c칩nyuge de la jefatura del hogar
seguridad_social.loc[(seguridad_social['hijo_ss'] > 0), 'hijo_ss'] = 1 # Acceso directo a servicios de salud de hijos(as) de la jefatura del hogar

# Otros n칰cleos familiares: se identifica a la poblaci칩n con acceso a la seguridad social mediante otros n칰cleos familiares a trav칠s de la afiliaci칩n o inscripci칩n 
#a servicios de salud por alg칰n familiar dentro o fuera del hogar, muerte del asegurado o por contrataci칩n propia.

seguridad_social['s_salud'] = np.NaN
seguridad_social.loc[((~seguridad_social['pop_insabi'].isna()) & (~seguridad_social['atemed'].isna())), 's_salud'] = 0 # Sin acceso
seguridad_social.loc[((seguridad_social['atemed'] == 1) & ((seguridad_social['inst_1'] == 1) |
                      (seguridad_social['inst_2'] == 2) | (seguridad_social['inst_3'] == 3) | 
                       (seguridad_social['inst_4'] == 4)) & ((seguridad_social['inscr_3'] == 3) | 
                        (seguridad_social['inscr_4'] == 4) | (seguridad_social['inscr_6'] == 6) | 
                         (seguridad_social['inscr_7'] == 7))), 's_salud'] = 1 # Con acceso

# Programas sociales de pensiones para adultos mayores
seguridad_social['pam'] = np.NaN
seguridad_social.loc[((seguridad_social['edad'] >= 65) & (~seguridad_social['edad'].isna())), 'pam'] = 0 # No recibe
seguridad_social.loc[((seguridad_social['edad'] >= 65) & (~seguridad_social['edad'].isna()) & 
                      (seguridad_social['ing_pam'] >= lp_pam) & (~seguridad_social['ing_pam'].isna())), 'pam'] = 1 # Recibe

#Indicador de carencia por acceso a la seguridad social
seguridad_social['ic_segsoc'] = np.NaN
## Acceso directo
seguridad_social.loc[(seguridad_social['ss_dir'] == 1), 'ic_segsoc'] = 0 # No presenta carencia

## Parentesco directo: jefatura
seguridad_social.loc[((seguridad_social['par'] == 1) & (seguridad_social['cony_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia
seguridad_social.loc[((seguridad_social['par'] == 1) & (seguridad_social['pea'] == 0) & 
                      (seguridad_social['hijo_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia

## Parentesco directo: c칩nyuge
seguridad_social.loc[((seguridad_social['par'] == 2) & (seguridad_social['jef_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia
seguridad_social.loc[((seguridad_social['par'] == 2) & (seguridad_social['pea'] == 0) & 
                      (seguridad_social['hijo_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia

## Parentesco directo: descendientes
seguridad_social.loc[((seguridad_social['par'] == 3) & (seguridad_social['edad'] < 16) & 
                      (seguridad_social['jef_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia
seguridad_social.loc[((seguridad_social['par'] == 3) & (seguridad_social['edad'] < 16) & 
                      (seguridad_social['cony_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia
seguridad_social.loc[((seguridad_social['par'] == 3) & (seguridad_social['edad'].between(16, 25)) & 
                      (seguridad_social['inas_esc'] == 0) & (seguridad_social['jef_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia
seguridad_social.loc[((seguridad_social['par'] == 3) & (seguridad_social['edad'].between(16, 25)) & 
                      (seguridad_social['inas_esc'] == 0) & (seguridad_social['cony_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia

## Parentesco directo: ascendientes
seguridad_social.loc[((seguridad_social['par'] == 4) & (seguridad_social['pea'] == 0) &
                      (seguridad_social['jef_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia
seguridad_social.loc[((seguridad_social['par'] == 5) & (seguridad_social['pea'] == 0) & 
                      (seguridad_social['cony_ss'] == 1)), 'ic_segsoc'] = 0 # No presenta carencia

## Otros n칰cleos familiares
seguridad_social.loc[(seguridad_social['s_salud'] == 1), 'ic_segsoc'] = 0 # No presenta carencia

## Programa de adultos mayores
seguridad_social.loc[(seguridad_social['pam'] == 1), 'ic_segsoc'] = 0 # No presenta carencia
seguridad_social.loc[(seguridad_social['ic_segsoc'].isna()), 'ic_segsoc'] = 1 # Presenta carencia

seguridad_social = seguridad_social[['folioviv', 'foliohog', 'numren', 'tipo_trab1', 'tipo_trab2', 'aforlab1', 'aforlab2', 'pea', 'jub', 
'smlab1', 'smlab2', 'smcv', 'aforecv', 'ss_dir', 'par', 'jef_ss', 'cony_ss', 'hijo_ss', 's_salud', 'pam', 'ing_pam', 'ic_segsoc']]
```

**Se guarda la base de datos** 
```{python}
seguridad_social.to_csv(current_directory + '/Output/Data/' + '/ic_segsoc22.csv', index = False)
```

##### Opci칩n 2 {.tabset .tabset-pills .top4-tiles} 

###### Prestaciones laborales

```{python}
trabajos = pd.read_csv(current_directory + "/Bases de datos/trabajos.csv", low_memory = False)
```

```{python}
def indicador_prestaciones(trabajos):
    def convertir_a_numerico(df):
        columnas = ['subor', 'indep', 'tiene_suel', 'pago', 'pres_8', 'id_trabajo']
        df[columnas] = df[columnas].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    def tipo_de_trabajador(df):
        df['tipo_trab'] = np.NaN
    
        # Subordinados
        df.loc[df['subor'] == 1, 'tipo_trab'] = 1
    
        # Independientes que reciben un pago
        df.loc[(df['subor'] == 2) & (df['indep'] == 1) & (df['tiene_suel'] == 1), 'tipo_trab'] = 2
        df.loc[(df['subor'] == 2) & (df['indep'] == 2) & (df['pago'] == 1), 'tipo_trab'] = 2
    
        # Independientes que no reciben un pago
        df.loc[(df['subor'] == 2) & (df['indep'] == 1) & (df['tiene_suel'] == 2), 'tipo_trab'] = 3
        df.loc[(df['subor'] == 2) & (df['indep'] == 2) & ((df['pago'] == 2) | (df['pago'] == 3)), 'tipo_trab'] = 3
    
        return df
    
    def ahorro_para_el_retiro(df):
        df['aforlab'] = np.NaN
        df.loc[df['pres_8'].isna(), 'aforlab'] = 0
        df.loc[df['pres_8'] == 8, 'aforlab'] = 1
        return df
    
    def ocupacion_principal_secundaria(df):
        df['ocupa'] = np.NaN
        df.loc[df['id_trabajo'] == 1, 'ocupa'] = 1
        df.loc[df['id_trabajo'] == 2, 'ocupa'] = 1
        return df
    
    def pivot_prestaciones(df):
        df = pd.pivot_table(df,
                            index = ['folioviv', 'foliohog', 'numren'],
                            columns = 'id_trabajo',
                            values = ['tipo_trab', 'aforlab', 'ocupa'],
                            aggfunc = np.sum,
                            fill_value = 0
                            )
        df.columns = [f'{i}{j}' for i, j in df.columns]
        df = df.reset_index()
        return df
    
    def identificar_poblacion_trabajadora(df):
        df['trab'] = 1
        columnas = ['folioviv', 'foliohog', 'numren', 'trab', 'tipo_trab1', 'tipo_trab2', 'aforlab1', 'aforlab2', 'ocupa1', 'ocupa2']
        return df[columnas]
    
            # Aplicando el pipeline
    return (trabajos.copy()
                    .pipe(convertir_a_numerico)
                    .pipe(tipo_de_trabajador)
                    .pipe(ahorro_para_el_retiro)
                    .pipe(ocupacion_principal_secundaria)
                    .pipe(pivot_prestaciones)
                    .pipe(identificar_poblacion_trabajadora))

# Indicador de prestaciones 
prestaciones = indicador_prestaciones(trabajos)
```


**Se guarda la base de datos** 
```{python}
prestaciones.to_csv(current_directory + '/Output/Data/' + '/prestaciones22_2.csv', index = False)
```

###### Ingresos por jubilaciones o pensiones

```{python}
# Ingresos por jubilaciones o pensiones
pensiones = pd.read_csv(current_directory + "/Bases de datos/ingresos.csv", low_memory = False)
```


```{python}
# Definiendo las constantes de deflaci칩n
deflactores = {
    1: 1.0118979346,  # oct22
    2: 0.9610510246,  # feb22
    3: 0.9705661414,  # mar22
    4: 0.9758164180,  # abr22
    5: 0.9775368933,  # may22
    6: 0.9857919437,  # jun22
    7: 0.9930938669,  # jul22
    8: 1.0000000000,  # ago22
    9: 1.0062034038,  # sep22
    10: 1.0118979346,  # oct22
    11: 1.0177217030,  # nov22
    12: 1.0216069077   # dic22
}
```

```{python}
def indicador_pensiones(pensiones):
    # Funci칩n para filtrar las pensiones relevantes
    def filtrar_pensiones(df):
        claves_relevantes = ['P032', 'P033', 'P104', 'P045']
        return df[df['clave'].isin(claves_relevantes)]
    
    # Funci칩n para convertir variables string a num칠ricas
    def convertir_a_numerico(df):
        columnas = ['mes_1', 'mes_2', 'mes_3', 'mes_4', 'mes_5', 'mes_6', 
                    'ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']
        df[columnas] = df[columnas].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    # Funci칩n para deflactar los ingresos
    def deflactar(ingreso, mes):
        if pd.isna(mes):
            return ingreso
        return ingreso / deflactores.get(mes, 1)
    
    def deflactar_ingresos(df):
        for i in range(1, 7):
            mes_col = f'mes_{i}'
            ing_col = f'ing_{i}'
            df[ing_col] = df.apply(lambda row: deflactar(row[ing_col], row[mes_col]), axis = 1)
        return df
    
    # Funci칩n para calcular los ingresos promedios
    def calcular_ingresos_promedios(df):
        # Ingreso promedio mensual por programas de adultos mayores
        df['ing_pam'] = np.where(df['clave'].isin(['P104', 'P045']),
                                  np.apply_along_axis(np.mean, 1, df[['ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']]),
                                   0
                                 )
        # Ingreso promedio mensual por jubilaciones y pensiones
        df['ing_pens'] = np.where(df['clave'].isin(['P032', 'P033']),
                                    np.apply_along_axis(np.mean, 1, df[['ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']]),
                                     0)
        return df
    
    # Funci칩n para agrupar los datos por hogar y sumar los ingresos
    def agrupar_y_sumar(df):
        df = df.groupby(['folioviv', 'foliohog', 'numren'])[['ing_pens', 'ing_pam']].sum(numeric_only = True)
        return df.reset_index()
    
    # Aplicando el pipeline
    return (pensiones.copy()
                     .pipe(filtrar_pensiones)
                     .pipe(convertir_a_numerico)
                     .pipe(deflactar_ingresos)
                     .pipe(calcular_ingresos_promedios)
                     .pipe(agrupar_y_sumar))
                     
# Indicador de pensiones 
pensiones = indicador_pensiones(pensiones)
```


**Se guarda la base de datos** 
```{python}
del deflactores
pensiones.to_csv(current_directory + '/Output/Data/' + '/pensiones22_2.csv', index = False)
```


###### Construcci칩n del indicador

**Indicador de carencia por acceso a la seguridad social** 

Se encuentra en situaci칩n de carencia por acceso a la seguridad social a la poblaci칩n que:    
1. No disponga de acceso directo a la seguridad social.   
2. No cuente con parentesco directo con alguna persona dentro del hogar que tenga acceso directo.    
3. No recibe servicios m칠dicos por parte de alg칰n familiar dentro o fuera del hogar, por muerte del asegurado o por contrataci칩n propia.  
4. No recibe ingreso por parte de un programa de adultos mayores donde el monto sea mayor o igual al valor promedio de la canasta alimentaria rural y urbana. 

```{python}
pensiones = pd.read_csv(current_directory + '/Output/Data/' + '/pensiones22.csv', low_memory = False)
prestaciones = pd.read_csv(current_directory + '/Output/Data/' + '/prestaciones22.csv', low_memory = False)
```

```{python}
# Valor monetario de las l칤neas de pobreza extrema por ingresos rural y urbana
lp1_urb = 2086.21
lp1_rur = 1600.18
lp_pam = (lp1_urb + lp1_rur)/2
```

 
```{python}
def indicador_seguridad_social(poblacion):
    def filtrar_poblacion_objetivo(df):
        return df[~((df['parentesco'] >= 400) & (df['parentesco'] < 500) |
                    (df['parentesco'] >= 700) & (df['parentesco'] < 800))]

    def integrar_bases(df):
        df = pd.merge(df, 
                       prestaciones, 
                        on = ['folioviv', 'foliohog', 'numren'], 
                         how = 'left')
        df = pd.merge(df, 
                       pensiones, 
                        on = ['folioviv', 'foliohog', 'numren'], 
                         how = 'left')
        return df
      
       # Convirtiendo variables string a num칠ricas
    def convertir_a_numerico(df):
        columnas_a_convertir = ['parentesco', 'trab', 'edad', 'act_pnea1', 'act_pnea2', 'ocupa1', 'atemed', 'trabajo_mp',
                                'inst_1', 'inst_2', 'inst_3', 'inst_4', 'inst_5', 'inst_6', 'inscr_1', 'inscr_2', 'inscr_3',
                                'inscr_4', 'inscr_5', 'inscr_6', 'inscr_7', 'asis_esc', 'pop_insabi', 'segvol_1']
        df[columnas_a_convertir] = df[columnas_a_convertir].apply(pd.to_numeric, errors = 'coerce')
        
        return df
      
    def calcular_pea(df):
        df['pea'] = np.NaN
        df.loc[(df['trab'] == 1) & (df['edad'] >= 16) & (~df['edad'].isna()), 'pea'] = 1  # PEA: ocupada
        df.loc[((df['act_pnea1'] == 1) | (df['act_pnea2'] == 1)) & (df['edad'] >= 16) & (~df['edad'].isna()), 'pea'] = 2  # PEA: desocupada
        df.loc[((df['edad'] >= 16) & (~df['edad'].isna()) &
                (((df['act_pnea1'] != 1) | (df['act_pnea1'].isna())) &
                 ((df['act_pnea2'] != 1) | (df['act_pnea2'].isna()))) &
                (((df['act_pnea1'] >= 2) & (df['act_pnea1'] <= 6)) |
                 ((df['act_pnea2'] >= 2) & (df['act_pnea2'] <= 6)))), 'pea'] = 0  # PNEA
        return df

    def tipo_trabajo(df):
        # Ocupaci칩n principal
        df['tipo_trab1'] = np.where(df['pea'] == 1, df['tipo_trab1'], df['tipo_trab1'])
        df['tipo_trab1'] = np.where((df['pea'] == 0) | (df['pea'] == 2), np.NaN, df['tipo_trab1'])
        df['tipo_trab1'] = np.where(df['pea'].isna(), np.NaN, df['tipo_trab1'])
        
        # Ocupaci칩n secundaria
        df['tipo_trab2'] = np.where(df['pea'] == 1, df['tipo_trab2'], df['tipo_trab2'])
        df['tipo_trab2'] = np.where((df['pea'] == 0) | (df['pea'] == 2), np.NaN, df['tipo_trab2'])
        df['tipo_trab2'] = np.where(df['pea'].isna(), np.NaN, df['tipo_trab2'])
        
        return df

    def calcular_jubilados(df):
        df['jub'] = np.NaN
        df.loc[((df['trabajo_mp'] == 2) & ((df['act_pnea1'] == 2) | (df['act_pnea2'] == 2))), 'jub'] = 1
        df.loc[((df['ing_pens'] > 0) & (~df['ing_pens'].isna())), 'jub'] = 1
        df.loc[(df['inscr_2'] == 2), 'jub'] = 1
        df.loc[(df['jub'].isna()), 'jub'] = 0
        
        return df

    def prestaciones_basicas(df):
        df['smlab1'] = np.NaN
        df.loc[(df['ocupa1'] == 1), 'smlab1'] = 0
        df.loc[((df['ocupa1'] == 1) & (df['atemed'] == 1) & 
                ((df['inst_1'] == 1) | (df['inst_2'] == 2) | (df['inst_3'] == 3) | (df['inst_4'] == 4)) &
                 (df['inscr_1'] == 1)), 'smlab1'] = 1
    
        df['smlab2'] = np.NaN
        df.loc[(df['ocupa2'] == 1), 'smlab2'] = 0
        df.loc[((df['ocupa2'] == 1) & (df['atemed'] == 1) &
                ((df['inst_1'] == 1) | (df['inst_2'] == 2) | (df['inst_3'] == 3) | (df['inst_4'] == 4)) &
                 (df['inscr_1'] == 1)), 'smlab2'] = 1
                 
        return df

    def contratacion_voluntaria(df):
        df['smcv'] = np.where((df['edad'] >= 12) & (~df['edad'].isna()), 0, np.NaN)
        df.loc[((df['atemed'] == 1) & ((df['inst_1'] == 1) |
                (df['inst_2'] == 2) | (df['inst_3'] == 3) |
                 (df['inst_4'] == 4)) & (df['inscr_6'] == 6) &
                  ((df['edad'] >= 12) & (~df['edad'].isna()))), 'smcv'] = 1
    
        df['aforecv'] = np.NaN
        df.loc[(df['segvol_1'].isna()) &
                ((df['edad'] >= 12) &
                 (~df['edad'].isna())), 'aforecv'] = 0
        df.loc[(df['segvol_1'] == 1) &
                ((df['edad'] >= 12) &
                 (~df['edad'].isna())), 'aforecv'] = 1
        
        return df

    def acceso_directo_seguridad_social(df):
        df['ss_dir'] = np.NaN
        df.loc[(df['ss_dir'].isna()), 'ss_dir'] = 0
    
        df.loc[((df['tipo_trab1'] == 1) & (df['smlab1'] == 1)), 'ss_dir'] = 1
        df.loc[((df['tipo_trab1'] == 2) & ((df['smlab1'] == 1) |
                (df['smcv'] == 1)) & ((df['aforlab1'] == 1) |
                 (df['aforecv'] == 1))), 'ss_dir'] = 1
        df.loc[((df['tipo_trab1'] == 3) & ((df['smlab1'] == 1) |
                (df['smcv'] == 1)) & (df['aforecv'] == 1)), 'ss_dir'] = 1
    
        df.loc[((df['tipo_trab2'] == 1) & (df['smlab2'] == 1)), 'ss_dir'] = 1
        df.loc[((df['tipo_trab2'] == 2) & ((df['smlab2'] == 1) |
                (df['smcv'] == 1)) & ((df['aforlab2'] == 1) |
                 (df['aforecv'] == 1))), 'ss_dir'] = 1
        df.loc[((df['tipo_trab2'] == 3) & ((df['smlab2'] == 1) |
                (df['smcv'] == 1)) & (df['aforecv'] == 1)), 'ss_dir'] = 1
    
        df.loc[(df['jub'] == 1), 'ss_dir'] = 1
        
        return df

    def identificar_nucleos_familiares(df):
        df['par'] = np.NaN
        df.loc[((df['parentesco'] >= 100) & (df['parentesco'] < 200)), 'par'] = 1
        df.loc[((df['parentesco'] >= 200) & (df['parentesco'] < 300)), 'par'] = 2
        df.loc[((df['parentesco'] >= 300) & (df['parentesco'] < 400)), 'par'] = 3
        df.loc[((df['parentesco'] == 601)), 'par'] = 4
        df.loc[((df['parentesco'] == 615)), 'par'] = 5
        df.loc[(df['par'].isna()), 'par'] = 6
        
        df['inas_esc'] = np.where((df['asis_esc'] == 1), 0, 1)
        
        return df

    def identificar_acceso_directo(df):
        df['jef'] = np.where(((df['par'] == 1) & (df['ss_dir'] == 1)), 1, np.NaN)
        df['cony'] = np.where(((df['par'] == 2) & (df['ss_dir'] == 1)), 1, np.NaN)
        df['hijo'] = np.where(((df['par'] == 3) & (df['ss_dir'] == 1) & (df['jub'] == 1) & 
                                (df['edad'] > 25) & (~df['edad'].isna())) | 
                               ((df['par'] == 3) & (df['ss_dir'] == 1) & (df['jub'] == 0)), 1, np.NaN)
        
        return df

    def agrupar_nucleos_familiares(df):
        grouped = df.groupby(['folioviv', 'foliohog']).agg({'jef': 'sum', 'cony': 'sum', 'hijo': 'sum'}).reset_index()
        grouped['jef'] = np.where((grouped['jef'] > 0), 1, 0)
        grouped['cony'] = np.where((grouped['cony'] > 0), 1, 0)
        grouped['hijo'] = np.where((grouped['hijo'] > 0), 1, 0)
        grouped.rename(columns={'jef': 'jef_ss', 'cony': 'cony_ss', 'hijo': 'hijo_ss'}, inplace=True)
        
        df = pd.merge(df, 
                       grouped, 
                        on = ['folioviv', 'foliohog'], 
                         how = 'left')
        df['jef_ss'] = np.where((df['jef_ss'] == 1), 1, np.NaN)
        df['cony_ss'] = np.where((df['cony_ss'] == 1), 1, np.NaN)
        df['hijo_ss'] = np.where((df['hijo_ss'] == 1), 1, np.NaN)
        
        return df

    # Funciones auxiliares
    def identificar_otro_nucleo_familiar(df):
        df['s_salud'] = np.NaN
        df.loc[((~df['pop_insabi'].isna()) & (~df['atemed'].isna())), 's_salud'] = 0
        df.loc[((df['atemed'] == 1) &
                ((df['inst_1'] == 1) | (df['inst_2'] == 2) | (df['inst_3'] == 3) | (df['inst_4'] == 4)) &
                 ((df['inscr_3'] == 3) | (df['inscr_4'] == 4) | (df['inscr_6'] == 6) | (df['inscr_7'] == 7))), 's_salud'] = 1
        return df

    def identificar_programa_pensiones(df):
        df['pam'] = np.NaN
        df.loc[((df['edad'] >= 65) & (~df['edad'].isna())), 'pam'] = 0
        df.loc[((df['edad'] >= 65) & (~df['edad'].isna()) & 
                (df['ing_pam'] >= lp_pam) & (~df['ing_pam'].isna())), 'pam'] = 1
        return df

    def calcular_indicador_carencia(df):
        df['ic_segsoc'] = np.NaN
        df.loc[(df['ss_dir'] == 1), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 1) & (df['cony_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 1) & (df['pea'] == 0) & (df['hijo_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 2) & (df['jef_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 2) & (df['pea'] == 0) & (df['hijo_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 3) & (df['edad'] < 16) & (df['jef_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 3) & (df['edad'] < 16) & (df['cony_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 3) & (df['edad'].between(16, 25)) & (df['inas_esc'] == 0) & (df['jef_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 3) & (df['edad'].between(16, 25)) & (df['inas_esc'] == 0) & (df['cony_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 4) & (df['pea'] == 0) & (df['jef_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[((df['par'] == 5) & (df['pea'] == 0) & (df['cony_ss'] == 1)), 'ic_segsoc'] = 0
        df.loc[(df['s_salud'] == 1), 'ic_segsoc'] = 0
        df.loc[(df['pam'] == 1), 'ic_segsoc'] = 0
        df.loc[df['ic_segsoc'].isna(), 'ic_segsoc'] = 1
        
        return df
      
        # Seleccionar columnas finales
    def seleccionar_columnas(df):
        columnas = ['folioviv', 'foliohog', 'numren', 'tipo_trab1', 'tipo_trab2', 'aforlab1', 'aforlab2', 'pea', 'jub',
                    'smlab1', 'smlab2', 'smcv', 'aforecv', 'ss_dir', 'par', 'jef_ss', 'cony_ss', 'hijo_ss', 's_salud',
                    'pam', 'ing_pam', 'ic_segsoc']
                    
        return df[columnas]    

    return (poblacion.copy()
                     .pipe(filtrar_poblacion_objetivo)
                     .pipe(integrar_bases)
                     .pipe(convertir_a_numerico)
                     .pipe(calcular_pea)
                     .pipe(tipo_trabajo)
                     .pipe(calcular_jubilados)
                     .pipe(prestaciones_basicas)
                     .pipe(contratacion_voluntaria)
                     .pipe(acceso_directo_seguridad_social)
                     .pipe(identificar_nucleos_familiares)
                     .pipe(identificar_acceso_directo)
                     .pipe(agrupar_nucleos_familiares)
                     .pipe(identificar_otro_nucleo_familiar)
                     .pipe(identificar_programa_pensiones)
                     .pipe(calcular_indicador_carencia)
                     .pipe(seleccionar_columnas)
                     )
                     
seguridad_social = indicador_seguridad_social(poblacion)
```


**Se guarda la base de datos** 
```{python}
seguridad_social.to_csv(current_directory + '/Output/Data/' + '/ic_segsoc22_2.csv', index = False)
```

#### IV. Indicador de carencia por calidad y espacios de la vivienda {.tabset .tabset-pills .top3-tiles}  

```{python}
viviendas = pd.read_csv(current_directory + "/Bases de datos/viviendas.csv", low_memory = False)
concentradohogar = pd.read_csv(current_directory + "/Bases de datos/concentradohogar.csv", low_memory = False)
```

##### Opci칩n 1 

###### Material de construcci칩n de la vivienda  

**Indicador de carencia por calidad y espacios de la vivienda**  

Se considera en situaci칩n de carencia por calidad y espacios de la vivienda a las personas que residan en viviendas que presenten, al menos, una de las siguientes caracter칤sticas:     
  
1. El material de los pisos de la vivienda es de tierra   
2. El material del techo de la vivienda es de l치mina de cart칩n o desechos.   
3. El material de los muros de la vivienda es de embarro o bajareque, de carrizo, bamb칰 o palma, de l치mina de cart칩n, met치lica o asbesto, o material de desecho.    
4. La raz칩n de personas por cuarto (hacinamiento) es mayor que `2.5`.      

```{python}
calidad_viviendas = viviendas.copy()

calidad_viviendas = pd.merge(calidad_viviendas, concentradohogar, 
                              on = ['folioviv'], 
                               how = 'left')

#Convirtiendo variables string a numericas
calidad_viviendas[['mat_pisos', 'mat_techos', 'mat_pared', 'tot_resid', 'num_cuarto']
                  ] = calidad_viviendas[['mat_pisos', 'mat_techos', 'mat_pared', 'tot_resid', 'num_cuarto']
                                        ].apply(pd.to_numeric, errors = 'coerce')

# Indicador de carencia por material de piso de la vivienda
## Material de los pisos de la vivienda
calidad_viviendas['icv_pisos'] = np.NaN
calidad_viviendas.loc[(calidad_viviendas['mat_pisos'] >= 2), 'icv_pisos'] = 0
calidad_viviendas.loc[(calidad_viviendas['mat_pisos'] == 1), 'icv_pisos'] = 1

# Indicador de carencia por material de techos de la vivienda
## Material de los techos de la vivienda
calidad_viviendas['icv_techos'] = np.NaN
calidad_viviendas.loc[(calidad_viviendas['mat_techos'] >= 3), 'icv_techos'] = 0
calidad_viviendas.loc[(calidad_viviendas['mat_techos'] <= 2), 'icv_techos'] = 1

# Indicador de carencia por material de muros de la vivienda
## Material de muros en la vivienda
calidad_viviendas['icv_muros'] = np.NaN
calidad_viviendas.loc[(calidad_viviendas['mat_pared'] >= 6), 'icv_muros'] = 0
calidad_viviendas.loc[(calidad_viviendas['mat_pared'] <= 5), 'icv_muros'] = 1

# Espacios en la vivienda (Hacinamiento)
## N칰mero de residentes en la vivienda
calidad_viviendas['num_ind'] = calidad_viviendas['tot_resid']

## N칰mero de cuartos en la vivienda
calidad_viviendas['num_cua'] = calidad_viviendas['num_cuarto']

## 칈ndice de hacinamiento
calidad_viviendas['cv_hac'] = calidad_viviendas['num_ind'] / calidad_viviendas['num_cua']

## Indicador de carencia por hacinamiento en la vivienda
calidad_viviendas['icv_hac'] = np.NaN
calidad_viviendas.loc[((calidad_viviendas['cv_hac'] > 2.5) & (~calidad_viviendas['cv_hac'].isna())), 'icv_hac'] = 1
calidad_viviendas.loc[(calidad_viviendas['cv_hac'] <= 2.5), 'icv_hac'] = 0
       
# Indicador de carencia por calidad y espacios de la vivienda
calidad_viviendas['ic_cv'] = np.NaN
calidad_viviendas.loc[((calidad_viviendas['icv_pisos'] == 1) | 
                       (calidad_viviendas['icv_techos'] == 1) | 
                        (calidad_viviendas['icv_muros'] == 1) | 
                         (calidad_viviendas['icv_hac'] == 1)), 'ic_cv'] = 1 # Con carencia
calidad_viviendas.loc[((calidad_viviendas['icv_pisos'] == 0) & 
                       (calidad_viviendas['icv_techos'] == 0) & 
                        (calidad_viviendas['icv_muros'] == 0) & 
                         (calidad_viviendas['icv_hac'] == 0)), 'ic_cv'] = 0 # Sin carencia  
calidad_viviendas.loc[((calidad_viviendas['icv_pisos'].isna()) | 
                       (calidad_viviendas['icv_techos'].isna()) |
                        (calidad_viviendas['icv_muros'].isna()) | 
                         (calidad_viviendas['icv_hac'].isna())), 'ic_cv'] = np.NaN
            
calidad_viviendas = calidad_viviendas[['folioviv', 'foliohog', 'icv_pisos', 'icv_techos', 'icv_muros', 'icv_hac', 'ic_cv']]    
```


**Se guarda la base de datos** 
```{python}
calidad_viviendas.to_csv(current_directory + '/Output/Data/' + '/ic_cev22.csv', index = False)
```

##### Opci칩n 2  

###### Material de construcci칩n de la vivienda  

**Indicador de carencia por calidad y espacios de la vivienda**  

Se considera en situaci칩n de carencia por calidad y espacios de la vivienda a las personas que residan en viviendas que presenten, al menos, una de las siguientes caracter칤sticas:     
  
1. El material de los pisos de la vivienda es de tierra   
2. El material del techo de la vivienda es de l치mina de cart칩n o desechos.   
3. El material de los muros de la vivienda es de embarro o bajareque, de carrizo, bamb칰 o palma, de l치mina de cart칩n, met치lica o asbesto, o material de desecho.    
4. La raz칩n de personas por cuarto (hacinamiento) es mayor que `2.5`.      

```{python}
def indicador_calidad_viviendas(viviendas):
    # Funciones auxiliares
    def merge_concentradohogar(df):
        return pd.merge(df, 
                         concentradohogar, 
                          on = 'folioviv', 
                           how = 'left')
                           
    def convertir_variables_numericas(df):
        cols = ['mat_pisos', 'mat_techos', 'mat_pared', 'tot_resid', 'num_cuarto']
        df[cols] = df[cols].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    def calcular_icv_pisos(df):
        df['icv_pisos'] = np.NaN
        df.loc[df['mat_pisos'] >= 2, 'icv_pisos'] = 0
        df.loc[df['mat_pisos'] == 1, 'icv_pisos'] = 1
        return df
    
    def calcular_icv_techos(df):
        df['icv_techos'] = np.NaN
        df.loc[df['mat_techos'] >= 3, 'icv_techos'] = 0
        df.loc[df['mat_techos'] <= 2, 'icv_techos'] = 1
        return df
    
    def calcular_icv_muros(df):
        df['icv_muros'] = np.NaN
        df.loc[df['mat_pared'] >= 6, 'icv_muros'] = 0
        df.loc[df['mat_pared'] <= 5, 'icv_muros'] = 1
        return df
    
    def calcular_icv_hacinamiento(df):
        df['num_ind'] = df['tot_resid']
        df['num_cua'] = df['num_cuarto']
        df['cv_hac'] = df['num_ind'] / df['num_cua']
        
        df['icv_hac'] = np.NaN
        df.loc[(df['cv_hac'] > 2.5) & (~df['cv_hac'].isna()), 'icv_hac'] = 1
        df.loc[df['cv_hac'] <= 2.5, 'icv_hac'] = 0
        return df
    
    def calcular_ic_cv(df):
        df['ic_cv'] = np.NaN
        df.loc[((df['icv_pisos'] == 1) | 
                (df['icv_techos'] == 1) | 
                (df['icv_muros'] == 1) | 
                (df['icv_hac'] == 1)), 'ic_cv'] = 1
        
        df.loc[((df['icv_pisos'] == 0) & 
                (df['icv_techos'] == 0) & 
                (df['icv_muros'] == 0) & 
                (df['icv_hac'] == 0)), 'ic_cv'] = 0
        
        df.loc[((df['icv_pisos'].isna()) | 
                (df['icv_techos'].isna()) |
                (df['icv_muros'].isna()) | 
                (df['icv_hac'].isna())), 'ic_cv'] = np.NaN
        return df
      
          # Seleccionar columnas finales
    def seleccionar_columnas(df):
        columnas = ['folioviv', 'foliohog', 'icv_pisos', 'icv_techos', 'icv_muros', 'icv_hac', 'ic_cv']
                    
        return df[columnas]    

    return (viviendas.copy()
                     .pipe(merge_concentradohogar)
                     .pipe(convertir_variables_numericas)
                     .pipe(calcular_icv_pisos)
                     .pipe(calcular_icv_techos)
                     .pipe(calcular_icv_muros)
                     .pipe(calcular_icv_hacinamiento)
                     .pipe(calcular_ic_cv)
                     .pipe(seleccionar_columnas))

calidad_viviendas = indicador_calidad_viviendas(viviendas)         
```

```{python}
calidad_viviendas.to_csv(current_directory + '/Output/Data/' + '/ic_cev22_2.csv', index = False)
```


#### V. Indicador de carencia por acceso a los servicios b치sicos de la vivienda {.tabset .tabset-pills .top3-tiles}    

**Indicador de carencia por acceso a los servicios b치sicos en la vivienda**   

Se considera en situaci칩n de carencia por servicios b치sicos en la vivienda a las personas que residan en viviendas que presenten, al menos, una de las siguientes caracter칤sticas:   
  
1. El agua se obtiene de un pozo, r칤o, lago, arroyo, pipa, o bien, el agua entubada la adquieren por acarreo de otra vivienda, o de la llave p칰blica o hidrante.  
2. No cuentan con servicio de drenaje o el desag칲e tiene conexi칩n a una tuber칤a que va a dar a un r칤o, lago, mar, barranca o grieta.   
3. No disponen de energ칤a el칠ctrica.   
4. El combustible que se usa para cocinar o calentar los alimentos es le침a o carb칩n sin chimenea.   

```{python}
viviendas = pd.read_csv(current_directory + "/Bases de datos/viviendas.csv", low_memory = False)
concentradohogar = pd.read_csv(current_directory + "/Bases de datos/concentradohogar.csv", low_memory = False)
```

##### Opci칩n 1  

```{python}
servicios_basicos = pd.merge(concentradohogar, 
                              viviendas, 
                               on = ['folioviv'], 
                                how = 'left')                  

#Convirtiendo variables string a numericas
servicios_basicos[['procaptar', 'disp_agua', 'drenaje', 'disp_elect', 'combustible', 'estufa_chi']
                  ] = servicios_basicos[['procaptar', 'disp_agua', 'drenaje', 'disp_elect', 'combustible', 'estufa_chi']
                                        ].apply(pd.to_numeric, errors = 'coerce')

# Indicador de carencia por acceso al agua
servicios_basicos['isb_agua'] = np.NaN
servicios_basicos.loc[((servicios_basicos['disp_agua'] >= 3) & 
                       (~servicios_basicos['disp_agua'].isna())), 'isb_agua'] = 1
servicios_basicos.loc[((servicios_basicos['procaptar'] == 1) & 
                       (servicios_basicos['disp_agua'] == 4)), 'isb_agua'] = 0
servicios_basicos.loc[((servicios_basicos['disp_agua'] <= 2) & 
                       (~servicios_basicos['disp_agua'].isna())), 'isb_agua'] = 0

# Indicador de carencia por servicio de drenaje
servicios_basicos['isb_dren'] = np.NaN
servicios_basicos.loc[(servicios_basicos['drenaje'] >= 3), 'isb_dren'] = 1
servicios_basicos.loc[(servicios_basicos['drenaje'] <= 2), 'isb_dren'] = 0

# Indicador de carencia por servicios de electricidad
servicios_basicos['isb_luz'] = np.NaN
servicios_basicos.loc[(servicios_basicos['disp_elect'] >= 5), 'isb_luz'] = 1
servicios_basicos.loc[(servicios_basicos['disp_elect'] <= 4), 'isb_luz'] = 0

# Indicador de carencia por combustible para cocinar
servicios_basicos['combus'] = servicios_basicos['combustible']
servicios_basicos['estufa'] = servicios_basicos['estufa_chi']
servicios_basicos['isb_combus'] = np.NaN
servicios_basicos.loc[(((servicios_basicos['combus'] == 1) | 
                       (servicios_basicos['combus'] == 2)) & 
                        (servicios_basicos['estufa'] == 2)), 'isb_combus'] = 1
servicios_basicos.loc[(((servicios_basicos['combus'] == 1) | 
                       (servicios_basicos['combus'] == 2)) & 
                        (servicios_basicos['estufa'] == 1)), 'isb_combus'] = 0
servicios_basicos.loc[(servicios_basicos['combus'].between(3, 6)), 'isb_combus'] = 0

# Indicador de carencia por acceso a los servicios b치sicos en la vivienda
servicios_basicos['ic_sbv'] = np.NaN
servicios_basicos.loc[((servicios_basicos['isb_agua'] == 1) | 
                       (servicios_basicos['isb_dren'] == 1) | 
                        (servicios_basicos['isb_luz'] == 1) | 
                         (servicios_basicos['isb_combus'] == 1)), 'ic_sbv'] = 1 # Con carencia
servicios_basicos.loc[((servicios_basicos['isb_agua'] == 0) & 
                       (servicios_basicos['isb_dren'] == 0) & 
                        (servicios_basicos['isb_luz'] == 0) & 
                         (servicios_basicos['isb_combus'] == 0)), 'ic_sbv'] = 0 # Sin carencia 
servicios_basicos.loc[((servicios_basicos['isb_agua'].isna()) | 
                       (servicios_basicos['isb_dren'].isna()) | 
                        (servicios_basicos['isb_luz'].isna()) | 
                         (servicios_basicos['isb_combus'].isna())), 'ic_sbv'] = np.NaN

servicios_basicos = servicios_basicos[['folioviv', 'foliohog', 'isb_agua', 'isb_dren', 'isb_luz', 'isb_combus', 'ic_sbv']]
```

**Se guarda la base de datos** 
```{python}
servicios_basicos.to_csv(current_directory + '/Output/Data/' + '/ic_sbv22.csv', index = False)
```

##### Opci칩n 2  

```{python}
def indicador_servicios_basicos(viviendas):
    # Funciones auxiliares
    def merge_concentradohogar(df):
        return pd.merge(df, 
                         concentradohogar, 
                          on = 'folioviv', 
                           how = 'left')

    def convertir_variables_numericas(df):
        cols = ['procaptar', 'disp_agua', 'drenaje', 'disp_elect', 'combustible', 'estufa_chi']
        df[cols] = df[cols].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    def calcular_isb_agua(df):
        df['isb_agua'] = np.nan
        df.loc[(df['disp_agua'] >= 3) & (~df['disp_agua'].isna()), 'isb_agua'] = 1
        df.loc[(df['procaptar'] == 1) & (df['disp_agua'] == 4), 'isb_agua'] = 0
        df.loc[(df['disp_agua'] <= 2) & (~df['disp_agua'].isna()), 'isb_agua'] = 0
        return df
    
    def calcular_isb_dren(df):
        df['isb_dren'] = np.nan
        df.loc[df['drenaje'] >= 3, 'isb_dren'] = 1
        df.loc[df['drenaje'] <= 2, 'isb_dren'] = 0
        return df
    
    def calcular_isb_luz(df):
        df['isb_luz'] = np.nan
        df.loc[df['disp_elect'] >= 5, 'isb_luz'] = 1
        df.loc[df['disp_elect'] <= 4, 'isb_luz'] = 0
        return df
    
    def calcular_isb_combus(df):
        df['combus'] = df['combustible']
        df['estufa'] = df['estufa_chi']
        df['isb_combus'] = np.nan
        df.loc[((df['combus'].isin([1, 2])) & (df['estufa'] == 2)), 'isb_combus'] = 1
        df.loc[((df['combus'].isin([1, 2])) & (df['estufa'] == 1)), 'isb_combus'] = 0
        df.loc[df['combus'].between(3, 6), 'isb_combus'] = 0
        return df
    
    def calcular_ic_sbv(df):
        df['ic_sbv'] = np.nan
        df.loc[((df['isb_agua'] == 1) | 
                (df['isb_dren'] == 1) | 
                (df['isb_luz'] == 1) | 
                (df['isb_combus'] == 1)), 'ic_sbv'] = 1  # Con carencia
        
        df.loc[((df['isb_agua'] == 0) & 
                (df['isb_dren'] == 0) & 
                (df['isb_luz'] == 0) & 
                (df['isb_combus'] == 0)), 'ic_sbv'] = 0  # Sin carencia
        
        df.loc[((df['isb_agua'].isna()) | 
                (df['isb_dren'].isna()) | 
                (df['isb_luz'].isna()) | 
                (df['isb_combus'].isna())), 'ic_sbv'] = np.nan
        return df
      
          # Seleccionar columnas finales
    def seleccionar_columnas(df):
        columnas = ['folioviv', 'foliohog', 'isb_agua', 'isb_dren', 'isb_luz', 'isb_combus', 'ic_sbv']
                    
        return df[columnas]  
    
    return (viviendas.copy()
                     .pipe(merge_concentradohogar)
                     .pipe(convertir_variables_numericas)
                     .pipe(calcular_isb_agua)
                     .pipe(calcular_isb_dren)
                     .pipe(calcular_isb_luz)
                     .pipe(calcular_isb_combus)
                     .pipe(calcular_ic_sbv)
                     .pipe(seleccionar_columnas)
                     )

servicios_basicos = indicador_servicios_basicos(viviendas)
```


```{python}
servicios_basicos.to_csv(current_directory + '/Output/Data/' + '/ic_sbv22_2.csv', index = False)
```


#### VI. Indicador de carencia por acceso a la alimentaci칩n nutritiva y de calidad {.tabset .tabset-pills .top3-tiles}  

##### Opci칩n 1 {.tabset .tabset-pills .top4-tiles} 
 
###### Grado de inseguridad alimentaria

```{python}
menores_alimentacion = poblacion.copy()

# Poblaci칩n objetivo: no se incluye a hu칠spedes ni trabajadores dom칠sticos
menores_alimentacion = menores_alimentacion[~((menores_alimentacion['parentesco'] >= 400) & 
                                              (menores_alimentacion['parentesco'] < 500) |
                                               (menores_alimentacion['parentesco'] >= 700) & 
                                                (menores_alimentacion['parentesco'] < 800))]

# Indicador de hogares con menores_alimentacion de 18 a침os
menores_alimentacion['men'] = np.NaN
menores_alimentacion.loc[(menores_alimentacion['edad'].between(0, 17)), 'men'] = 1

menores_alimentacion = menores_alimentacion.groupby(['folioviv', 'foliohog'])['men'].sum().dropna().reset_index()

menores_alimentacion['id_men'] = np.NaN
menores_alimentacion.loc[((menores_alimentacion['men'] >= 1) & 
                          (~menores_alimentacion['men'].isna())), 'id_men'] = 1
menores_alimentacion.loc[(menores_alimentacion['men'] == 0), 'id_men'] = 0

menores_alimentacion = menores_alimentacion[['folioviv', 'foliohog', 'id_men']]
```

**Se guarda la base de datos** 
```{python}
menores_alimentacion.to_csv(current_directory + '/Output/Data/' + '/menores22.csv', index = False)
```

####### Grado de inseguridad alimentaria 

```{python}
hogares = pd.read_csv(current_directory + "/Bases de datos/hogares.csv", low_memory = False)
```

```{python}
alimentacion = hogares.copy()

#Convirtiendo variables string a numericas
alimentacion[['acc_alim2', 'acc_alim4', 'acc_alim5', 'acc_alim6', 'acc_alim7', 'acc_alim8', 'acc_alim11', 'acc_alim12', 
              'acc_alim13', 'acc_alim14', 'acc_alim15', 'acc_alim16']
             ] = alimentacion[['acc_alim2', 'acc_alim4', 'acc_alim5', 'acc_alim6', 'acc_alim7', 'acc_alim8',
                               'acc_alim11', 'acc_alim12', 'acc_alim13', 'acc_alim14', 'acc_alim15', 'acc_alim16']
                               ].apply(pd.to_numeric, errors = 'coerce')
                  
                  
# Parte 1. Grado de inseguridad alimentaria 
# Seis preguntas para hogares sin poblaci칩n menor a 18 a침os

## Alg칰n adulto tuvo una alimentaci칩n basada en muy poca variedad de alimentos
alimentacion['ia_1ad'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim4'] == 2), 'ia_1ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim4'].isna()), 'ia_1ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim4'] == 1), 'ia_1ad'] = 1 # S칤

## Alg칰n adulto dej칩 de desayunar, comer o cenar
alimentacion['ia_2ad'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim5'] == 2), 'ia_2ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim5'].isna()), 'ia_2ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim5'] == 1), 'ia_2ad'] = 1 # S칤

## Alg칰n adulto comi칩 menos de lo que deb칤a comer
alimentacion['ia_3ad'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim6'] == 2), 'ia_3ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim6'].isna()), 'ia_3ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim6'] == 1), 'ia_3ad'] = 1 # S칤

## El hogar se qued칩 sin comida
alimentacion['ia_4ad'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim2'] == 2), 'ia_4ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim2'].isna()), 'ia_4ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim2'] == 1), 'ia_4ad'] = 1 # S칤

## Alg칰n adulto sinti칩 hambre pero no comi칩
alimentacion['ia_5ad'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim7'] == 2), 'ia_5ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim7'].isna()), 'ia_5ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim7'] == 1), 'ia_5ad'] = 1 # S칤

## Alg칰n adulto solo comi칩 una vez al d칤a o dej칩 de comer todo un d칤a
alimentacion['ia_6ad'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim8'] == 2), 'ia_6ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim8'].isna()), 'ia_6ad'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim8'] == 1), 'ia_6ad'] = 1 # S칤    

# Seis preguntas para hogares sin poblaci칩n menor a 18 a침os
            
## Alguien de 0 a 17 a침os tuvo una alimentaci칩n basada en muy poca variedad de alimentos
alimentacion['ia_7men'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim11'] == 2), 'ia_7men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim11'].isna()), 'ia_7men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim11'] == 1), 'ia_7men'] = 1 # S칤 

## Alguien de 0 a 17 a침os comi칩 menos de lo que deb칤a
alimentacion['ia_8men'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim12'] == 2), 'ia_8men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim12'].isna()), 'ia_8men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim12'] == 1), 'ia_8men'] = 1 # S칤 

## Se tuvo que disminuir la cantidad servida en las comidas a alguien de 0 a 17 a침os
alimentacion['ia_9men'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim13'] == 2), 'ia_9men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim13'].isna()), 'ia_9men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim13'] == 1), 'ia_9men'] = 1 # S칤 

## Alguien de 0 a 17 a침os sinti칩 hambre pero no comi칩
alimentacion['ia_10men'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim14'] == 2), 'ia_10men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim14'].isna()), 'ia_10men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim14'] == 1), 'ia_10men'] = 1 # S칤 

## Alguien de 0 a 17 a침os se acost칩 con hambre
alimentacion['ia_11men'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim15'] == 2), 'ia_11men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim15'].isna()), 'ia_11men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim15'] == 1), 'ia_11men'] = 1 # S칤 

## Alguien de 0 a 17 a침os comi칩 una vez al d칤a o dej칩 de comer todo un d칤a
alimentacion['ia_12men'] = np.NaN
alimentacion.loc[(alimentacion['acc_alim16'] == 2), 'ia_12men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim16'].isna()), 'ia_12men'] = 0 # No
alimentacion.loc[(alimentacion['acc_alim16'] == 1), 'ia_12men'] = 1 # S칤 

alimentacion = pd.merge(alimentacion, menores_alimentacion, 
                         on = ['folioviv', 'foliohog'], 
                          how = 'left')

#Convirtiendo variables string a numericas
alimentacion[['id_men', 'ia_1ad', 'ia_2ad', 'ia_3ad', 'ia_4ad', 'ia_5ad', 'ia_6ad', 'ia_7men', 'ia_8men',
              'ia_9men', 'ia_10men', 'ia_11men', 'ia_12men', 'alim17_1', 'alim17_2', 'alim17_3', 'alim17_4',
              'alim17_5', 'alim17_6', 'alim17_7', 'alim17_8', 'alim17_9','alim17_10', 'alim17_11', 'alim17_12']
             ] = alimentacion[['id_men', 'ia_1ad', 'ia_2ad', 'ia_3ad', 'ia_4ad', 'ia_5ad', 'ia_6ad', 'ia_7men',
                               'ia_8men', 'ia_9men', 'ia_10men', 'ia_11men', 'ia_12men', 'alim17_1', 'alim17_2',
                               'alim17_3', 'alim17_4', 'alim17_5', 'alim17_6', 'alim17_7', 'alim17_8', 'alim17_9',
                               'alim17_10', 'alim17_11', 'alim17_12']
                               ].apply(pd.to_numeric, errors = 'coerce')

# Construcci칩n de la escala de inseguridad alimentaria

# Escala para hogares sin menores de 18 a침os
alimentacion['tot_iaad'] = np.NaN 
alimentacion.loc[(alimentacion['id_men'] == 0), 'tot_iaad'] = (alimentacion['ia_1ad']
                                                               ) + (alimentacion['ia_2ad']
                                                               ) + (alimentacion['ia_3ad']
                                                               ) + (alimentacion['ia_4ad']
                                                               ) + (alimentacion['ia_5ad']
                                                               ) + (alimentacion['ia_6ad'])
# Escala para hogares con menores de 18 a침os
alimentacion['tot_iamen'] = np.NaN 
alimentacion.loc[(alimentacion['id_men'] == 1), 'tot_iamen'] = (alimentacion['ia_1ad']
                                                                ) + (alimentacion['ia_2ad']
                                                                ) + (alimentacion['ia_3ad']
                                                                ) + (alimentacion['ia_4ad']
                                                                ) +  (alimentacion['ia_5ad']
                                                                ) + (alimentacion['ia_6ad']
                                                                ) + (alimentacion['ia_7men']
                                                                ) +  (alimentacion['ia_8men']
                                                                ) + (alimentacion['ia_9men']
                                                                ) + (alimentacion['ia_10men']
                                                                ) + (alimentacion['ia_11men']
                                                                ) + (alimentacion['ia_12men'])

## Grado de inseguridad alimentaria
alimentacion['ins_ali'] = np.NaN

## Seguridad alimentaria 
alimentacion.loc[((alimentacion['tot_iaad'] == 0) | 
                  (alimentacion['tot_iamen'] == 0)), 'ins_ali'] = 0

## Inseguridad alimentaria leve
alimentacion.loc[((alimentacion['tot_iaad'] == 1) | (alimentacion['tot_iaad'] == 2) | 
                  (alimentacion['tot_iamen'] == 1) | (alimentacion['tot_iamen'] == 2) | 
                   (alimentacion['tot_iamen'] == 3)), 'ins_ali'] = 1

## Inseguridad alimentaria moderada
alimentacion.loc[((alimentacion['tot_iaad'] == 3) | (alimentacion['tot_iaad'] == 4) | 
                  (alimentacion['tot_iamen'] == 4) | (alimentacion['tot_iamen'] == 5) | 
                   (alimentacion['tot_iamen'] == 6) | (alimentacion['tot_iamen'] == 7)), 'ins_ali'] = 2

## Inseguridad alimentaria severa
alimentacion.loc[((alimentacion['tot_iaad'] == 5) | (alimentacion['tot_iaad'] == 6) | 
                  (alimentacion['tot_iamen'] >= 8) & (~alimentacion['tot_iamen'].isna())), 'ins_ali'] = 3   

# Se genera el indicador de carencia por acceso a la alimentaci칩n que considera en situaci칩n de carencia a la poblaci칩n en hogares que presenten inseguridad alimentaria moderada o severa

#Indicador de carencia por acceso a la alimentaci칩n
alimentacion['ic_ali'] = np.NaN
alimentacion.loc[((alimentacion['ins_ali'] == 2) | 
                  (alimentacion['ins_ali'] == 3)), 'ic_ali'] = 1 # Con carencia
alimentacion.loc[((alimentacion['ins_ali'] == 0) | 
                  (alimentacion['ins_ali'] == 1)), 'ic_ali'] = 0 # Sin carencia
```

###### Limitaci칩n en el consumo de alimentos  

Se considera el n칰mero de d칤as que se consumieron cada uno de los 12 grupos  de alimentos por el ponderador utilizado por el Programa Mundial de Alimentos (`PMA`) de las Naciones Unidas:   

`Grupo 1`: (ma칤z, avena, arroz, sorgo, mijo, pan y otros cereales) y (yuca, papas, camotes y otros tub칠rculos)  
`Grupo 2`: frijoles, ch칤charos, cacahuates, nueces  
`Grupo 3`: vegetales y hojas  
`Grupo 4`: frutas  
`Grupo 5`: carne de res, cabra, aves, cerdo, huevos y pescado  
`Grupo 6`: leche, yogur y otros l치cteos  
`Grupo 7`: az칰cares y productos azucarados  
`Grupo 8`: aceites, grasas y mantequilla  
`Grupo 9`: especias, t칠, caf칠, sal, polvo de pescado, peque침as cantidades de leche para el t칠  

El ponderador para el `Grupo 1` es 2, para el `Grupo 2` es 3, para el `Grupo 3` y `Grupo 4` es 1, para el `Grupo 5` y `Grupo 6` es 4, para el `Grupo 7` y `Grupo 8` es 0.5, y para el `Grupo 9` es 0.    


```{python}
alimentacion['cpond1'] = np.where(alimentacion['alim17_1'] > alimentacion['alim17_2'],
                                   alimentacion['alim17_1'],
                                    alimentacion['alim17_2']) * 2
alimentacion['cpond3'] = alimentacion['alim17_3'] * 1
alimentacion['cpond4'] = alimentacion['alim17_4'] * 1
alimentacion['cpond5'] = alimentacion[['alim17_5', 'alim17_6', 'alim17_7']].apply(lambda row: max(row), axis = 1) * 4
alimentacion['cpond8'] = alimentacion['alim17_8'] * 3
alimentacion['cpond9'] = alimentacion['alim17_9'] * 4
alimentacion['cpond10'] = alimentacion['alim17_10'] * 0.5
alimentacion['cpond11'] = alimentacion['alim17_11'] * 0.5
alimentacion['cpond12'] = alimentacion['alim17_12'] * 0

# Puntaje total de consumo ponderado de alimentos, indica el n칰mero ponderado de grupos de alimentos que se consumieron en los 칰ltimos siete d칤as.   
alimentacion['tot_cpond'] = alimentacion['cpond1' 
                             ] + alimentacion['cpond3'
                             ] + alimentacion['cpond4'
                             ] + alimentacion['cpond5'
                             ] + alimentacion['cpond8'
                             ] + alimentacion['cpond9'
                             ] + alimentacion['cpond10'
                             ] + alimentacion['cpond11'
                             ] + alimentacion['cpond12']

# Se categoriza la dieta consumida en los hogares
## Dieta consumida en los hogares
alimentacion['dch'] = np.NaN
alimentacion.loc[(alimentacion['tot_cpond'].between(0, 28)), 'dch'] = 1 # Pobre
alimentacion.loc[((alimentacion['tot_cpond'] > 28) &
                  (alimentacion['tot_cpond'] <= 42)), 'dch'] = 2 # Lim칤trofe
alimentacion.loc[((alimentacion['tot_cpond'] > 42) &
                  (~alimentacion['tot_cpond'].isna())), 'dch'] = 3 # Aceptable

## Limitaci칩n en el consumo de Alimentos
alimentacion['lca'] = np.NaN
alimentacion.loc[((alimentacion['dch'] == 1) |
                  (alimentacion['dch'] == 2)), 'lca'] = 1 # Limitado
alimentacion.loc[(alimentacion['dch'] == 3), 'lca'] = 0 # No limitado
```


###### Indicador de carencia por acceso a la alimentaci칩n nutritiva y de calidad   

Se considera en situaci칩n de carencia por acceso a la alimentaci칩n nutritiva y de calidad a la poblaci칩n en hogares que presenten, al menos, una de las siguientes caracter칤sticas:
  
1. Grado inseguridad alimentaria moderada o severa.   
2. Limitaci칩n en el consumo de alimentos.  


```{python}
alimentacion['ic_ali_nc'] = np.NaN
alimentacion.loc[((alimentacion['ic_ali'] == 0) &
                    (alimentacion['lca'] == 0)), 'ic_ali_nc'] = 0 # Sin carencia
alimentacion.loc[((alimentacion['ic_ali'] == 1) |
                  (alimentacion['lca'] == 1) &
                   ((~alimentacion['ic_ali'].isna()) &
                    (~alimentacion['lca'].isna()))), 'ic_ali_nc'] = 1 # Con carencia

alimentacion = alimentacion[['folioviv', 'foliohog', 'ia_1ad', 'ia_2ad', 'ia_3ad', 'ia_4ad', 'ia_5ad', 'ia_6ad',
                             'ia_7men', 'ia_8men', 'ia_9men', 'ia_10men', 'ia_11men', 'ia_12men', 'id_men',
                             'tot_iaad', 'tot_iamen', 'ins_ali', 'dch', 'lca', 'ic_ali', 'ic_ali_nc']]
```


**Se guarda la base de datos** 
```{python}
alimentacion.to_csv(current_directory + '/Output/Data/' + '/ic_ali22.csv', index = False)
```

##### Opci칩n 2 {.tabset .tabset-pills .top4-tiles} 
 
###### Grado de inseguridad alimentaria

```{python}
def indicador_menores_alimentacion (poblacion):
    # Funciones auxiliares
    def filtrar_poblacion_objetivo(df):
        return df[~((df['parentesco'] >= 400) & (df['parentesco'] < 500) | 
                    (df['parentesco'] >= 700) & (df['parentesco'] < 800))]
    
    def crear_indicador_menores(df):
        df['men'] = np.NaN
        df.loc[df['edad'].between(0, 17), 'men'] = 1
        return df
    
    def agrupar_y_contar_menores(df):
        return df.groupby(['folioviv', 'foliohog'])['men'].sum().dropna().reset_index()
    
    def calcular_id_men(df):
        df['id_men'] = np.NaN
        df.loc[(df['men'] >= 1) & (~df['men'].isna()), 'id_men'] = 1
        df.loc[df['men'] == 0, 'id_men'] = 0
        return df
      
      # Seleccionar columnas finales
    def seleccionar_columnas(df):
        columnas = ['folioviv', 'foliohog', 'id_men']
                    
        return df[columnas]  
      
    return (poblacion.copy()
                     .pipe(filtrar_poblacion_objetivo)
                     .pipe(crear_indicador_menores)
                     .pipe(agrupar_y_contar_menores)
                     .pipe(calcular_id_men)
                     .pipe(seleccionar_columnas)
                     )

# Uso de la funci칩n principal
menores_alimentacion = indicador_menores_alimentacion(poblacion)
```

**Se guarda la base de datos** 
```{python}
menores_alimentacion.to_csv(current_directory + '/Output/Data/' + '/menores22_2.csv', index = False)
```

####### Grado de inseguridad alimentaria 

```{python}
hogares = pd.read_csv(current_directory + "/Bases de datos/hogares.csv", low_memory = False)
```

```{python}
def indicador_alimentacion(hogares):
    # Funciones auxiliares
    def convertir_a_numerico(df):
        columnas = [
            'acc_alim2', 'acc_alim4', 'acc_alim5', 'acc_alim6', 'acc_alim7', 'acc_alim8', 
            'acc_alim11', 'acc_alim12', 'acc_alim13', 'acc_alim14', 'acc_alim15', 'acc_alim16'
        ]
        df[columnas] = df[columnas].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    def crear_indicador_adultos(df):
        indicadores_adultos = {
            'ia_1ad': 'acc_alim4', 'ia_2ad': 'acc_alim5', 'ia_3ad': 'acc_alim6', 
            'ia_4ad': 'acc_alim2', 'ia_5ad': 'acc_alim7', 'ia_6ad': 'acc_alim8'
        }
        
        for indicador, columna in indicadores_adultos.items():
            df[indicador] = np.NaN
            df.loc[df[columna] == 2, indicador] = 0
            df.loc[df[columna].isna(), indicador] = 0
            df.loc[df[columna] == 1, indicador] = 1
        
        return df
    
    def crear_indicador_menores(df):
        indicadores_menores = {
            'ia_7men': 'acc_alim11', 'ia_8men': 'acc_alim12', 'ia_9men': 'acc_alim13', 
            'ia_10men': 'acc_alim14', 'ia_11men': 'acc_alim15', 'ia_12men': 'acc_alim16'
        }
        
        for indicador, columna in indicadores_menores.items():
            df[indicador] = np.NaN
            df.loc[df[columna] == 2, indicador] = 0
            df.loc[df[columna].isna(), indicador] = 0
            df.loc[df[columna] == 1, indicador] = 1
        
        return df
    # Funciones auxiliares
    def merge_menores_alimentacion(df):
        return pd.merge(df, 
                         menores_alimentacion, 
                          on = ['folioviv', 'foliohog'],
                           how = 'left')
                           
        # Funci칩n para convertir variables string a num칠ricas
    def convertir_a_numerico_2(df):
        columnas = [
            'id_men', 'ia_1ad', 'ia_2ad', 'ia_3ad', 'ia_4ad', 'ia_5ad', 'ia_6ad', 'ia_7men', 'ia_8men',
            'ia_9men', 'ia_10men', 'ia_11men', 'ia_12men', 'alim17_1', 'alim17_2', 'alim17_3', 'alim17_4',
            'alim17_5', 'alim17_6', 'alim17_7', 'alim17_8', 'alim17_9', 'alim17_10', 'alim17_11', 'alim17_12'
        ]
        df[columnas] = df[columnas].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    # Funci칩n para calcular los totales de inseguridad alimentaria
    def calcular_totales_inseguridad(df):
        df['tot_iaad'] = np.NaN
        df.loc[df['id_men'] == 0, 'tot_iaad'] = (
                                                 df['ia_1ad'] + df['ia_2ad'] + df['ia_3ad'] + df['ia_4ad'] +
                                                 df['ia_5ad'] + df['ia_6ad']
                                                )
        
        df['tot_iamen'] = np.NaN
        df.loc[df['id_men'] == 1, 'tot_iamen'] = (
                                                  df['ia_1ad'] + df['ia_2ad'] + df['ia_3ad'] + df['ia_4ad'] +
                                                  df['ia_5ad'] + df['ia_6ad'] + df['ia_7men'] + df['ia_8men'] +
                                                  df['ia_9men'] + df['ia_10men'] + df['ia_11men'] + df['ia_12men']
                                                  )
        return df
    
    # Funci칩n para calcular el grado de inseguridad alimentaria
    def calcular_grado_inseguridad(df):
        df['ins_ali'] = np.NaN
        df.loc[(df['tot_iaad'] == 0) | (df['tot_iamen'] == 0), 'ins_ali'] = 0
        df.loc[(df['tot_iaad'].isin([1, 2])) | (df['tot_iamen'].isin([1, 2, 3])), 'ins_ali'] = 1
        df.loc[(df['tot_iaad'].isin([3, 4])) | (df['tot_iamen'].isin([4, 5, 6, 7])), 'ins_ali'] = 2
        df.loc[(df['tot_iaad'].isin([5, 6])) | (df['tot_iamen'] >= 8),'ins_ali'] = 3
        
        return df
    
    # Funci칩n para calcular el indicador de carencia por acceso a la alimentaci칩n
    def calcular_indicador_carencia(df):
        df['ic_ali'] = np.NaN
        df.loc[df['ins_ali'].isin([2, 3]), 'ic_ali'] = 1  # Con carencia
        df.loc[df['ins_ali'].isin([0, 1]), 'ic_ali'] = 0  # Sin carencia
        return df
      
    return (hogares.copy()
                   .pipe(convertir_a_numerico)
                   .pipe(crear_indicador_adultos)
                   .pipe(crear_indicador_menores)
                   .pipe(merge_menores_alimentacion)
                   .pipe(convertir_a_numerico_2)
                   .pipe(calcular_totales_inseguridad)
                   .pipe(calcular_grado_inseguridad)
                   .pipe(calcular_indicador_carencia)
                   )
alimentacion = indicador_alimentacion(hogares)                   
```


###### Limitaci칩n en el consumo de alimentos  

Se considera el n칰mero de d칤as que se consumieron cada uno de los 12 grupos  de alimentos por el ponderador utilizado por el Programa Mundial de Alimentos (`PMA`) de las Naciones Unidas:   

`Grupo 1`: (ma칤z, avena, arroz, sorgo, mijo, pan y otros cereales) y (yuca, papas, camotes y otros tub칠rculos)  
`Grupo 2`: frijoles, ch칤charos, cacahuates, nueces  
`Grupo 3`: vegetales y hojas  
`Grupo 4`: frutas  
`Grupo 5`: carne de res, cabra, aves, cerdo, huevos y pescado  
`Grupo 6`: leche, yogur y otros l치cteos  
`Grupo 7`: az칰cares y productos azucarados  
`Grupo 8`: aceites, grasas y mantequilla  
`Grupo 9`: especias, t칠, caf칠, sal, polvo de pescado, peque침as cantidades de leche para el t칠  

El ponderador para el `Grupo 1` es 2, para el `Grupo 2` es 3, para el `Grupo 3` y `Grupo 4` es 1, para el `Grupo 5` y `Grupo 6` es 4, para el `Grupo 7` y `Grupo 8` es 0.5, y para el `Grupo 9` es 0.    


```{python}
def indicador_alimentacion_anexoa(alimentacion):
    # Funci칩n para calcular los diferentes valores de cpond
    def calcular_cpond(df):
        df['cpond1'] = np.where(df['alim17_1'] > df['alim17_2'], df['alim17_1'], df['alim17_2']) * 2
        df['cpond3'] = df['alim17_3'] * 1
        df['cpond4'] = df['alim17_4'] * 1
        df['cpond5'] = df[['alim17_5', 'alim17_6', 'alim17_7']].apply(lambda row: max(row), axis=1) * 4
        df['cpond8'] = df['alim17_8'] * 3
        df['cpond9'] = df['alim17_9'] * 4
        df['cpond10'] = df['alim17_10'] * 0.5
        df['cpond11'] = df['alim17_11'] * 0.5
        df['cpond12'] = df['alim17_12'] * 0
        return df
    
    # Funci칩n para calcular el puntaje total de consumo ponderado de alimentos
    def calcular_tot_cpond(df):
        df['tot_cpond'] = (df['cpond1'] + df['cpond3'] + df['cpond4'] + df['cpond5'] + df['cpond8'] + 
                           df['cpond9'] + df['cpond10'] + df['cpond11'] + df['cpond12'])
        return df
    
    # Funci칩n para categorizar la dieta consumida en los hogares
    def categorizar_dieta(df):
        df['dch'] = np.NaN
        df.loc[df['tot_cpond'].between(0, 28), 'dch'] = 1  # Pobre
        df.loc[(df['tot_cpond'] > 28) & (df['tot_cpond'] <= 42), 'dch'] = 2  # Lim칤trofe
        df.loc[(df['tot_cpond'] > 42) & (~df['tot_cpond'].isna()), 'dch'] = 3  # Aceptable
        
        return df
    
    # Funci칩n para calcular la limitaci칩n en el consumo de alimentos
    def calcular_limitacion_consumo(df):
        df['lca'] = np.NaN
        df.loc[(df['dch'] == 1) | (df['dch'] == 2), 'lca'] = 1  # Limitado
        df.loc[df['dch'] == 3, 'lca'] = 0  # No limitado
        
        return df
      
    return (alimentacion.copy()
                        .pipe(calcular_cpond)
                        .pipe(calcular_tot_cpond)
                        .pipe(categorizar_dieta)
                        .pipe(calcular_limitacion_consumo)
                        )

alimentacion = indicador_alimentacion_anexoa(alimentacion) 
```


###### Indicador de carencia por acceso a la alimentaci칩n nutritiva y de calidad   

Se considera en situaci칩n de carencia por acceso a la alimentaci칩n nutritiva y de calidad a la poblaci칩n en hogares que presenten, al menos, una de las siguientes caracter칤sticas:
  
1. Grado inseguridad alimentaria moderada o severa.   
2. Limitaci칩n en el consumo de alimentos.  


```{python}
def indicador_alimentacion_anexob(alimentacion):
      # Funci칩n para calcular la columna ic_ali_nc
    def calcular_ic_ali_nc(df):
        df['ic_ali_nc'] = np.NaN
        df.loc[(df['ic_ali'] == 0) & (df['lca'] == 0), 'ic_ali_nc'] = 0  # Sin carencia
        df.loc[(df['ic_ali'] == 1) | ((df['lca'] == 1) & (~df['ic_ali'].isna()) & (~df['lca'].isna())), 'ic_ali_nc'] = 1  # Con carencia
        return df
    
    # Funci칩n para seleccionar las columnas finales
    def seleccionar_columnas_finales(df):
        columnas = ['folioviv', 'foliohog', 'ia_1ad', 'ia_2ad', 'ia_3ad', 'ia_4ad', 'ia_5ad', 'ia_6ad',
                    'ia_7men', 'ia_8men', 'ia_9men', 'ia_10men', 'ia_11men', 'ia_12men', 'id_men',
                    'tot_iaad', 'tot_iamen', 'ins_ali', 'dch', 'lca', 'ic_ali', 'ic_ali_nc']
        return df[columnas]
      
    return (alimentacion.copy()
                        .pipe(calcular_ic_ali_nc)
                        .pipe(seleccionar_columnas_finales))
                        
alimentacion = indicador_alimentacion_anexob(alimentacion) 
```


**Se guarda la base de datos** 
```{python}
alimentacion.to_csv(current_directory + '/Output/Data/' + 'ic_ali22_2.csv', index = False)
```


#### VII. Bienestar econ칩mico (ingresos) {.tabset .tabset-pills .top3-tiles}   

##### Opci칩n 1 {.tabset .tabset-pills .top4-tiles}   

###### Ingresos    

Para la construcci칩n del ingreso corriente del hogar es necesario utilizar informaci칩n sobre la condici칩n de ocupaci칩n y los ingresos de los individuos.  
Se utiliza la informaci칩n contenida en la base trabajo.csv para identificar a la poblaci칩n ocupada que declara tener como prestaci칩n laboral aguinaldo, ya sea por su trabajo principal o secundario, a fin de incorporar los ingresos por este concepto en la medici칩n

Creaci칩n del ingreso monetario deflactado a pesos de agosto del 2022   

```{python}
trabajos = pd.read_csv(current_directory + "/Bases de datos/trabajos.csv", low_memory = False)
```


```{python}
aguinaldos = trabajos.copy()

#Convirtiendo variables string a numericas
aguinaldos[['numren', 'id_trabajo', 'pres_2']
           ] = aguinaldos[['numren', 'id_trabajo', 'pres_2']
                          ].apply(pd.to_numeric, errors = 'coerce')

#Generando la base de aguinaldo
aguinaldos = pd.pivot_table(aguinaldos, 
                             index=['folioviv', 'foliohog', 'numren'], 
                              columns = 'id_trabajo', 
                               values=['pres_2'], 
                                aggfunc = np.sum, 
                                 fill_value = 0)
                                 
aguinaldos.columns = [f'{i}{j}' for i, j in aguinaldos.columns]
aguinaldos = aguinaldos.reset_index()

aguinaldos['trab'] = 1 # Poblaci칩n con al menos un empleo 

aguinaldos['aguinaldo1'] = np.where(aguinaldos['pres_21'] == 2, 1, 0) # Aguinaldo trabajo principal
aguinaldos['aguinaldo2'] = np.where(aguinaldos['pres_22'] == 2, 1, 0) # Aguinaldo trabajo secundario

aguinaldos = aguinaldos[['folioviv', 'foliohog', 'numren', 'aguinaldo1', 'aguinaldo2', 'trab']]
```

**Se guarda la base de datos** 
```{python}
aguinaldos.to_csv(current_directory + '/Output/Data/' + 'aguinaldo22.csv', index = False)
```

**Ahora se incorpora a la base de ingresos**

```{python}
ingresos = pd.read_csv(current_directory + "/Bases de datos/ingresos.csv", low_memory = False)
```


```{python}
ingreso_deflactado = ingresos.copy()

ingreso_deflactado = pd.merge(ingresos, 
                               aguinaldos, 
                                on = ['folioviv', 'foliohog', 'numren'], 
                                 how = 'outer') 

ingreso_deflactado = ingreso_deflactado[~(((ingreso_deflactado['clave'] == 'P009') & (ingreso_deflactado['aguinaldo1'] != 1)) |
                                          ((ingreso_deflactado['clave'] == 'P016') & (ingreso_deflactado['aguinaldo2'] != 1)))]
```

Una vez realizado lo anterior, se procede a deflactar el ingreso recibido por los hogares a precios de agosto de 2022. Para ello, se utilizan las variables meses, las cuales toman los valores 2 a 10 e indican el mes en que se recibi칩 el ingreso respectivo.   

**Definici칩n de los deflactores 2022**   

```{python}
# Definici칩n de los deflactores 2022 
dic21 =	0.9475376203	
ene22 =	0.9531433002
feb22 =	0.9610510246	
mar22 =	0.9705661414	
abr22 =	0.9758164180	
may22 =	0.9775368933
jun22 =	0.9857919437	
jul22 =	0.9930938669
ago22 =	1.0000000000
sep22 =	1.0062034038
oct22 =	1.0118979346
nov22 =	1.0177217030
dic22 =	1.0216069077
```

```{python}
#Convirtiendo variables string a numericas
ingreso_deflactado[['mes_1', 'mes_2', 'mes_3', 'mes_4', 'mes_5', 'mes_6', 'ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']
                     ] = ingreso_deflactado[['mes_1', 'mes_2', 'mes_3', 'mes_4', 'mes_5', 'mes_6', 'ing_1', 'ing_2', 'ing_3', 'ing_4',
                                               'ing_5', 'ing_6']
                                              ].apply(pd.to_numeric, errors = 'coerce')

ingreso_deflactado['ing_6'] = np.where(ingreso_deflactado['mes_6'].isna(), 
                                        ingreso_deflactado['ing_6'] ,
                              np.where(ingreso_deflactado['mes_6'] == 2, 
                                        ingreso_deflactado['ing_6'] / feb22,
                              np.where(ingreso_deflactado['mes_6'] == 3, 
                                        ingreso_deflactado['ing_6'] / mar22,
                              np.where(ingreso_deflactado['mes_6'] == 4, 
                                        ingreso_deflactado['ing_6'] / abr22,
                                         ingreso_deflactado['ing_6'] / may22))))
ingreso_deflactado['ing_5'] = np.where(ingreso_deflactado['mes_5'].isna(), 
                                        ingreso_deflactado['ing_5'] ,
                              np.where(ingreso_deflactado['mes_5'] == 3, 
                                        ingreso_deflactado['ing_5'] / mar22,
                              np.where(ingreso_deflactado['mes_5'] == 4, 
                                        ingreso_deflactado['ing_5'] / abr22,
                              np.where(ingreso_deflactado['mes_5'] == 5, 
                                        ingreso_deflactado['ing_5'] / may22,
                                         ingreso_deflactado['ing_5'] / jun22))))
ingreso_deflactado['ing_4'] = np.where(ingreso_deflactado['mes_4'].isna(), 
                                        ingreso_deflactado['ing_4'] ,
                              np.where(ingreso_deflactado['mes_4'] == 4,  
                                        ingreso_deflactado['ing_4'] / abr22,
                              np.where(ingreso_deflactado['mes_4'] == 5, 
                                        ingreso_deflactado['ing_4'] / may22,
                              np.where(ingreso_deflactado['mes_4'] == 6, 
                                        ingreso_deflactado['ing_4'] / jun22,
                                         ingreso_deflactado['ing_4'] / jul22))))
ingreso_deflactado['ing_3'] = np.where(ingreso_deflactado['mes_3'].isna(), 
                                        ingreso_deflactado['ing_3'] ,
                              np.where(ingreso_deflactado['mes_3'] == 5, 
                                        ingreso_deflactado['ing_3'] / may22,
                              np.where(ingreso_deflactado['mes_3'] == 6,  
                                        ingreso_deflactado['ing_3'] / jun22,
                              np.where(ingreso_deflactado['mes_3'] == 7, 
                                        ingreso_deflactado['ing_3'] / jul22,
                                         ingreso_deflactado['ing_3'] / ago22))))
ingreso_deflactado['ing_2'] = np.where(ingreso_deflactado['mes_2'].isna(), 
                                        ingreso_deflactado['ing_2'] ,
                              np.where(ingreso_deflactado['mes_2'] == 6, 
                                        ingreso_deflactado['ing_2'] / jun22,
                              np.where(ingreso_deflactado['mes_2'] == 7, 
                                        ingreso_deflactado['ing_2'] / jul22,
                              np.where(ingreso_deflactado['mes_2'] == 8, 
                                        ingreso_deflactado['ing_2'] / ago22,
                                         ingreso_deflactado['ing_2'] / sep22))))
ingreso_deflactado['ing_1'] = np.where(ingreso_deflactado['mes_1'].isna(), 
                                        ingreso_deflactado['ing_1'] ,
                              np.where(ingreso_deflactado['mes_1'] == 7, 
                                        ingreso_deflactado['ing_1'] / jul22,
                              np.where(ingreso_deflactado['mes_1'] == 8, 
                                        ingreso_deflactado['ing_1'] / ago22,
                              np.where(ingreso_deflactado['mes_1'] == 9, 
                                        ingreso_deflactado['ing_1'] / sep22,
                                         ingreso_deflactado['ing_1'] / oct22))))
```

Se deflactan las claves P008 y P015 (Reparto de utilidades) y P009 y P016 (aguinaldo) con los deflactores de mayo a agosto 2022 y de diciembre de 2021 a agosto 2022, respectivamente, y se obtiene el promedio mensual.   

```{python}
index = ['P008', 'P009', 'P015', 'P016']
```

```{python}
ingreso_deflactado.loc[ingreso_deflactado['clave'].isin(['P008', 'P015']), 'ing_1'] = ingreso_deflactado['ing_1'] / may22 / 12
ingreso_deflactado.loc[ingreso_deflactado['clave'].isin(['P009', 'P016']), 'ing_1'] = ingreso_deflactado['ing_1'] / dic21 / 12

cols = ['ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']
for col in cols:
    ingreso_deflactado.loc[ingreso_deflactado['clave'].isin(index) & ([col] == 0), col] = None
    
# Una vez realizada la deflactaci칩n, se procede a obtener el ingreso mensual promedio en los 칰ltimos seis meses, para cada persona y clave de ingreso
ingreso_deflactado['ing_mens'] = ingreso_deflactado[['ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']].mean(axis = 1, skipna = True)

# Para obtener el ingreso corriente monetario, se seleccionan las claves de ingreso correspondientes
ingreso_deflactado.loc[((ingreso_deflactado['clave'].between('P001', 'P009')) |
                        (ingreso_deflactado['clave'].between('P011', 'P016')) | 
                         (ingreso_deflactado['clave'].between('P018', 'P048')) | 
                          (ingreso_deflactado['clave'].between('P067', 'P081')) | 
                           (ingreso_deflactado['clave'].between('P101', 'P108'))), 'ing_mon'] = ingreso_deflactado['ing_mens']

# Para obtener el ingreso laboral, se seleccionan las claves de ingreso correspondientes
ingreso_deflactado.loc[((ingreso_deflactado['clave'].between('P001', 'P009')) | 
                        (ingreso_deflactado['clave'].between('P011', 'P016')) | 
                         (ingreso_deflactado['clave'].between('P018', 'P022')) | 
                          (ingreso_deflactado['clave'].between('P067', 'P081'))), 'ing_lab'] = ingreso_deflactado['ing_mens']

# Para obtener el ingreso por rentas, se seleccionan las claves de ingreso correspondientes
ingreso_deflactado.loc[ingreso_deflactado['clave'].between('P023', 'P031'), 'ing_ren'] = ingreso_deflactado['ing_mens']

# Para obtener el ingreso por transferencias, se seleccionan las claves de ingreso correspondientes
ingreso_deflactado.loc[((ingreso_deflactado['clave'].between('P032', 'P048')) | 
                        (ingreso_deflactado['clave'].between('P101', 'P108'))), 'ing_tra'] = ingreso_deflactado['ing_mens']

# Se estima el total de ingresos de cada  hogar
ingreso_deflactado = ingreso_deflactado.groupby(['folioviv', 'foliohog'])[['ing_mon', 'ing_lab', 'ing_ren', 'ing_tra']
                                                                          ].sum(numeric_only = True)
ingreso_deflactado = ingreso_deflactado.reset_index()
```

**Se guarda la base de datos** 
```{python}
ingreso_deflactado.to_csv(current_directory + '/Output/Data/' + '/ingreso_deflactado22.csv', index = False)
```

###### No Monetario  

En el caso de la informaci칩n de gasto no monetario, para deflactar se utiliza la decena de levantamiento de la encuesta, la cual se encuentra en la octava posici칩n del folio de la vivienda. En primer lugar se obtiene una variable que identifique la decena de levantamiento.   

Creaci칩n del ingreso no monetario deflactado a pesos de agosto del 2022.  

```{python}
gastoshogar = pd.read_csv(current_directory + "/Bases de datos/gastoshogar.csv", low_memory = False).astype(str)
gastospersona = pd.read_csv(current_directory + "/Bases de datos/gastospersona.csv", low_memory = False).astype(str)

gastoshogar['base'] = 1
```

```{python}
no_monetario = pd.concat([gastoshogar, gastospersona], 
                          ignore_index = True)
                          
no_monetario.loc[no_monetario['base'].isna(), 'base'] = 2

no_monetario.loc[no_monetario['base'] == 2, 'frecuencia'] = no_monetario['frec_rem']

# En el caso de la informaci칩n de gasto no monetario, para deflactar se utiliza la decena de levantamiento de la encuesta, 
# la cual se encuentra en la octava posici칩n del folio de la vivienda. En primer lugar se obtiene una variable que 
# identifique la decena de levantamiento.  

no_monetario['decena'] = no_monetario['folioviv'].astype(str).str.zfill(10).str[7]
```

**Definici칩n de los deflactores**

```{python}
# Definici칩n de los deflactores
d11w07 = 0.9869825057
d11w08 = 1.0000000000
d11w09 = 1.0130754464
d11w10 = 1.0178275200
d11w11 = 1.0207468579

# Rubro 1.2 semanal, Bebidas alcoh칩licas y tabaco		
d12w07 = 0.9923340135
d12w08 = 1.0000000000
d12w09 = 1.0035071112
d12w10 = 1.0111808568
d12w11 = 1.0131982216

# Rubro 2 trimestral, Vestido, calzado y accesorios		
d2t05 = 0.9899050815
d2t06 = 0.9941003723
d2t07 = 0.9997465345
d2t08 = 1.0083352270

# Rubro 3 mensual, viviendas		
d3m07 = 0.9998142481
d3m08 = 1.0000000000
d3m09 = 0.9978682753
d3m10 = 1.0031577830
d3m11 = 1.0197073965

# Rubro 4.2 mensual, Accesorios y art칤culos de limpieza para el hogar		
d42m07 = 0.9894769136
d42m08 = 1.0000000000
d42m09 = 1.0086286240
d42m10 = 1.0182083142
d42m11 = 1.0237613131

# Rubro 4.2 trimestral, Accesorios y art칤culos de limpieza para el hogar		
d42t05 = 0.9787953163
d42t06 = 0.9897197934
d42t07 = 0.9993685126
d42t08 = 1.0089456461

# Rubro 4.1 semestral, Muebles y aparatos d칩mesticos		
d41s02 = 1.0003069312
d41s03 = 0.9993861376
d41s04 = 0.9992122603
d41s05 = 0.9991442214

# Rubro 5.1 trimestral, Salud		
d51t05 = 0.9909917367
d51t06 = 0.9954834527
d51t07 = 0.9994564693
d51t08 = 1.0030487384

# Rubro 6.1.1 semanal, Transporte p칰blico urbano		
d611w07 = 0.9963207274
d611w08 = 1.0000000000
d611w09 = 1.0034865488
d611w10 = 1.0052385833
d611w11 = 1.0064912880

# Rubro 6 mensual, Transporte		
d6m07 = 0.9987845893
d6m08 = 1.0000000000
d6m09 = 1.0001664946
d6m10 = 1.0057274150
d6m11 = 1.0076837268

# Rubro 6 semestral, Transporte		
d6s02 = 0.9808628306
d6s03 = 0.9879901879
d6s04 = 0.9927380596
d6s05 = 0.9969378864

# Rubro 7 mensual, Educaci칩n y esparcimiento		
d7m07 = 0.9961413091
d7m08 = 1.0000000000
d7m09 = 1.0095233900
d7m10 = 1.0144128271
d7m11 = 1.0174522069

# Rubro 2.3 mensual, Accesorios y cuidados del vestido		
d23m07 = 0.9952443607
d23m08 = 1.0000000000
d23m09 = 1.0081869233
d23m10 = 1.0108184343
d23m11 = 1.0072323555

# Rubro 2.3 trimestral,  Accesorios y cuidados del vestido		
d23t05 = 0.9914948875
d23t06 = 0.9956428139
d23t07 = 1.0011437613
d23t08 = 1.0063351192

# INPC semestral		
dINPCs02 = 0.9773093813
dINPCs03 = 0.9838008772
dINPCs04 = 0.9897404209
dINPCs05 = 0.9957540070
```


**Una vez definidos los deflactores, se seleccionan los rubros** 

```{python}
#Convirtiendo variables string a numericas
no_monetario[['gas_nm_tri', 'gasto_nm']] = no_monetario[['gas_nm_tri', 'gasto_nm']
                                                        ].apply(pd.to_numeric, errors = 'coerce')

# Una vez definidos los deflactores, se seleccionan los rubros
no_monetario['gasnomon'] = no_monetario['gas_nm_tri'] / 3
no_monetario.loc[no_monetario['tipo_gasto'] == 'G4', 'esp'] = 1
no_monetario.loc[no_monetario['tipo_gasto'].isin(['G5', 'G6']), 'reg'] = 1
no_monetario = no_monetario.loc[~no_monetario['tipo_gasto'].isin(['G2', 'G3', 'G7'])]

# Control para la frecuencia de los regalos recibidos por el hogar
no_monetario = no_monetario[~(((no_monetario['frecuencia'].between('5', '6')) |
                               (no_monetario['frecuencia'].isna()) |
                                (no_monetario['frecuencia'] == '0')) &
                                 (no_monetario['base'] == 1) &
                                  (no_monetario['tipo_gasto'] == 'G5'))]

# Control para la frecuencia de los regalos recibidos por persona
no_monetario = no_monetario[~(((no_monetario['frecuencia'] == '9') |
                              (no_monetario['frecuencia'].isna())) &
                               (no_monetario['base'] == 2) &
                                (no_monetario['tipo_gasto'] == 'G5'))]

# Se deflactan los rubros del gasto no monetario seg칰n la decena de levantamiento 
no_monetario.loc[(no_monetario['clave'].between('A001', 'A222') |
                   no_monetario['clave'].between('A242', 'A247')), 'ali_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('A223', 'A241')), 'alta_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('H001', 'H122') |
                  (no_monetario['clave'] == 'H136')), 'veca_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('G001', 'G016') |
                   no_monetario['clave'].between('R001', 'R004') |
                    (no_monetario['clave'] == 'R013')), 'viv_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('C001', 'C024')), 'lim_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('I001', 'I026')), 'cris_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('K001', 'K037')), 'ens_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('J001', 'J072')), 'sal_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('B001', 'B007')), 'tpub_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('M001', 'M018') |
                   no_monetario['clave'].between('F007', 'F014')), 'tfor_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('F001', 'F006') |
                   no_monetario['clave'].between('R005', 'R008') |
                    no_monetario['clave'].between('R010', 'R011')), 'com_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('E001', 'E034') |
                   no_monetario['clave'].between('H134', 'H135') |
                    no_monetario['clave'].between('L001', 'L029') |
                     no_monetario['clave'].between('N003', 'N005') |
                      (no_monetario['clave'] == 'R009')), 'edre_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('E002', 'E003') |
                   no_monetario['clave'].between('H134', 'H135')), 'edba_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('D001', 'D026') |
                  (no_monetario['clave'] == 'H132')), 'cuip_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('H123', 'H131') |
                   (no_monetario['clave'] == 'H133')), 'accp_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('N001', 'N002') |
                   no_monetario['clave'].between('N006', 'N016') |
                    no_monetario['clave'].between('T901', 'T915') |
                     (no_monetario['clave'] == 'R012')), 'otr_nm'] = no_monetario['gasnomon']
no_monetario.loc[(no_monetario['clave'].between('T901', 'T915') |
                  (no_monetario['clave'] == 'N013')), 'reda_nm'] = no_monetario['gasnomon']

# Gasto no monetario en Alimentos deflactado (semanal)
no_monetario['ali_nm'] = np.where(no_monetario['decena'].isin(['1','2','3']), no_monetario['ali_nm']/d11w08, 
                          np.where(no_monetario['decena'].isin(['4','5','6']), no_monetario['ali_nm']/d11w09,
                           np.where(no_monetario['decena'].isin(['7','8','9']), no_monetario['ali_nm']/d11w10,
                                    no_monetario['ali_nm']/d11w11)))

# Gasto no monetario en Alcohol y tabaco deflactado (semanal)
no_monetario['alta_nm'] = np.where(no_monetario['decena'].isin(['1','2','3']), no_monetario['alta_nm']/d12w08,
                           np.where(no_monetario['decena'].isin(['4','5','6']), no_monetario['alta_nm']/d12w09,
                            np.where(no_monetario['decena'].isin(['7','8','9']), no_monetario['alta_nm']/d12w10,
                                      no_monetario['alta_nm']/d12w11)))

# Gasto no monetario en Vestido y calzado deflactado (trimestral)
no_monetario['veca_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['veca_nm']/d2t05,
                           np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['veca_nm']/d2t06,
                            np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['veca_nm']/d2t07,
                                      no_monetario['veca_nm']/d2t08)))

# Gasto no monetario en viviendas y servicios de conservaci칩n deflactado (mensual)
no_monetario['viv_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['viv_nm']/d3m07,
                          np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['viv_nm']/d3m08,
                           np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['viv_nm']/d3m09,
                                     no_monetario['viv_nm']/d3m10)))

# Gasto no monetario en Art칤culos de limpieza deflactado (mensual)
no_monetario['lim_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['lim_nm']/d42m07,
                          np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['lim_nm']/d42m08,
                           np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['lim_nm']/d42m09,
                                     no_monetario['lim_nm']/d42m10)))

# Gasto no monetario en Cristaler칤a y blancos deflactado (trimestral)
no_monetario['cris_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['cris_nm']/d42t05,
                           np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['cris_nm']/d42t06,
                            np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['cris_nm']/d42t07,
                                      no_monetario['cris_nm']/d42t08)))

# Gasto no monetario en Enseres dom칠sticos y muebles deflactado (semestral)
no_monetario['ens_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['ens_nm']/d41s02,
                          np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['ens_nm']/d41s03,
                           np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['ens_nm']/d41s04,
                                     no_monetario['ens_nm']/d41s05)))

# Gasto no monetario en Salud deflactado (trimestral)
no_monetario['sal_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['sal_nm']/d51t05,
                          np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['sal_nm']/d51t06,
                           np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['sal_nm']/d51t07,
                                     no_monetario['sal_nm']/d51t08)))

# Gasto no monetario en Transporte p칰blico deflactado (semanal)
no_monetario['tpub_nm'] = np.where(no_monetario['decena'].isin(['1','2','3']), no_monetario['tpub_nm']/d611w08,
                           np.where(no_monetario['decena'].isin(['4','5','6']), no_monetario['tpub_nm']/d611w09,
                            np.where(no_monetario['decena'].isin(['7','8','9']), no_monetario['tpub_nm']/d611w10,
                                      no_monetario['tpub_nm']/d611w11)))

# Gasto no monetario en Transporte for치neo deflactado (semestral)
no_monetario['tfor_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['tfor_nm']/d6s02,
                           np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['tfor_nm']/d6s03,
                            np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['tfor_nm']/d6s04,
                                      no_monetario['tfor_nm']/d6s05)))

# Gasto no monetario en Comunicaciones deflactado (mensual)
no_monetario['com_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['com_nm']/d6m07,
                          np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['com_nm']/d6m08,
                           np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['com_nm']/d6m09,
                                     no_monetario['com_nm']/d6m10)))

# Gasto no monetario en Educaci칩n y recreaci칩n deflactado (mensual)
no_monetario['edre_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['edre_nm']/d7m07,
                           np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['edre_nm']/d7m08,
                            np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['edre_nm']/d7m09,
                                      no_monetario['edre_nm']/d7m10)))

# Gasto no monetario en Educaci칩n b치sica deflactado (mensual)
no_monetario['edba_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['edba_nm']/d7m07,
                           np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['edba_nm']/d7m08,
                            np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['edba_nm']/d7m09,
                                      no_monetario['edba_nm']/d7m10)))

# Gasto no monetario en Cuidado personal deflactado (mensual)
no_monetario['cuip_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['cuip_nm']/d23m07,
                           np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['cuip_nm']/d23m08,
                            np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['cuip_nm']/d23m09,
                                      no_monetario['cuip_nm']/d23m10)))

# Gasto no monetario en Accesorios personales deflactado (trimestral)
no_monetario['accp_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['accp_nm']/d23t05,
                           np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['accp_nm']/d23t06,
                            np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['accp_nm']/d23t07,
                                      no_monetario['accp_nm']/d23t08)))

# Gasto no monetario en Otros gastos y transferencias deflactado (semestral)
no_monetario['otr_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['otr_nm']/dINPCs02,
                          np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['otr_nm']/dINPCs03,
                           np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['otr_nm']/dINPCs04,
                                     no_monetario['otr_nm']/dINPCs05)))

# Gasto no monetario en Regalos Otorgados deflactado
no_monetario['reda_nm'] = np.where(no_monetario['decena'].isin(['1','2']), no_monetario['reda_nm']/dINPCs02,
                           np.where(no_monetario['decena'].isin(['3','4','5']), no_monetario['reda_nm']/dINPCs03,
                            np.where(no_monetario['decena'].isin(['6','7','8']), no_monetario['reda_nm']/dINPCs04,
                                      no_monetario['reda_nm']/dINPCs05)))
```

**Se guarda la base de datos** 
```{python}
no_monetario.to_csv(current_directory + '/Output/Data/' + '/ingresonomonetario_def22.csv', index = False)
```

**Construcci칩n de la base de pagos en especie a partir de la base de gasto no monetario**  

```{python}
# Construcci칩n de la base de pagos en especie a partir de la base de gasto no monetario
pagos_especie = no_monetario[no_monetario['esp'] == 1]

pagos_especie = pagos_especie.groupby(['folioviv', 'foliohog'])[['gasto_nm', 'ali_nm', 'alta_nm', 'veca_nm', 'viv_nm',
                                       'lim_nm', 'cris_nm', 'ens_nm', 'sal_nm', 'tpub_nm', 'tfor_nm', 'com_nm', 'edre_nm',
                                       'edba_nm', 'cuip_nm', 'accp_nm', 'otr_nm', 'reda_nm']].sum(numeric_only = True)

pagos_especie = pagos_especie.reset_index()

pagos_especie.columns = ['folioviv', 'foliohog', 'gasto_nm', 'ali_nme', 'alta_nme', 'veca_nme', 'viv_nme', 'lim_nme', 
                         'cris_nme', 'ens_nme', 'sal_nme', 'tpub_nme', 'tfor_nme', 'com_nme', 'edre_nme', 'edba_nme', 
                         'cuip_nme', 'accp_nme', 'otr_nme', 'reda_nme']
```

**Se guarda la base de datos** 
```{python}
pagos_especie.to_csv(current_directory + '/Output/Data/' + '/esp_def22.csv', index = False)
```


**Construcci칩n de base de regalos a partir de la base no monetaria**  

```{python}
# Construcci칩n de base de regalos a partir de la base no monetaria
regalos = no_monetario[no_monetario['reg'] == 1]

regalos = regalos.groupby(['folioviv', 'foliohog'])[['gasto_nm', 'ali_nm', 'alta_nm', 'veca_nm', 'viv_nm', 'lim_nm', 'cris_nm',
                                                     'ens_nm', 'sal_nm', 'tpub_nm', 'tfor_nm', 'com_nm', 'edre_nm', 'edba_nm',
                                                     'cuip_nm', 'accp_nm', 'otr_nm', 'reda_nm']].sum(numeric_only = True)
regalos = regalos.reset_index()

regalos.columns = ['folioviv', 'foliohog', 'gasto_nm', 'ali_nmr', 'alta_nmr', 'veca_nmr', 'viv_nmr', 'lim_nmr', 'cris_nmr',
                   'ens_nmr', 'sal_nmr', 'tpub_nmr', 'tfor_nmr', 'com_nmr', 'edre_nmr', 'edba_nmr', 'cuip_nmr', 'accp_nmr',
                   'otr_nmr', 'reda_nmr']
```

**Se guarda la base de datos**
```{python}
regalos.to_csv(current_directory + '/Output/Data/' + '/reg_def22.csv', index = False)
```

##### Opci칩n 2 {.tabset .tabset-pills .top4-tiles}   

###### Ingresos    

Para la construcci칩n del ingreso corriente del hogar es necesario utilizar informaci칩n sobre la condici칩n de ocupaci칩n y los ingresos de los individuos.  
Se utiliza la informaci칩n contenida en la base trabajo.csv para identificar a la poblaci칩n ocupada que declara tener como prestaci칩n laboral aguinaldo, ya sea por su trabajo principal o secundario, a fin de incorporar los ingresos por este concepto en la medici칩n

Creaci칩n del ingreso monetario deflactado a pesos de agosto del 2022   

```{python}
trabajos = pd.read_csv(current_directory + "/Bases de datos/trabajos.csv", low_memory = False)
```


```{python}
def indicador_aguinaldos(trabajos):
    def convertir_a_numerico(df):
        columnas_a_convertir = ['numren', 'id_trabajo', 'pres_2']
        df[columnas_a_convertir] = df[columnas_a_convertir
                                     ].apply(pd.to_numeric, errors = 'coerce')
        return df
    
    def generar_base_aguinaldo(df):
        df = pd.pivot_table(df, 
                            index = ['folioviv', 'foliohog', 'numren'], 
                            columns = 'id_trabajo', 
                            values = ['pres_2'], 
                            aggfunc = np.sum, 
                            fill_value = 0)
        df.columns = [f'{i}{j}' for i, j in df.columns]
        df = df.reset_index()
        
        return df 
    
    def agregar_columnas_aguinaldo(df):
        df['trab'] = 1  # Poblaci칩n con al menos un empleo 
        df['aguinaldo1'] = np.where(df.get('pres_21', 0) == 2, 1, 0)  # Aguinaldo trabajo principal
        df['aguinaldo2'] = np.where(df.get('pres_22', 0) == 2, 1, 0)  # Aguinaldo trabajo secundario
        
        return df
    
    def seleccionar_columnas_finales(df):
        columnas_finales = ['folioviv', 'foliohog', 'numren', 'aguinaldo1', 'aguinaldo2', 'trab']
        
        return df[columnas_finales]
    
    # Aplicando las funciones utilizando pipe
    return (trabajos.copy()
                    .pipe(convertir_a_numerico)
                    .pipe(generar_base_aguinaldo)
                    .pipe(agregar_columnas_aguinaldo)
                    .pipe(seleccionar_columnas_finales))
                    
aguinaldos = indicador_aguinaldos(trabajos)
```

**Se guarda la base de datos** 
```{python}
aguinaldos.to_csv(current_directory + '/Output/Data/' + 'aguinaldo22_2.csv', index = False)
```

**Ahora se incorpora a la base de ingresos**

```{python}
ingresos = pd.read_csv(current_directory + "/Bases de datos/ingresos.csv", low_memory = False)
```


Se procede a deflactar el ingreso recibido por los hogares a precios de agosto de 2022. Para ello, se utilizan las variables meses, las cuales toman los valores 2 a 10 e indican el mes en que se recibi칩 el ingreso respectivo.   

**Definici칩n de los deflactores 2022**   

```{python}
deflactores = {
    1: 0.9531433002,
    2: 0.9610510246,
    3: 0.9705661414,
    4: 0.9758164180,
    5: 0.9775368933,
    6: 0.9857919437,
    7: 0.9930938669,
    8: 1.0000000000,
    9: 1.0062034038,
    10: 1.0118979346,
    11: 1.0177217030,
    12: 1.0216069077,
    'dic21': 0.9475376203
}
```

```{python}
def indicador_ingreso_deflactado(ingresos):
    def merge_aguinaldos(df, aguinaldos):
        """Fusiona las tablas de ingresos y aguinaldos."""
        return pd.merge(df, 
                         aguinaldos, 
                          on = ['folioviv', 'foliohog', 'numren'], 
                           how = 'outer')
    
    def filtrar_aguinaldos(df):
        """Filtra las filas basadas en las condiciones de aguinaldo."""
        condicion = ~(((df['clave'] == 'P009') & (df['aguinaldo1'] != 1)) |
                      ((df['clave'] == 'P016') & (df['aguinaldo2'] != 1)))
                      
        return df[condicion]
    
    def convertir_a_numerico(df):
        """Convierte columnas espec칤ficas a tipo num칠rico."""
        columnas_a_convertir = ['mes_1', 'mes_2', 'mes_3', 'mes_4', 'mes_5', 'mes_6', 
                                'ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']
        df[columnas_a_convertir] = df[columnas_a_convertir].apply(pd.to_numeric, errors = 'coerce')
        
        return df
    
        # Funci칩n auxiliar para deflactar ingresos
    def deflactar_ingreso(df, col_ingreso, col_mes):
        def deflactar(row):
            mes = row[col_mes]
            ingreso = row[col_ingreso]
            if pd.isna(mes) or pd.isna(ingreso):
                return ingreso
            return ingreso / deflactores.get(mes, 1.0)
    
        df[col_ingreso] = df.apply(deflactar, axis = 1)
        return df

        # Funci칩n auxiliar para deflactar ingresos
        # Aplicar la funci칩n a cada columna de ingreso
    def aplicar_deflactores(df):
        ingresos_meses = [
            ('ing_6', 'mes_6'),
            ('ing_5', 'mes_5'),
            ('ing_4', 'mes_4'),
            ('ing_3', 'mes_3'),
            ('ing_2', 'mes_2'),
            ('ing_1', 'mes_1')
        ]
        
        for col_ingreso, col_mes in ingresos_meses:
            df = deflactar_ingreso(df, col_ingreso, col_mes)
    
        return df

    #def deflactar_ingreso(df, mes_col, ing_col):
    #    """Aplica los deflactores a los ingresos seg칰n el mes correspondiente."""
    #    deflactor_col = f'deflactor_{mes_col}'
    #    df[deflactor_col] = df[mes_col].map(deflactores)
    #    df[ing_col] = df[ing_col] / df[deflactor_col]
        
    #    return df.drop(columns=[deflactor_col])
    
    #def aplicar_deflactores(df):
    #    """Deflacta los ingresos para cada mes."""
    #    for i in range(1, 7):
    #        mes_col = f'mes_{i}'
    #        ing_col = f'ing_{i}'
    #        df = df.pipe(deflactar_ingreso, mes_col, ing_col)
    #        
    #    return df
    
        # Aplicando las funciones utilizando pipe
    return (ingresos.copy()
                    .pipe(merge_aguinaldos, aguinaldos)
                    .pipe(filtrar_aguinaldos)
                    .pipe(convertir_a_numerico)
                    .pipe(aplicar_deflactores)
                    )
    
ingreso_deflactado = indicador_ingreso_deflactado(ingresos)
```

Se deflactan las claves P008 y P015 (Reparto de utilidades) y P009 y P016 (aguinaldo) con los deflactores de mayo a agosto 2022 y de diciembre de 2021 a agosto 2022, respectivamente, y se obtiene el promedio mensual.  

```{python}
# Definici칩n de los deflactores 2022
deflactores = {
    'dic21': 0.9475376203, 'ene22': 0.9531433002, 'feb22': 0.9610510246,
    'mar22': 0.9705661414, 'abr22': 0.9758164180, 'may22': 0.9775368933,
    'jun22': 0.9857919437, 'jul22': 0.9930938669, 'ago22': 1.0000000000,
    'sep22': 1.0062034038, 'oct22': 1.0118979346, 'nov22': 1.0177217030,
    'dic22': 1.0216069077
}
```


```{python}
index = ['P008', 'P009', 'P015', 'P016']
```

```{python}
def indicador_ingreso_deflactado_anexoa(ingreso_deflactado):
    def deflactar_ing_1(df):
        """Aplica deflactores espec칤ficos a ing_1 seg칰n la clave."""
        df.loc[df['clave'].isin(['P008', 'P015']), 'ing_1'] = df['ing_1'] /deflactores['may22'] / 12
        df.loc[df['clave'].isin(['P009', 'P016']), 'ing_1'] = df['ing_1'] /deflactores['dic21'] / 12
      
        return df

    def poner_nulos(df):
        """Pone valores nulos en ciertas columnas si las condiciones se cumplen."""
        cols = ['ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']
        for col in cols:
            df.loc[df['clave'].isin(index) & (df[col] == 0), col] = None
            
        return df
    
    def calcular_ingreso_mensual(df):
        """Calcula el ingreso mensual promedio en los 칰ltimos seis meses."""
        df['ing_mens'] = df[['ing_1', 'ing_2', 'ing_3', 'ing_4', 'ing_5', 'ing_6']].mean(axis = 1, skipna = True)
        
        return df
    
    def clasificar_ingresos(df):
        """Clasifica los ingresos en categor칤as espec칤ficas."""
        condiciones_mon = ((df['clave'].between('P001', 'P009')) |
                           (df['clave'].between('P011', 'P016')) | 
                           (df['clave'].between('P018', 'P048')) | 
                           (df['clave'].between('P067', 'P081')) | 
                           (df['clave'].between('P101', 'P108')))
        
        condiciones_lab = ((df['clave'].between('P001', 'P009')) | 
                           (df['clave'].between('P011', 'P016')) | 
                           (df['clave'].between('P018', 'P022')) | 
                           (df['clave'].between('P067', 'P081')))
        
        condiciones_ren = (df['clave'].between('P023', 'P031'))
        condiciones_tra = ((df['clave'].between('P032', 'P048')) | 
                           (df['clave'].between('P101', 'P108')))
        
        df.loc[condiciones_mon, 'ing_mon'] = df['ing_mens']
        df.loc[condiciones_lab, 'ing_lab'] = df['ing_mens']
        df.loc[condiciones_ren, 'ing_ren'] = df['ing_mens']
        df.loc[condiciones_tra, 'ing_tra'] = df['ing_mens']
        
        return df
    
    def sumar_ingresos_hogar(df):
        """Suma los ingresos por hogar."""
        df = df.groupby(['folioviv', 'foliohog'])[['ing_mon', 'ing_lab', 'ing_ren', 'ing_tra']
                                                  ].sum(numeric_only = True).reset_index()
        
        return df
      
    # Aplicando las funciones utilizando pipe
    return(ingreso_deflactado.copy()
                             .pipe(deflactar_ing_1)
                             .pipe(poner_nulos)
                             .pipe(calcular_ingreso_mensual)
                             .pipe(clasificar_ingresos)
                             .pipe(sumar_ingresos_hogar))

ingreso_deflactado = indicador_ingreso_deflactado_anexoa(ingreso_deflactado)
```

**Se guarda la base de datos** 
```{python}
ingreso_deflactado.to_csv(current_directory + '/Output/Data/' + '/ingreso_deflactado22_2.csv', index = False)
```

###### No Monetario  

En el caso de la informaci칩n de gasto no monetario, para deflactar se utiliza la decena de levantamiento de la encuesta, la cual se encuentra en la octava posici칩n del folio de la vivienda. En primer lugar se obtiene una variable que identifique la decena de levantamiento.   

Creaci칩n del ingreso no monetario deflactado a pesos de agosto del 2022.  

```{python}
gastoshogar = pd.read_csv(current_directory + "/Bases de datos/gastoshogar.csv", low_memory = False).astype(str)
gastospersona = pd.read_csv(current_directory + "/Bases de datos/gastospersona.csv", low_memory = False).astype(str)
```

**Definici칩n de los deflactores**

```{python}
# Definici칩n de los deflactores
d11w07 = 0.9869825057
d11w08 = 1.0000000000
d11w09 = 1.0130754464
d11w10 = 1.0178275200
d11w11 = 1.0207468579

# Rubro 1.2 semanal, Bebidas alcoh칩licas y tabaco		
d12w07 = 0.9923340135
d12w08 = 1.0000000000
d12w09 = 1.0035071112
d12w10 = 1.0111808568
d12w11 = 1.0131982216

# Rubro 2 trimestral, Vestido, calzado y accesorios		
d2t05 = 0.9899050815
d2t06 = 0.9941003723
d2t07 = 0.9997465345
d2t08 = 1.0083352270

# Rubro 3 mensual, viviendas		
d3m07 = 0.9998142481
d3m08 = 1.0000000000
d3m09 = 0.9978682753
d3m10 = 1.0031577830
d3m11 = 1.0197073965

# Rubro 4.2 mensual, Accesorios y art칤culos de limpieza para el hogar		
d42m07 = 0.9894769136
d42m08 = 1.0000000000
d42m09 = 1.0086286240
d42m10 = 1.0182083142
d42m11 = 1.0237613131

# Rubro 4.2 trimestral, Accesorios y art칤culos de limpieza para el hogar		
d42t05 = 0.9787953163
d42t06 = 0.9897197934
d42t07 = 0.9993685126
d42t08 = 1.0089456461

# Rubro 4.1 semestral, Muebles y aparatos d칩mesticos		
d41s02 = 1.0003069312
d41s03 = 0.9993861376
d41s04 = 0.9992122603
d41s05 = 0.9991442214

# Rubro 5.1 trimestral, Salud		
d51t05 = 0.9909917367
d51t06 = 0.9954834527
d51t07 = 0.9994564693
d51t08 = 1.0030487384

# Rubro 6.1.1 semanal, Transporte p칰blico urbano		
d611w07 = 0.9963207274
d611w08 = 1.0000000000
d611w09 = 1.0034865488
d611w10 = 1.0052385833
d611w11 = 1.0064912880

# Rubro 6 mensual, Transporte		
d6m07 = 0.9987845893
d6m08 = 1.0000000000
d6m09 = 1.0001664946
d6m10 = 1.0057274150
d6m11 = 1.0076837268

# Rubro 6 semestral, Transporte		
d6s02 = 0.9808628306
d6s03 = 0.9879901879
d6s04 = 0.9927380596
d6s05 = 0.9969378864

# Rubro 7 mensual, Educaci칩n y esparcimiento		
d7m07 = 0.9961413091
d7m08 = 1.0000000000
d7m09 = 1.0095233900
d7m10 = 1.0144128271
d7m11 = 1.0174522069

# Rubro 2.3 mensual, Accesorios y cuidados del vestido		
d23m07 = 0.9952443607
d23m08 = 1.0000000000
d23m09 = 1.0081869233
d23m10 = 1.0108184343
d23m11 = 1.0072323555

# Rubro 2.3 trimestral,  Accesorios y cuidados del vestido		
d23t05 = 0.9914948875
d23t06 = 0.9956428139
d23t07 = 1.0011437613
d23t08 = 1.0063351192

# INPC semestral		
dINPCs02 = 0.9773093813
dINPCs03 = 0.9838008772
dINPCs04 = 0.9897404209
dINPCs05 = 0.9957540070
```


Se cambia la estructura de los deflactores del c칩digo anterior para reducir el c치lculo como el chunk de la  `Opci칩n 1`.
Se seleccionan los deflactores que solamente pertencen al c치lculo de los rubros:    

```{python}
# Definici칩n de los deflactores
deflactores = {
    'ali_nm': [1.0000000000, 1.0130754464, 1.0178275200, 1.0207468579],
    'alta_nm': [1.0000000000, 1.0035071112, 1.0111808568, 1.0131982216],
    'veca_nm': [0.9899050815, 0.9941003723, 0.9997465345, 1.0083352270],
    'viv_nm': [0.9998142481, 1.0000000000, 0.9978682753, 1.0031577830],
    'lim_nm': [0.9894769136, 1.0000000000, 1.0086286240, 1.0182083142],
    'cris_nm': [0.9787953163, 0.9897197934, 0.9993685126, 1.0089456461],
    'ens_nm': [1.0003069312, 0.9993861376, 0.9992122603, 0.9991442214],
    'sal_nm': [0.9909917367, 0.9954834527, 0.9994564693, 1.0030487384],
    'tpub_nm': [1.0000000000, 1.0034865488, 1.0052385833, 1.0064912880],
    'tfor_nm': [0.9808628306, 0.9879901879, 0.9927380596, 0.9969378864],
    'com_nm': [0.9987845893, 1.0000000000, 1.0001664946, 1.0057274150],
    'edre_nm': [0.9961413091, 1.0000000000, 1.0095233900, 1.0144128271],
    'edba_nm': [0.9961413091, 1.0000000000, 1.0095233900, 1.0144128271],
    'cuip_nm': [0.9952443607, 1.0000000000, 1.0081869233, 1.0108184343],
    'accp_nm': [0.9914948875, 0.9956428139, 1.0011437613, 1.0063351192],
    'otr_nm': [0.9773093813, 0.9838008772, 0.9897404209, 0.9957540070],
    'reda_nm': [0.9773093813, 0.9838008772, 0.9897404209, 0.9957540070]
}
deflactores.keys()
```


```{python}
def indicador_no_monetario(gastoshogar):
    # Definir funciones auxiliares
    def merge_gastopersonas(df):
        df['base'] = 1
        df = pd.concat([df, gastospersona], ignore_index = True)
        return df
    
    def establecer_base_frecuencia(df):
        df.loc[df['base'].isna(), 'base'] = 2
        df.loc[df['base'] == 2, 'frecuencia'] = df['frec_rem']
        
        return df
    
    def definir_decena(df):
        df['decena'] = df['folioviv'].astype(str).str.zfill(10).str[7]
        
        return df
    
    def convertir_variables(df):
        df[['gas_nm_tri', 'gasto_nm']] = df[['gas_nm_tri', 'gasto_nm']].apply(pd.to_numeric, errors = 'coerce')
        
        return df
    
    def seleccionar_rubros(df):
        df['gasnomon'] = df['gas_nm_tri'] / 3
        df.loc[df['tipo_gasto'] == 'G4', 'esp'] = 1
        df.loc[df['tipo_gasto'].isin(['G5', 'G6']), 'reg'] = 1
        df = df.loc[~df['tipo_gasto'].isin(['G2', 'G3', 'G7'])]
        
        return df
    
    def controlar_frecuencia_regalos(df):
        df = df[~(((df['frecuencia'].between('5', '6')) |
                   (df['frecuencia'].isna()) |
                    (df['frecuencia'] == '0')) &
                     (df['base'] == 1) &
                      (df['tipo_gasto'] == 'G5'))]
    
        df = df[~(((df['frecuencia'] == '9') |
                   (df['frecuencia'].isna())) &
                    (df['base'] == 2) &
                     (df['tipo_gasto'] == 'G5'))]
        return df
    
    def deflactar_rubros(df):
        rubros = [
            ('A001', 'A222', 'ali_nm'),
            ('A242', 'A247', 'ali_nm'),
            ('A223', 'A241', 'alta_nm'),
            ('H001', 'H122', 'veca_nm'),
            ('H136', 'H136', 'veca_nm'),
            ('G001', 'G016', 'viv_nm'),
            ('R001', 'R004', 'viv_nm'),
            ('R013', 'R013', 'viv_nm'),
            ('C001', 'C024', 'lim_nm'),
            ('I001', 'I026', 'cris_nm'),
            ('K001', 'K037', 'ens_nm'),
            ('J001', 'J072', 'sal_nm'),
            ('B001', 'B007', 'tpub_nm'),
            ('M001', 'M018', 'tfor_nm'),
            ('F007', 'F014', 'tfor_nm'),
            ('F001', 'F006', 'com_nm'),
            ('R005', 'R008', 'com_nm'),
            ('R010', 'R011', 'com_nm'),
            ('E001', 'E034', 'edre_nm'),
            ('H134', 'H135', 'edre_nm'),
            ('L001', 'L029', 'edre_nm'),
            ('N003', 'N005', 'edre_nm'),
            ('R009', 'R009', 'edre_nm'),
            ('E002', 'E003', 'edba_nm'),
            ('H134', 'H135', 'edba_nm'),
            ('D001', 'D026', 'cuip_nm'),
            ('H132', 'H132', 'cuip_nm'),
            ('H123', 'H131', 'accp_nm'),
            ('H133', 'H133', 'accp_nm'),
            ('N001', 'N002', 'otr_nm'),
            ('N006', 'N016', 'otr_nm'),
            ('T901', 'T915', 'otr_nm'),
            ('R012', 'R012', 'otr_nm'),
            ('N013', 'N013', 'reda_nm')
        ]
    
        for inicio, fin, columna in rubros:
            df.loc[df['clave'].between(inicio, fin), columna] = df['gasnomon']
        
        return df

        # Funci칩n auxiliar para deflactar seg칰n los deflactores y la decena
    def deflactar(df, col_name, deflactores):
        deflact_values = deflactores[col_name]
        if len(deflact_values) == 4:
            conditions = [
                df['decena'].isin(['1', '2']),
                df['decena'].isin(['3', '4', '5']),
                df['decena'].isin(['6', '7', '8']),
                df['decena'].isin(['9', '10', '11', '0'])
            ]
        else:
            conditions = [
                df['decena'].isin(['1', '2', '3']),
                df['decena'].isin(['4', '5', '6']),
                df['decena'].isin(['7', '8', '9']),
                df['decena'].isin(['10', '11', '12', '0'])
            ]
    
        return np.select(conditions, deflact_values, default = df[col_name])

        # Aplicar deflactores utilizando pipe
    def aplicar_deflactores(df):
        for col_name in deflactores.keys():
            df[col_name] = deflactar(df, col_name, deflactores)
        
        return df
    
    # Aplicar funciones utilizando pipe
    return (gastoshogar.copy()
                       .pipe(merge_gastopersonas)
                       .pipe(establecer_base_frecuencia)
                       .pipe(definir_decena)
                       .pipe(convertir_variables)
                       .pipe(seleccionar_rubros)
                       .pipe(controlar_frecuencia_regalos)
                       .pipe(deflactar_rubros)
                       .pipe(aplicar_deflactores))
                  
no_monetario = indicador_no_monetario(gastoshogar)
```

**Se guarda la base de datos** 
```{python}
no_monetario.to_csv(current_directory + '/Output/Data/' + '/ingresonomonetario_def22_2.csv', index = False)
```

**Construcci칩n de la base de pagos en especie a partir de la base de gasto no monetario**  

```{python}
def indicador_pagos_especie(no_monetario):
    # Funci칩n para filtrar pagos en especie
    def filtrar_pagos_especie(df):
        return df[df['esp'] == 1]

    # Funci칩n para agrupar y sumar gastos no monetarios
    def agrupar_y_sumar(df):
        columnas_gasto = ['gasto_nm', 'ali_nm', 'alta_nm', 'veca_nm', 'viv_nm', 'lim_nm', 'cris_nm', 'ens_nm', 
                          'sal_nm', 'tpub_nm', 'tfor_nm', 'com_nm', 'edre_nm', 'edba_nm', 'cuip_nm', 'accp_nm', 
                          'otr_nm', 'reda_nm']
        df_agrupado = df.groupby(['folioviv', 'foliohog'])[columnas_gasto
                                                          ].sum(numeric_only = True).reset_index()
        return df_agrupado
  
    # Funci칩n para renombrar las columnas
    def renombrar_columnas(df):
        nuevas_columnas = ['folioviv', 'foliohog', 'gasto_nm', 'ali_nme', 'alta_nme', 'veca_nme', 'viv_nme', 'lim_nme', 
                           'cris_nme', 'ens_nme', 'sal_nme', 'tpub_nme', 'tfor_nme', 'com_nme', 'edre_nme', 'edba_nme', 
                           'cuip_nme', 'accp_nme', 'otr_nme', 'reda_nme']
        df.columns = nuevas_columnas
        return df

    # Construcci칩n de la base de pagos en especie utilizando pipe
    return (no_monetario.copy()
                        .pipe(filtrar_pagos_especie)
                        .pipe(agrupar_y_sumar)
                        .pipe(renombrar_columnas))

pagos_especie = indicador_pagos_especie(no_monetario)
```

**Se guarda la base de datos** 
```{python}
pagos_especie.to_csv(current_directory + '/Output/Data/' + '/esp_def22_2.csv', index = False)
```


**Construcci칩n de base de regalos a partir de la base no monetaria**  

```{python}
# Construcci칩n de base de regalos a partir de la base no monetaria
regalos = no_monetario[no_monetario['reg'] == 1]

regalos = regalos.groupby(['folioviv', 'foliohog'])[['gasto_nm', 'ali_nm', 'alta_nm', 'veca_nm', 'viv_nm', 'lim_nm', 'cris_nm',
                                                     'ens_nm', 'sal_nm', 'tpub_nm', 'tfor_nm', 'com_nm', 'edre_nm', 'edba_nm',
                                                     'cuip_nm', 'accp_nm', 'otr_nm', 'reda_nm']].sum(numeric_only = True)
regalos = regalos.reset_index()

regalos.columns = ['folioviv', 'foliohog', 'gasto_nm', 'ali_nmr', 'alta_nmr', 'veca_nmr', 'viv_nmr', 'lim_nmr', 'cris_nmr',
                   'ens_nmr', 'sal_nmr', 'tpub_nmr', 'tfor_nmr', 'com_nmr', 'edre_nmr', 'edba_nmr', 'cuip_nmr', 'accp_nmr',
                   'otr_nmr', 'reda_nmr']
```

**Se guarda la base de datos**
```{python}
regalos.to_csv(current_directory + '/Output/Data/' + '/reg_def22.csv', index = False)
```



### Construcci칩n del ingreso corriente total   {.tabset .tabset-pills .top2-tiles} 

#### Ingreso corriente total {.tabset .tabset-pills .top3-tiles}

##### Opci칩n 1  

```{python}
concentradohogar = pd.read_csv(current_directory + "/Bases de datos/concentradohogar.csv", low_memory = False)
ingreso_deflactado = pd.read_csv(current_directory + '/Output/Data/' + '/ingreso_deflactado22.csv', low_memory = False)
pagos_especie = pd.read_csv(current_directory + '/Output/Data/' + '/esp_def22.csv', low_memory = False)
regalos = pd.read_csv(current_directory + '/Output/Data/' + '/reg_def22.csv', low_memory = False)
```

```{python}
ingreso_corriente = concentradohogar[['folioviv', 'foliohog', 'tam_loc', 'factor', 'tot_integ', 'est_dis', 'upm', 'ubica_geo']]

# Incorporaci칩n de la base de ingreso monetario deflactado
ingreso_corriente = pd.merge(ingreso_corriente, 
                              ingreso_deflactado, 
                               on = ['folioviv', 'foliohog'], 
                                how = 'left')

# Incorporaci칩n de la base de ingreso no monetario deflactado: pago en especie
ingreso_corriente = pd.merge(ingreso_corriente,
                              pagos_especie, 
                               on = ['folioviv', 'foliohog'], 
                                how = 'left')

# Incorporaci칩n de la base de ingreso no monetario deflactado: regalos en especie
ingreso_corriente = pd.merge(ingreso_corriente, 
                              regalos,
                               on = ['folioviv', 'foliohog'], 
                                how = 'left')

ingreso_corriente.loc[ingreso_corriente['tam_loc'] == 4, 'rururb'] = 1 # Rural
ingreso_corriente.loc[ingreso_corriente['tam_loc'] <= 3, 'rururb'] = 0 # Urbano

# Ingreso corriente no monetario pago especie
ingreso_corriente['pago_esp'] = ingreso_corriente[['ali_nme', 'alta_nme', 'veca_nme', 'viv_nme', 'lim_nme', 'cris_nme', 'ens_nme', 'sal_nme',
                                                   'tpub_nme', 'tfor_nme', 'com_nme', 'edre_nme', 'cuip_nme', 'accp_nme', 'otr_nme']
                                                  ].sum(axis = 1)

# Ingreso corriente no monetario regalos especie
ingreso_corriente['reg_esp'] = ingreso_corriente[['ali_nmr', 'alta_nmr', 'veca_nmr', 'viv_nmr', 'lim_nmr', 'cris_nmr', 'ens_nmr', 'sal_nmr',
                                                  'tpub_nmr', 'tfor_nmr', 'com_nmr', 'edre_nmr', 'cuip_nmr', 'accp_nmr', 'otr_nmr']
                                                  ].sum(axis = 1)

# Ingreso corriente no monetario
ingreso_corriente['nomon'] = ingreso_corriente[['pago_esp', 'reg_esp']].sum(axis = 1)

# Se construye el Ingreso Corriente Total con el ingreso monetario y el ingreso no monetario 
ingreso_corriente['ict'] = ingreso_corriente[['ing_mon', 'nomon']].sum(axis = 1)

ingreso_corriente = ingreso_corriente[['folioviv', 'foliohog', 'ubica_geo', 'tam_loc', 'est_dis', 'upm', 'factor', 'tot_integ', 'ing_mon',
                                       'ing_lab', 'ing_ren', 'ing_tra', 'ali_nme', 'alta_nme', 'veca_nme', 'viv_nme', 'lim_nme', 'cris_nme',
                                       'ens_nme', 'sal_nme', 'tpub_nme', 'tfor_nme', 'com_nme', 'edre_nme', 'edba_nme', 'cuip_nme', 'accp_nme',
                                       'otr_nme', 'reda_nme', 'ali_nmr', 'alta_nmr', 'veca_nmr', 'viv_nmr', 'lim_nmr', 'cris_nmr', 'ens_nmr',
                                       'sal_nmr', 'tpub_nmr', 'tfor_nmr', 'com_nmr', 'edre_nmr', 'edba_nmr', 'cuip_nmr', 'accp_nmr', 'otr_nmr',
                                       'reda_nmr', 'rururb', 'pago_esp', 'reg_esp', 'nomon', 'ict']]
```

**Se guarda la base de datos**
```{python}
ingreso_corriente.to_csv(current_directory + '/Output/Data/' + '/ingresotot22.csv', index = False)
```

##### Opci칩n 2  

```{python}
concentradohogar = pd.read_csv(current_directory + "/Bases de datos/concentradohogar.csv", low_memory = False)
ingreso_deflactado = pd.read_csv(current_directory + '/Output/Data/' + '/ingreso_deflactado22.csv', low_memory = False)
pagos_especie = pd.read_csv(current_directory + '/Output/Data/' + '/esp_def22.csv', low_memory = False)
regalos = pd.read_csv(current_directory + '/Output/Data/' + '/reg_def22.csv', low_memory = False)
```

```{python}
ingreso_corriente = concentradohogar[['folioviv', 'foliohog', 'tam_loc', 'factor', 'tot_integ', 'est_dis', 'upm', 'ubica_geo']]

# Incorporaci칩n de la base de ingreso monetario deflactado
ingreso_corriente = pd.merge(ingreso_corriente, 
                              ingreso_deflactado, 
                               on = ['folioviv', 'foliohog'], 
                                how = 'left')

# Incorporaci칩n de la base de ingreso no monetario deflactado: pago en especie
ingreso_corriente = pd.merge(ingreso_corriente,
                              pagos_especie, 
                               on = ['folioviv', 'foliohog'], 
                                how = 'left')

# Incorporaci칩n de la base de ingreso no monetario deflactado: regalos en especie
ingreso_corriente = pd.merge(ingreso_corriente, 
                              regalos,
                               on = ['folioviv', 'foliohog'], 
                                how = 'left')

ingreso_corriente.loc[ingreso_corriente['tam_loc'] == 4, 'rururb'] = 1 # Rural
ingreso_corriente.loc[ingreso_corriente['tam_loc'] <= 3, 'rururb'] = 0 # Urbano

# Ingreso corriente no monetario pago especie
ingreso_corriente['pago_esp'] = ingreso_corriente[['ali_nme', 'alta_nme', 'veca_nme', 'viv_nme', 'lim_nme', 'cris_nme', 'ens_nme', 'sal_nme',
                                                   'tpub_nme', 'tfor_nme', 'com_nme', 'edre_nme', 'cuip_nme', 'accp_nme', 'otr_nme']
                                                  ].sum(axis = 1)

# Ingreso corriente no monetario regalos especie
ingreso_corriente['reg_esp'] = ingreso_corriente[['ali_nmr', 'alta_nmr', 'veca_nmr', 'viv_nmr', 'lim_nmr', 'cris_nmr', 'ens_nmr', 'sal_nmr',
                                                  'tpub_nmr', 'tfor_nmr', 'com_nmr', 'edre_nmr', 'cuip_nmr', 'accp_nmr', 'otr_nmr']
                                                  ].sum(axis = 1)

# Ingreso corriente no monetario
ingreso_corriente['nomon'] = ingreso_corriente[['pago_esp', 'reg_esp']].sum(axis = 1)

# Se construye el Ingreso Corriente Total con el ingreso monetario y el ingreso no monetario 
ingreso_corriente['ict'] = ingreso_corriente[['ing_mon', 'nomon']].sum(axis = 1)

ingreso_corriente = ingreso_corriente[['folioviv', 'foliohog', 'ubica_geo', 'tam_loc', 'est_dis', 'upm', 'factor', 'tot_integ', 'ing_mon',
                                       'ing_lab', 'ing_ren', 'ing_tra', 'ali_nme', 'alta_nme', 'veca_nme', 'viv_nme', 'lim_nme', 'cris_nme',
                                       'ens_nme', 'sal_nme', 'tpub_nme', 'tfor_nme', 'com_nme', 'edre_nme', 'edba_nme', 'cuip_nme', 'accp_nme',
                                       'otr_nme', 'reda_nme', 'ali_nmr', 'alta_nmr', 'veca_nmr', 'viv_nmr', 'lim_nmr', 'cris_nmr', 'ens_nmr',
                                       'sal_nmr', 'tpub_nmr', 'tfor_nmr', 'com_nmr', 'edre_nmr', 'edba_nmr', 'cuip_nmr', 'accp_nmr', 'otr_nmr',
                                       'reda_nmr', 'rururb', 'pago_esp', 'reg_esp', 'nomon', 'ict']]
```

**Se guarda la base de datos**
```{python}
ingreso_corriente.to_csv(current_directory + '/Output/Data/' + '/ingresotot22.csv', index = False)
```

#### Construcci칩n del tama침o de hogar con econom칤as de escala y escalas de equivalencia {.tabset .tabset-pills .top2-tiles}  

##### Opci칩n 1 {.tabset .tabset-pills .top3-tiles}  

```{python}
tam_hogar_escala = poblacion.copy()

# Poblaci칩n objetivo: no se incluye a hu칠spedes ni trabajadores dom칠sticos
tam_hogar_escala = tam_hogar_escala.loc[~((tam_hogar_escala['parentesco'] >= 400) & (tam_hogar_escala['parentesco'] < 500) |
                                          (tam_hogar_escala['parentesco'] >= 700) & (tam_hogar_escala['parentesco'] < 800))]

# Total de integrantes del hogar
tam_hogar_escala['ind'] = 1

tam_hogar_escala['tot_ind'] = tam_hogar_escala.groupby(['folioviv', 'foliohog'])['ind'].transform('sum')

# Escalas de equivalencia 
tam_hogar_escala.loc[(tam_hogar_escala['edad'] >= 0) & (tam_hogar_escala['edad'] <= 5), 'n_05'] = 1
tam_hogar_escala.loc[(tam_hogar_escala['edad'] < 0) | (tam_hogar_escala['edad'] > 5), 'n_05'] = 0

tam_hogar_escala.loc[(tam_hogar_escala['edad'] >= 6) & (tam_hogar_escala['edad'] <= 12), 'n_6_12'] = 1
tam_hogar_escala.loc[(tam_hogar_escala['edad'] < 6) | (tam_hogar_escala['edad'] > 12), 'n_6_12'] = 0

tam_hogar_escala.loc[(tam_hogar_escala['edad'] >= 13) & (tam_hogar_escala['edad'] <= 18), 'n_13_18'] = 1
tam_hogar_escala.loc[(tam_hogar_escala['edad'] < 13) | (tam_hogar_escala['edad'] > 18), 'n_13_18'] = 0

tam_hogar_escala.loc[(tam_hogar_escala['edad'] >= 19), 'n_19'] = 1
tam_hogar_escala.loc[(tam_hogar_escala['edad'] < 19), 'n_19'] = 0

tam_hogar_escala.loc[tam_hogar_escala['n_05'] == 1, 'tamhogesc'] = tam_hogar_escala['n_05'] * .7031
tam_hogar_escala.loc[tam_hogar_escala['n_6_12'] == 1, 'tamhogesc'] = tam_hogar_escala['n_6_12'] * .7382
tam_hogar_escala.loc[tam_hogar_escala['n_13_18'] == 1, 'tamhogesc'] = tam_hogar_escala['n_13_18'] * .7057
tam_hogar_escala.loc[tam_hogar_escala['n_19'] == 1, 'tamhogesc'] = tam_hogar_escala['n_19'] * .9945
tam_hogar_escala.loc[tam_hogar_escala['tot_ind'] == 1, 'tamhogesc'] = 1

tam_hogar_escala = tam_hogar_escala.groupby(['folioviv', 'foliohog'])['tamhogesc'].sum().reset_index()
```

**Se guarda la base de datos**
```{python}
tam_hogar_escala.to_csv(current_directory + '/Output/Data/' + '/tamhogesc22.csv', index = False)
```

##### Opci칩n 2 {.tabset .tabset-pills .top3-tiles}  

```{python}
tam_hogar_escala = poblacion.copy()

# Poblaci칩n objetivo: no se incluye a hu칠spedes ni trabajadores dom칠sticos
tam_hogar_escala = tam_hogar_escala.loc[~((tam_hogar_escala['parentesco'] >= 400) & (tam_hogar_escala['parentesco'] < 500) |
                                          (tam_hogar_escala['parentesco'] >= 700) & (tam_hogar_escala['parentesco'] < 800))]

# Total de integrantes del hogar
tam_hogar_escala['ind'] = 1

tam_hogar_escala['tot_ind'] = tam_hogar_escala.groupby(['folioviv', 'foliohog'])['ind'].transform('sum')

# Escalas de equivalencia 
tam_hogar_escala.loc[(tam_hogar_escala['edad'] >= 0) & (tam_hogar_escala['edad'] <= 5), 'n_05'] = 1
tam_hogar_escala.loc[(tam_hogar_escala['edad'] < 0) | (tam_hogar_escala['edad'] > 5), 'n_05'] = 0

tam_hogar_escala.loc[(tam_hogar_escala['edad'] >= 6) & (tam_hogar_escala['edad'] <= 12), 'n_6_12'] = 1
tam_hogar_escala.loc[(tam_hogar_escala['edad'] < 6) | (tam_hogar_escala['edad'] > 12), 'n_6_12'] = 0

tam_hogar_escala.loc[(tam_hogar_escala['edad'] >= 13) & (tam_hogar_escala['edad'] <= 18), 'n_13_18'] = 1
tam_hogar_escala.loc[(tam_hogar_escala['edad'] < 13) | (tam_hogar_escala['edad'] > 18), 'n_13_18'] = 0

tam_hogar_escala.loc[(tam_hogar_escala['edad'] >= 19), 'n_19'] = 1
tam_hogar_escala.loc[(tam_hogar_escala['edad'] < 19), 'n_19'] = 0

tam_hogar_escala.loc[tam_hogar_escala['n_05'] == 1, 'tamhogesc'] = tam_hogar_escala['n_05'] * .7031
tam_hogar_escala.loc[tam_hogar_escala['n_6_12'] == 1, 'tamhogesc'] = tam_hogar_escala['n_6_12'] * .7382
tam_hogar_escala.loc[tam_hogar_escala['n_13_18'] == 1, 'tamhogesc'] = tam_hogar_escala['n_13_18'] * .7057
tam_hogar_escala.loc[tam_hogar_escala['n_19'] == 1, 'tamhogesc'] = tam_hogar_escala['n_19'] * .9945
tam_hogar_escala.loc[tam_hogar_escala['tot_ind'] == 1, 'tamhogesc'] = 1

tam_hogar_escala = tam_hogar_escala.groupby(['folioviv', 'foliohog'])['tamhogesc'].sum().reset_index()
```

**Se guarda la base de datos**
```{python}
tam_hogar_escala.to_csv(current_directory + '/Output/Data/' + '/tamhogesc22.csv', index = False)
```

#### Bienestar econ칩mico {.tabset .tabset-pills .top2-tiles}  

##### Opci칩n 1 {.tabset .tabset-pills .top3-tiles}  

Incorporaci칩n de la informaci칩n sobre el tama침o del hogar ajustado

```{python}
ingreso_corriente = pd.read_csv(current_directory + '/Output/Data/' + '/ingresotot22.csv', low_memory = False)
tam_hogar_escala = pd.read_csv(current_directory + '/Output/Data/' + '/tamhogesc22.csv', low_memory = False)
```

**Indicadores de Bienestar econ칩mico**    

`LP I`: Valor de la Canasta alimentaria   
`LP II`: Valor monetario de la canasta alimentaria m치s el valor monetario de la canasta no alimentaria (ver Anexo A del documento metodol칩gico).    

En este programa se construyen los indicadores de bienestar econ칩mico mediante las 2 l칤neas definidas por CONEVAL, denomin치ndolas:   
  
`lp1` : L칤nea de Pobreza Extrema por Ingresos (`LPEI`)   
`lp2` : L칤nea de Pobreza por Ingresos (`LPI`)    

Para m치s informaci칩n, se sugiere consultar el documento metodol칩gico de Construcci칩n de las l칤neas de pobreza por ingresos. Disponible en: https://www.coneval.org.mx/InformesPublicaciones/InformesPublicaciones/Documents/Lineas_pobreza.pdf     

```{python}
#L칤nea de pobreza extrema por ingresos (LPEI)
# Valor monetario de la canasta alimentaria
lp1_urb = 2086.21
lp1_rur = 1600.18

# L칤nea de pobreza por ingresos (LPI)
# Valor monetario de la canasta alimentaria m치s el valor monetario de la canasta no alimentaria
lp2_urb = 4158.35
lp2_rur = 2970.76
```


```{python}
# Incorporaci칩n de la informaci칩n sobre el tama침o del hogar ajustado
p_ingreso = pd.merge(ingreso_corriente, 
                      tam_hogar_escala, 
                       on = ['folioviv', 'foliohog'], 
                        how = 'left')

# Informaci칩n per c치pita
p_ingreso['ictpc'] = p_ingreso['ict'] / p_ingreso['tamhogesc']     

# Se identifica a los hogares bajo lp1
p_ingreso.loc[(p_ingreso['ictpc'] < lp1_urb) & (p_ingreso['rururb'] == 0), 'plp_e'] = 1
p_ingreso.loc[(p_ingreso['ictpc'] >= lp1_urb) & (p_ingreso['rururb'] == 0), 'plp_e'] = 0
p_ingreso.loc[(p_ingreso['ictpc'] < lp1_rur) & (p_ingreso['rururb'] == 1), 'plp_e'] = 1
p_ingreso.loc[(p_ingreso['ictpc'] >= lp1_rur) & (p_ingreso['rururb'] == 1), 'plp_e'] = 0

# Se identifica a los hogares bajo lp2
p_ingreso.loc[(p_ingreso['ictpc'] < lp2_urb) & (p_ingreso['rururb'] == 0), 'plp'] = 1
p_ingreso.loc[(p_ingreso['ictpc'] >= lp2_urb) & (p_ingreso['rururb'] == 0), 'plp'] = 0
p_ingreso.loc[(p_ingreso['ictpc'] < lp2_rur) & (p_ingreso['rururb'] == 1), 'plp'] = 1
p_ingreso.loc[(p_ingreso['ictpc'] >= lp2_rur) & (p_ingreso['rururb'] == 1), 'plp'] = 0

p_ingreso = p_ingreso[['folioviv', 'foliohog', 'factor', 'tam_loc', 'rururb', 'tamhogesc', 'ict', 'ictpc',
                       'plp_e', 'plp', 'est_dis', 'upm', 'ubica_geo', 'tot_integ', 'ing_mon', 'ing_lab', 'ing_ren',
                       'ing_tra', 'nomon', 'pago_esp', 'reg_esp']]
```


**Se guarda la base de datos**
```{python}
p_ingreso.to_csv(current_directory + '/Output/Data/' + '/p_ingresos22.csv', index = False)
```


##### Opci칩n 2 {.tabset .tabset-pills .top3-tiles}  

Incorporaci칩n de la informaci칩n sobre el tama침o del hogar ajustado

```{python}
ingreso_corriente = pd.read_csv(current_directory + '/Output/Data/' + '/ingresotot22.csv', low_memory = False)
tam_hogar_escala = pd.read_csv(current_directory + '/Output/Data/' + '/tamhogesc22.csv', low_memory = False)
```

**Indicadores de Bienestar econ칩mico**    

`LP I`: Valor de la Canasta alimentaria   
`LP II`: Valor monetario de la canasta alimentaria m치s el valor monetario de la canasta no alimentaria (ver Anexo A del documento metodol칩gico).    

En este programa se construyen los indicadores de bienestar econ칩mico mediante las 2 l칤neas definidas por CONEVAL, denomin치ndolas:   
  
`lp1` : L칤nea de Pobreza Extrema por Ingresos (`LPEI`)   
`lp2` : L칤nea de Pobreza por Ingresos (`LPI`)    

Para m치s informaci칩n, se sugiere consultar el documento metodol칩gico de Construcci칩n de las l칤neas de pobreza por ingresos. Disponible en: https://www.coneval.org.mx/InformesPublicaciones/InformesPublicaciones/Documents/Lineas_pobreza.pdf     

```{python}
#L칤nea de pobreza extrema por ingresos (LPEI)
# Valor monetario de la canasta alimentaria
lp1_urb = 2086.21
lp1_rur = 1600.18

# L칤nea de pobreza por ingresos (LPI)
# Valor monetario de la canasta alimentaria m치s el valor monetario de la canasta no alimentaria
lp2_urb = 4158.35
lp2_rur = 2970.76
```


```{python}
# Incorporaci칩n de la informaci칩n sobre el tama침o del hogar ajustado
p_ingreso = pd.merge(ingreso_corriente, 
                      tam_hogar_escala, 
                       on = ['folioviv', 'foliohog'], 
                        how = 'left')

# Informaci칩n per c치pita
p_ingreso['ictpc'] = p_ingreso['ict'] / p_ingreso['tamhogesc']     

# Se identifica a los hogares bajo lp1
p_ingreso.loc[(p_ingreso['ictpc'] < lp1_urb) & (p_ingreso['rururb'] == 0), 'plp_e'] = 1
p_ingreso.loc[(p_ingreso['ictpc'] >= lp1_urb) & (p_ingreso['rururb'] == 0), 'plp_e'] = 0
p_ingreso.loc[(p_ingreso['ictpc'] < lp1_rur) & (p_ingreso['rururb'] == 1), 'plp_e'] = 1
p_ingreso.loc[(p_ingreso['ictpc'] >= lp1_rur) & (p_ingreso['rururb'] == 1), 'plp_e'] = 0

# Se identifica a los hogares bajo lp2
p_ingreso.loc[(p_ingreso['ictpc'] < lp2_urb) & (p_ingreso['rururb'] == 0), 'plp'] = 1
p_ingreso.loc[(p_ingreso['ictpc'] >= lp2_urb) & (p_ingreso['rururb'] == 0), 'plp'] = 0
p_ingreso.loc[(p_ingreso['ictpc'] < lp2_rur) & (p_ingreso['rururb'] == 1), 'plp'] = 1
p_ingreso.loc[(p_ingreso['ictpc'] >= lp2_rur) & (p_ingreso['rururb'] == 1), 'plp'] = 0

p_ingreso = p_ingreso[['folioviv', 'foliohog', 'factor', 'tam_loc', 'rururb', 'tamhogesc', 'ict', 'ictpc',
                       'plp_e', 'plp', 'est_dis', 'upm', 'ubica_geo', 'tot_integ', 'ing_mon', 'ing_lab', 'ing_ren',
                       'ing_tra', 'nomon', 'pago_esp', 'reg_esp']]
```


**Se guarda la base de datos**
```{python}
p_ingreso.to_csv(current_directory + '/Output/Data/' + '/p_ingresos22.csv', index = False)
```

## Pobreza multidimensional  {.tabset .tabset-pills .top3-tiles} 

### Integraci칩n de las bases  

**Se vuelven a cargar las bases de datos**  

```{python}
# Rezago eductivo 
rezago_educativo = pd.read_csv(current_directory + '/Output/Data/' + '/ic_rezedu22.csv', low_memory = False)
# Carencia por acceso a los servicios de salud
salud = pd.read_csv(current_directory + '/Output/Data/' + '/ic_asalud22.csv', low_memory = False)
# Carencia por acceso a la seguridad social
seguridad_social = pd.read_csv(current_directory + '/Output/Data/' + '/ic_segsoc22.csv', low_memory = False)
# Carencia por calidad y espacios de la vivienda
calidad_viviendas = pd.read_csv(current_directory + '/Output/Data/' + '/ic_cev22.csv', low_memory = False)
# Carencia por acceso a los servicios b치sicos de la vivienda
servicios_basicos = pd.read_csv(current_directory + '/Output/Data/' + '/ic_sbv22.csv', low_memory = False)
# Carencia por acceso a la alimentaci칩n nutritiva y de calidad 
alimentacion = pd.read_csv(current_directory + '/Output/Data/' + '/ic_ali22.csv', low_memory = False)
# L칤nea de pobreza por ingresos (LPI)
p_ingreso = pd.read_csv(current_directory + '/Output/Data/' + '/p_ingresos22.csv', low_memory = False)
```


#### Opci칩n 1 {.tabset .tabset-pills .top4-tiles}  

Se integran las seis bases de datos.  

```{python}
pobreza = pd.merge(rezago_educativo, 
                    salud, 
                     on = ['folioviv', 'foliohog', 'numren'], 
                      how = 'left')
pobreza = pd.merge(pobreza, 
                    seguridad_social, 
                     on = ['folioviv', 'foliohog', 'numren'], 
                      how = 'left')
pobreza = pd.merge(pobreza, 
                    calidad_viviendas, 
                     on = ['folioviv', 'foliohog'], 
                      how = 'left')
pobreza = pd.merge(pobreza, 
                    servicios_basicos, 
                     on = ['folioviv', 'foliohog'], 
                      how = 'left')
pobreza = pd.merge(pobreza, 
                    alimentacion, 
                     on = ['folioviv', 'foliohog'], 
                      how = 'left')
pobreza = pd.merge(pobreza, 
                    p_ingreso, 
                     on = ['folioviv', 'foliohog'], 
                      how = 'left')

pobreza['ing_mon'].fillna(0, inplace = True)
pobreza['ing_lab'].fillna(0, inplace = True)
pobreza['ing_ren'].fillna(0, inplace = True)
pobreza['ing_tra'].fillna(0, inplace = True)

# Se eliminan posibles duplicados
pobreza = pobreza.drop_duplicates(subset = ['folioviv', 'foliohog', 'numren'], keep = 'first', index = False)

pobreza['folioviv'] = pobreza['folioviv'].astype(str).str.zfill(10)
pobreza['ent'] = pobreza['folioviv'].str[:2].astype(int)

entidad = {
           1: 'Aguascalientes',
           2: 'Baja California',
           3: 'Baja California Sur',
           4: 'Campeche',
           5: 'Coahuila',
           6: 'Colima',
           7: 'Chiapas',
           8: 'Chihuahua',
           9: 'Ciudad de M칠xico',
           10: 'Durango',
           11: 'Guanajuato',
           12: 'Guerrero',
           13: 'Hidalgo',
           14: 'Jalisco',
           15: 'M칠xico',
           16: 'Michoac치n',
           17: 'Morelos',
           18: 'Nayarit',
           19: 'Nuevo Le칩n',
           20: 'Oaxaca',
           21: 'Puebla',
           22: 'Quer칠taro',
           23: 'Quintana Roo',
           24: 'San Luis Potos칤',
           25: 'Sinaloa',
           26: 'Sonora',
           27: 'Tabasco',
           28: 'Tamaulipas',
           29: 'Tlaxcala',
           30: 'Veracruz',
           31: 'Yucat치n',
           32: 'Zacatecas'}
           
pobreza['entidad'] = pobreza['ent'].map(entidad)
```


### 칈ndice de Privaci칩n Social {.tabset .tabset-pills .top3-tiles} 

#### Opci칩n 1 {.tabset .tabset-pills .top4-tiles} 

```{python}
pobreza['i_privacion'] = pobreza[['ic_rezedu', 'ic_asalud', 'ic_segsoc', 'ic_cv', 'ic_sbv', 'ic_ali_nc']].sum(axis = 1)

pobreza.loc[pobreza['ic_rezedu'].isna() |
             pobreza['ic_asalud'].isna() |
              pobreza['ic_segsoc'].isna() |
               pobreza['ic_cv'].isna() |
                pobreza['ic_sbv'].isna() |
                 pobreza['ic_ali'].isna(), 'i_privacion'] = np.NaN
```


### Pobreza multidimensional {.tabset .tabset-pills .top3-tiles}  

#### Opci칩n 1 {.tabset .tabset-pills .top4-tiles}  

```{python}
# Pobreza
pobreza.loc[(pobreza['plp'] == 1) &
             (pobreza['i_privacion'] >= 1) &
              (~pobreza['i_privacion'].isna()), 'pobreza'] = 1 # Pobre
pobreza.loc[((pobreza['plp'] == 0) | (pobreza['i_privacion'] == 0)) &
             (~pobreza['plp'].isna()) &
              (~pobreza['i_privacion'].isna()), 'pobreza'] = 0 # No pobre

# Pobreza extrema
pobreza.loc[(pobreza['plp_e'] == 1) &
             (pobreza['i_privacion'] >= 3) &
              (~pobreza['i_privacion'].isna()), 'pobreza_e'] = 1 # Pobre extremo
pobreza.loc[((pobreza['plp_e'] == 0) | (pobreza['i_privacion'] < 3)) &
             (~pobreza['plp_e'].isna()) &
              (~pobreza['i_privacion'].isna()), 'pobreza_e'] = 0 # No pobre extremo

# Pobreza moderada
pobreza.loc[(pobreza['pobreza'] == 1) &
             (pobreza['pobreza_e'] == 0), 'pobreza_m'] = 1 # Pobre moderado
pobreza.loc[(pobreza['pobreza'] == 0) | ((pobreza['pobreza'] == 1) &
             (pobreza['pobreza_e'] == 1)), 'pobreza_m'] = 0 # No pobre moderado
```


### Poblaci칩n vulnerable {.tabset .tabset-pills .top3-tiles}  

#### Opci칩n 1 {.tabset .tabset-pills .top4-tiles}  

```{python}
# Vulnerables por carencias
pobreza['vul_car'] = 0  
pobreza.loc[(pobreza['plp'] == 0) &
             (pobreza['i_privacion'] >= 1) &
              (~pobreza['i_privacion'].isna()), 'vul_car'] = 1 # Vulnerable
pobreza.loc[pd.isna(pobreza['pobreza']), 'vul_car'] = pd.NA # No vulnerable

# Vulnerables por ingresos
pobreza['vul_ing'] = 0  
pobreza.loc[(pobreza['plp'] == 1) &
             (pobreza['i_privacion'] == 0), 'vul_ing'] = 1 # Vulnerable
pobreza.loc[pd.isna(pobreza['pobreza']), 'vul_ing'] = pd.NA # No vulnerable
```


### Poblaci칩n no pobre y no vulnerable {.tabset .tabset-pills .top3-tiles}  

#### Opci칩n 1 {.tabset .tabset-pills .top4-tiles}  

```{python}
# Poblaci칩n no pobre y no vulnerable
pobreza['no_pobv'] = 0  
pobreza.loc[(pobreza['plp'] == 0) &
             (pobreza['i_privacion'] == 0), 'no_pobv'] = 1 # Vulnerable
pobreza.loc[pd.isna(pobreza['pobreza']), 'no_pobv'] = pd.NA # No vulnerable
```


### Poblaci칩n con carencias sociales {.tabset .tabset-pills .top3-tiles}  

#### Opci칩n 1 {.tabset .tabset-pills .top4-tiles}    

```{python}
# Poblaci칩n con al menos una carencia
pobreza['carencias'] = 0
pobreza.loc[(pobreza['i_privacion'] >= 1) &
             (~pobreza['i_privacion'].isna()), 'carencias'] = 1 # Poblaci칩n con al menos una carencia social
pobreza.loc[pd.isna(pobreza['pobreza']), 'carencias'] = pd.NA # Poblaci칩n sin carencias sociales

# Poblaci칩n con tres o m치s carencias
pobreza['carencias3'] = 0
pobreza.loc[(pobreza['i_privacion'] >= 3) &
             (~pobreza['i_privacion'].isna()), 'carencias3'] = 1 # Poblaci칩n con al menos tres carencias sociales
pobreza.loc[pd.isna(pobreza['pobreza']), 'carencias3'] = pd.NA # Poblaci칩n con menos de tres carencias sociales
```


### Cuadrantes {.tabset .tabset-pills .top3-tiles}  

#### Opci칩n 1 {.tabset .tabset-pills .top4-tiles}  

```{python}
pobreza['cuadrantes'] = np.NaN
pobreza.loc[(pobreza['plp'] == 1) &
             (pobreza['i_privacion'] >= 1) &
              (~pobreza['i_privacion'].isna()), 'cuadrantes'] = 1 # Pobres
pobreza.loc[(pobreza['plp'] == 0) &
             (pobreza['i_privacion'] >= 1) &
              (~pobreza['i_privacion'].isna()), 'cuadrantes'] = 2 # Vulnerables por carencias
pobreza.loc[(pobreza['plp'] == 1) &
             (pobreza['i_privacion'] == 0), 'cuadrantes'] = 3 # Vulnerables por ingresos 
pobreza.loc[(pobreza['plp'] == 0) &
             (pobreza['i_privacion'] == 0), 'cuadrantes'] = 4 # No pobres y no vulnerables
```


### Profundidad en el espacio del bienestar econ칩mico {.tabset .tabset-pills .top3-tiles}  

#### Opci칩n 1 {.tabset .tabset-pills .top4-tiles}    

```{python}
#L칤nea de pobreza extrema por ingresos (LPEI)
# Valor monetario de la canasta alimentaria
lp1_urb = 2086.21
lp1_rur = 1600.18

# L칤nea de pobreza por ingresos (LPI)
# Valor monetario de la canasta alimentaria m치s el valor monetario de la canasta no alimentaria
lp2_urb = 4158.35
lp2_rur = 2970.76
```


```{python}
# FGT (a=1)
# Distancia normalizada del ingreso respecto a la l칤nea de pobreza por ingresos
pobreza.loc[(pobreza['rururb'] == 1) &
             (pobreza['plp'] == 1), 'prof1'] = (lp2_rur - pobreza['ictpc']) / lp2_rur
pobreza.loc[(pobreza['rururb'] == 0) &
             (pobreza['plp'] == 1), 'prof1'] = (lp2_urb - pobreza['ictpc']) / lp2_urb
pobreza.loc[(pobreza['prof1'].isna()) &
             (pobreza['ictpc'].notna()), 'prof1'] = 0

# Distancia normalizada del ingreso respecto a la l칤nea de pobreza extrema por ingresos
pobreza.loc[(pobreza['rururb'] == 1) &
             (pobreza['plp_e'] == 1), 'prof_e1'] = (lp1_rur - pobreza['ictpc']) / lp1_rur
pobreza.loc[(pobreza['rururb'] == 0) &
             (pobreza['plp_e'] == 1), 'prof_e1'] = (lp1_urb - pobreza['ictpc']) / lp1_urb
pobreza.loc[(pobreza['prof_e1'].isna()) &
             (pobreza['ictpc'].notna()), 'prof_e1'] = 0
```


### Profundidad de la privaci칩n social {.tabset .tabset-pills .top3-tiles}  

#### Opci칩n 1 {.tabset .tabset-pills .top4-tiles}    

```{python}
pobreza['profun'] = pobreza['i_privacion'] / 6

#   Intensidad de la privaci칩n social      
            
# Intensidad de la privaci칩n social: pobres
pobreza['int_pob'] = pobreza['profun']*pobreza['pobreza']

# Intensidad de la privaci칩n social: pobres extremos
pobreza['int_pobe']= pobreza['profun']*pobreza['pobreza_e']

# Intensidad de la privaci칩n social: poblaci칩n vulnerable por carencias
pobreza['int_vulcar']=pobreza['profun']*pobreza['vul_car']

# Intensidad de la privaci칩n social: poblaci칩n con carencias sociales
pobreza['int_caren'] = pobreza['profun'] * pobreza['carencias']

pobreza = pobreza[['folioviv', 'foliohog', 'numren', 'est_dis', 'upm', 'factor', 'tam_loc', 'rururb', 'ent', 'ubica_geo',
                   'edad', 'sexo', 'parentesco', 'ic_rezedu', 'anac_e', 'inas_esc', 'niv_ed', 'ic_asalud', 'ic_segsoc', 'sa_dir',
                   'ss_dir', 's_salud', 'par', 'jef_ss', 'cony_ss', 'hijo_ss', 'pea', 'jub', 'pam', 'ing_pam', 'ic_cv', 'icv_pisos',
                   'icv_muros', 'icv_techos', 'icv_hac', 'ic_sbv', 'isb_agua', 'isb_dren', 'isb_luz', 'isb_combus', 'ic_ali_nc',
                   'id_men', 'tot_iaad', 'tot_iamen', 'ins_ali', 'ic_ali', 'lca', 'dch', 'plp_e', 'plp', 'pobreza', 'pobreza_e',
                   'pobreza_m', 'vul_car', 'vul_ing', 'no_pobv', 'i_privacion', 'carencias', 'carencias3', 'cuadrantes', 'prof1',
                   'prof_e1', 'profun', 'int_pob', 'int_pobe', 'int_vulcar', 'int_caren', 'tamhogesc', 'ictpc', 'ict', 'ing_mon',
                   'ing_lab', 'ing_ren', 'ing_tra', 'nomon', 'pago_esp', 'reg_esp', 'hli', 'discap']]
```

**Se guarda la base de datos**
```{python}
pobreza.to_csv(current_directory + '/Output/Data/' + 'pobreza_22.csv', index = False)
```

## Resultados 

### Nivel nacional 

```{python}
base = pobreza[~np.isnan(pobreza['pobreza'])]
base_pobreza = pobreza[pobreza['pobreza'] == 1]

nac= [
      ['pobreza', np.average(a = base['pobreza'], 
                             weights  = base['factor']) * 100 ,
                  np.average(a = base[base['pobreza'] == 1]['pobreza'], 
                             weights = base[base['pobreza'] == 1]['factor'], returned = True)[1]/1000000],     
      ['pobreza_m', np.average(a = base['pobreza_m'], 
                               weights = base['factor']) * 100 ,
                    np.average(a = base[base['pobreza_m'] == 1]['pobreza_m'], 
                               weights = base[base['pobreza_m'] == 1]['factor'], returned = True)[1]/1000000], 
      ['pobreza_e', np.average(a = base['pobreza_e'], 
                               weights  = pobreza[~np.isnan(pobreza['pobreza_e'])]['factor']) * 100 ,
                    np.average(a = base[base['pobreza_e'] == 1]['pobreza_e'], 
                               weights = base[base['pobreza_e'] == 1]['factor'], returned = True)[1]/1000000],     
      ['vul_car', np.average(a = base['vul_car'], 
                             weights = pobreza[~np.isnan(pobreza['vul_car'] )]['factor']) * 100 ,
                  np.average(a = base[base['vul_car'] == 1]['vul_car'], 
                             weights = base[base['vul_car'] == 1]['factor'], returned = True)[1]/1000000],
      ['vul_ing', np.average(a = base['vul_ing'], 
                             weights = pobreza[~np.isnan(pobreza['vul_car'])]['factor']) * 100 ,
                  np.average(a = base[base['vul_ing'] == 1]['vul_ing'], 
                             weights = base[base['vul_ing'] == 1]['factor'], returned = True)[1]/1000000],      
      ['no_pobv', np.average(a = base['no_pobv'], 
                             weights = pobreza[~np.isnan(pobreza['no_pobv'])]['factor']) * 100 ,
                  np.average(a = base[base['no_pobv'] == 1]['no_pobv'], 
                             weights = base[base['no_pobv'] == 1]['factor'], returned = True)[1]/1000000], 
      ['carencias', np.average(a = base['carencias'], 
                               weights=pobreza[~np.isnan(pobreza['carencias'])]['factor']) * 100 ,
                    np.average(a = base[base['carencias'] == 1]['carencias'], 
                               weights = base[base['carencias'] == 1]['factor'], returned = True)[1]/1000000],
      ['carencias3', np.average(a = base['carencias3'], 
                                weights=pobreza[~np.isnan(pobreza['carencias3'])]['factor']) * 100 ,
                     np.average(a = base[base['carencias3'] == 1]['carencias3'], 
                                weights = base[base['carencias3'] == 1]['factor'], returned = True)[1]/1000000],  
      ['ic_rezedu', np.average(a = base['ic_rezedu'], 
                               weights = base['factor']) * 100 ,
                    np.average(a = base[base['ic_rezedu'] == 1]['ic_rezedu'], 
                               weights = base[base['ic_rezedu'] == 1]['factor'], returned = True)[1]/1000000],     
      ['ic_asalud', np.average(a = base['ic_asalud'], 
                               weights = base['factor']) * 100 ,
                    np.average(a = base[base['ic_asalud'] == 1]['ic_asalud'], 
                               weights = base[base['ic_asalud'] == 1]['factor'], returned = True)[1]/1000000], 
      ['ic_segsoc', np.average(a = base['ic_segsoc'], 
                               weights = base['factor']) * 100 ,
                    np.average(a = base[base['ic_segsoc'] == 1]['ic_segsoc'], 
                               weights = base[base['ic_segsoc'] == 1]['factor'], returned = True)[1]/1000000],       
      ['ic_cv', np.average(a = base['ic_cv'], 
                           weights = base['factor']) * 100 , 
                np.average(a = base[base['ic_cv'] == 1]['ic_cv'], 
                           weights = base[base['ic_cv'] == 1]['factor'], returned = True)[1]/1000000],         
      ['ic_sbv', np.average(a = base['ic_sbv'], 
                            weights = base['factor']) * 100 ,
                 np.average(a = base[base['ic_sbv'] == 1]['ic_sbv'], 
                            weights = base[base['ic_sbv'] == 1]['factor'], returned = True)[1]/1000000],            
      ['ic_ali_nc', np.average(a = base['ic_ali_nc'], 
                               weights = base['factor']) * 100 ,
                    np.average(a = base[base['ic_ali_nc'] == 1]['ic_ali_nc'], 
                               weights = base[base['ic_ali_nc'] == 1]['factor'], returned = True)[1]/1000000],      
      ['plp_e', np.average(a = base['plp_e'], 
                           weights = base['factor']) * 100 ,
                np.average(a = base[base['plp_e'] == 1]['plp_e'], 
                           weights = base[base['plp_e'] == 1]['factor'], returned = True)[1]/1000000],
      ['plp', np.average(a = base['plp'], 
                         weights = base['factor']) * 100 ,
              np.average(a = base[base['plp'] == 1]['plp'], 
                         weights = base[base['plp'] == 1]['factor'], returned = True)[1]/1000000]]

titulos = ['Indicador', 'Porcentaje', 'Millones de personas']

print(tabulate(nac, titulos, tablefmt = 'grid', floatfmt = ('.6f')))
```

**Se guarda la base de datos**
```{python}
nac = pd.DataFrame(nac)
nac.to_csv(current_directory + '/Output/' + 'indice de pobreza a nivel nacional.csv', index = False)
```

### Porcentaje y n칰mero de personas por indicador de pobreza, entidad federativa.   

```{python}
ids = np.unique(pobreza['ent'])

pob_ent_por =[list(j) for j in  zip([np.average(a = base[base['ent'] == i]['pobreza'], 
                                                weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                    [np.average(a = base[base['ent'] == i]['pobreza_m'], 
                                                weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                    [np.average(a = base[base['ent'] == i]['pobreza_e'], 
                                                weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                    [np.average(a = base[base['ent'] == i]['vul_car'], 
                                                weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                    [np.average(a = base[base['ent'] == i]['vul_ing'], 
                                                weights = base[base['ent'] == i]['factor']) * 100 for i in ids])]

titulos = ['pobreza', 'pobreza_m', 'pobreza_e', 'vul_car', 'vul_ing', 'no_pobv']   

print(tabulate(pob_ent_por, titulos, floatfmt = ('.6f')))    

pob_ent_tot =[list(j) for j in  zip([np.average(a = base[base['pobreza'] == 1][base['ent'] == i]['pobreza'], 
                                                weights = base[base['pobreza'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],         
                                    [np.average(a = base[base['pobreza_m'] == 1][base['ent'] == i]['pobreza_m'], 
                                                weights = base[base['pobreza_m'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                    [np.average(a = base[base['pobreza_e'] == 1][base['ent'] == i]['pobreza_e'], 
                                                weights = base[base['pobreza_e'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                    [np.average(a = base[base['vul_car'] == 1][base['ent'] == i]['vul_car'], 
                                                weights = base[base['vul_car'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                    [np.average(a = base[base['vul_ing'] == 1][base['ent'] == i]['vul_ing'], 
                                                weights = base[base['vul_ing'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids])]

print(tabulate(pob_ent_tot, titulos, floatfmt = ('.0f')))    
```


**Se guarda la base de datos**
```{python}
pob_ent_tot = pd.DataFrame(pob_ent_tot)
pob_ent_tot.to_csv(current_directory + '/Output/' + 'indice de pobreza a nivel estatal.csv', index = False)
```

### Porcentaje y n칰mero de personas por indicador de carencia social, entidad federativa.    

```{python}
ids = np.unique(pobreza['ent'])

care_ent_por =[list(j) for j in  zip([np.average(a = base[base['ent'] == i]['ic_rezedu'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                     [np.average(a = base[base['ent'] == i]['ic_asalud'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                     [np.average(a = base[base['ent'] == i]['ic_segsoc'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                     [np.average(a = base[base['ent'] == i]['ic_cv'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                     [np.average(a = base[base['ent'] == i]['ic_sbv'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                     [np.average(a = base[base['ent'] == i]['ic_ali_nc'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                     [np.average(a = base[base['ent'] == i]['carencias'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                     [np.average(a = base[base['ent'] == i]['carencias3'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                     [np.average(a = base[base['ent'] == i]['plp_e'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids],
                                     [np.average(a = base[base['ent'] == i]['plp'], 
                                                 weights = base[base['ent'] == i]['factor']) * 100 for i in ids])]

titulos = ['ic_rezedu', 'ic_asalud', 'ic_segsoc', 'ic_cv', 'ic_sbv', 'ic_ali_nc', 'carencias', 'carencias3', 'plp_e', 'plp']   

print(tabulate(care_ent_por, titulos,floatfmt=('.6f')))    

care_ent_tot =[list(j) for j in  zip([np.average(a = base[base['ic_rezedu'] == 1][base['ent'] == i]['ic_rezedu'], 
                                                 weights = base[base['ic_rezedu'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],           
                                     [np.average(a = base[base['ic_asalud'] == 1][base['ent'] == i]['ic_asalud'], 
                                                 weights = base[base['ic_asalud'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                     [np.average(a = base[base['ic_segsoc'] == 1][base['ent'] == i]['ic_segsoc'], 
                                                 weights = base[base['ic_segsoc'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                     [np.average(a = base[base['ic_cv'] == 1][base['ent'] == i]['ic_cv'], 
                                                 weights = base[base['ic_cv'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                     [np.average(a = base[base['ic_sbv'] == 1][base['ent'] == i]['ic_sbv'], 
                                                 weights = base[base['ic_sbv'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                     [np.average(a = base[base['ic_ali_nc'] == 1][base['ent'] == i]['ic_ali_nc'], 
                                                 weights = base[base['ic_ali_nc'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                     [np.average(a = base[base['carencias'] == 1][base['ent'] == i]['carencias'], 
                                                 weights = base[base['carencias'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                     [np.average(a = base[base['carencias3'] == 1][base['ent'] == i]['carencias3'], 
                                                 weights = base[base['carencias3'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                     [np.average(a = base[base['plp_e'] == 1][base['ent'] == i]['plp_e'], 
                                                 weights = base[base['plp_e'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids],
                                     [np.average(a = base[base['plp'] == 1][base['ent'] == i]['plp'], 
                                                 weights = base[base['plp'] == 1][base['ent'] == i]['factor'], returned = True)[1] for i in ids])]

titulos = ['ic_rezedu', 'ic_asalud', 'ic_segsoc', 'ic_cv', 'ic_sbv', 'ic_ali_nc', 'carencias', 'carencias3', 'plp_e', 'plp']   

print(tabulate(care_ent_tot, titulos, floatfmt = ('.0f')))
```


**Se guarda la base de datos**
```{python}
care_ent_tot = pd.DataFrame(care_ent_tot)
care_ent_tot.columns = ['ic_rezedu', 'ic_asalud', 'ic_segsoc', 'ic_cv', 'ic_sbv', 'ic_ali_nc', 'carencias', 'carencias3', 'plp_e', 'plp']   
care_ent_tot.to_csv(current_directory + '/Output/' + 'indicadores de carencia a nivel estatal.csv', index = False)
```
